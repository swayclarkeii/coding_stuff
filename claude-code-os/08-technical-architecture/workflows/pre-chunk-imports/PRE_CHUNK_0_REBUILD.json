{
  "name": "AMA Pre-Chunk 0: Intake & Client Identification",
  "active": false,
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        },
        "simple": false,
        "filters": {
          "labelIds": [
            "INBOX",
            "UNREAD",
            "Label_8011160688574026773"
          ],
          "q": "has:attachment"
        },
        "options": {
          "dataPropertyAttachmentsPrefixName": "attachment_",
          "downloadAttachments": true
        }
      },
      "name": "Gmail Trigger - Unread with Attachments",
      "type": "n8n-nodes-base.gmailTrigger",
      "typeVersion": 1.3,
      "position": [
        112,
        480
      ],
      "id": "gmail-trigger-001",
      "credentials": {
        "gmailOAuth2": {
          "id": "aYzk7sZF8ZVyfOan",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Filter PDF and ZIP attachments only\nconst items = $input.all();\nconst filtered = [];\n\nfor (const item of items) {\n  // Gmail trigger stores attachments in item.binary, not item.json.attachments\n  if (!item.binary) continue;\n  \n  // Iterate over binary keys (attachment_0, attachment_1, etc.)\n  for (const [key, attachment] of Object.entries(item.binary)) {\n    const filename = attachment.fileName;\n    if (!filename) continue;\n    \n    const ext = filename.toLowerCase().split('.').pop();\n    \n    if (['pdf', 'zip'].includes(ext)) {\n      filtered.push({\n        json: {\n          emailId: item.json.id,\n          emailSubject: item.json.Subject || item.json.subject,\n          emailFrom: item.json.From || item.json.from,\n          emailDate: item.json.date,\n          attachmentKey: key,\n          filename: filename,\n          mimeType: attachment.mimeType,\n          size: attachment.fileSize\n        },\n        binary: {\n          data: attachment\n        }\n      });\n    }\n  }\n}\n\nreturn filtered;"
      },
      "name": "Filter PDF/ZIP Attachments",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        336,
        480
      ],
      "id": "filter-attachments-001"
    },
    {
      "parameters": {
        "name": "={{ $json.filename }}",
        "driveId": {
          "__rl": true,
          "mode": "list",
          "value": "My Drive"
        },
        "folderId": {
          "__rl": true,
          "mode": "id",
          "value": "1ikw3k-EgpVg_h2ySDdqdUFB7-FQyYDFm"
        },
        "options": {},
        "operation": "upload"
      },
      "id": "upload-pdf-gdrive-001",
      "name": "Upload PDF to Temp Folder",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        560,
        480
      ],
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "a4m50EefR3DJoU0R",
          "name": "Google Drive account"
        }
      },
      "notes": "Uploads PDF to temp folder and returns Google Drive file ID. This replaces binary data passing."
    },
    {
      "parameters": {
        "jsCode": "// Extract Google Drive file ID from upload response and preserve email metadata\nconst uploadResult = $input.first().json;\nconst emailData = $('Filter PDF/ZIP Attachments').first().json;\n\nreturn [{\n  json: {\n    file_id: uploadResult.id,\n    filename: uploadResult.name,\n    emailId: emailData.emailId,\n    emailSubject: emailData.emailSubject,\n    emailFrom: emailData.emailFrom,\n    emailDate: emailData.emailDate\n  }\n}];"
      },
      "id": "extract-file-id-001",
      "name": "Extract File ID & Metadata",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        784,
        480
      ],
      "notes": "Extracts Google Drive file ID and preserves email metadata for downstream processing"
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "mode": "id",
          "value": "={{ $json.file_id }}"
        },
        "options": {}
      },
      "id": "download-pdf-from-gdrive-001",
      "name": "Download PDF from Drive",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        784,
        640
      ],
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "a4m50EefR3DJoU0R",
          "name": "Google Drive account"
        }
      },
      "notes": "Downloads PDF binary using file_id for text extraction"
    },
    {
      "parameters": {
        "operation": "pdf",
        "options": {
          "joinPages": true,
          "keepSource": "json"
        }
      },
      "name": "Extract Text from PDF",
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1.1,
      "position": [
        1008,
        480
      ],
      "id": "extract-text-001"
    },
    {
      "parameters": {
        "jsCode": " // V4: Evaluate extraction quality for each PDF\n  const items = $input.all();\n  const results = [];\n\n  for (const item of items) {\n    const extractedText = item.json.text || '';\n    const wordCount = extractedText.trim().split(/\\s+/).length;\n\n    results.push({\n      json: {\n        ...item.json,\n        wordCount: wordCount,\n        needsOCR: wordCount < 10,\n        extractionQuality: wordCount < 10 ? 'poor' : 'good',\n        \n        // NEW: Keep extracted text for downstream use\n        extractedText: extractedText,\n        textLength: extractedText.trim().length,\n        extractionMethod: 'digital_pre_chunk'\n      },\n      binary: item.binary  // ✅ Pass through binary data\n    });\n  }\n\n  return results;"
      },
      "name": "Evaluate Extraction Quality",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1008,
        480
      ],
      "id": "evaluate-extraction-001",
      "notes": "Checks if text extraction succeeded. If <10 words, flags for OCR (AWS Textract)"
    },
    {
      "parameters": {
        "resource": "chat",
        "prompt": {
          "messages": [
            {
              "role": "system",
              "content": "You are an AI that extracts client company names from German real estate documents. Extract ONLY the client/investor company name. Return the name without any explanation or additional text."
            },
            {
              "content": "=Extract the client company name from this text:\n\n={{ $json.text }}"
            }
          ]
        },
        "options": {
          "maxTokens": 50,
          "temperature": 0.1
        },
        "requestOptions": {}
      },
      "name": "AI Extract Client Name",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1.1,
      "position": [
        1232,
        480
      ],
      "id": "ai-extract-client-001",
      "credentials": {
        "openAiApi": {
          "id": "xmJ7t6kaKgMwA1ce",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get all input items\nconst items = $input.all();\nconst results = [];\n\n// Process each item\nfor (const item of items) {\n  let clientNameRaw = '';\n  \n  // Extract AI response from OpenAI Chat node output\n  if (item.json && item.json.message && item.json.message.content) {\n    clientNameRaw = String(item.json.message.content);\n  } else if (item.json && item.json.text) {\n    clientNameRaw = String(item.json.text);\n  }\n  \n  clientNameRaw = clientNameRaw.trim();\n  \n  // Normalize German client name for folder creation\n  let clientNormalized = '';\n  if (clientNameRaw) {\n    clientNormalized = clientNameRaw\n      .toLowerCase()\n      .trim()\n      .replace(/ä/g, 'ae')\n      .replace(/ö/g, 'oe')\n      .replace(/ü/g, 'ue')\n      .replace(/ß/g, 'ss')\n      .replace(/\\s*(gmbh|ag|kg|e\\.v\\.|mbh|co\\.|&\\s*co\\.?)\\s*/gi, '')\n      .replace(/[^a-z0-9]/g, '_')\n      .replace(/_+/g, '_')\n      .replace(/^_|_$/g, '');\n  }\n  \n  results.push({\n    json: {\n      client_name_raw: clientNameRaw,\n      client_normalized: clientNormalized,\n      parent_folder_id: '1ikw3k-EgpVg_h2ySDdqdUFB7-FQyYDFm'\n    }\n  });\n}\n\nreturn results;"
      },
      "name": "Normalize Client Name",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1456,
        480
      ],
      "id": "normalize-name-001"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "mode": "id",
          "value": "1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI"
        },
        "sheetName": {
          "__rl": true,
          "mode": "list",
          "value": 762792134,
          "cachedResultName": "Client_Registry",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI/edit#gid=762792134"
        },
        "options": {}
      },
      "name": "Lookup Client Registry",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        1680,
        480
      ],
      "id": "lookup-registry-001",
      "alwaysOutputData": true,
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "H7ewI1sOrDYabelt",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// V5: Check if client exists in Client_Registry\n// CRITICAL FIX V2: Detect polite AI refusals (\"I'm sorry...\", \"doesn't seem to be...\")\n\n// Get normalized client name from Normalize Client Name node (not from $input!)\nconst normalizeOutput = $('Normalize Client Name').first().json;\nconst clientNormalized = normalizeOutput.client_normalized || '';\nconst clientNameRaw = normalizeOutput.client_name_raw || '';\nconst parentFolderId = normalizeOutput.parent_folder_id || '';\n\n// Get registry rows from $input (Lookup Client Registry output)\nconst registryRows = $input.all();\n\n// ✅ Detect AI extraction failures (technical + polite refusals)\nconst extractionFailurePatterns = [\n  // Technical error messages\n  'unable_to_extract',\n  'error_extracting',\n  'could_not_identify',\n  'could_not_extract',\n  'no_client_name',\n  'extraction_failed',\n  'cannot_identify',\n  // Polite AI refusals\n  'i_m_sorry',\n  'sorry_but',\n  'doesn_t_seem',\n  'does_not_appear',\n  'no_company_name',\n  'cannot_find',\n  'not_able_to'\n];\n\nconst isExtractionFailure = extractionFailurePatterns.some(pattern => \n  clientNormalized.toLowerCase().includes(pattern)\n);\n\nif (isExtractionFailure) {\n  // AI failed to extract client name → Route to UNKNOWN path\n  return [{\n    json: {\n      client_name_raw: clientNameRaw,\n      client_normalized: clientNormalized,\n      parent_folder_id: parentFolderId,\n      client_status: 'UNKNOWN',\n      root_folder_id: null,\n      staging_folder_id: null,\n      extraction_failure: true,\n      extraction_error_message: clientNameRaw\n    }\n  }];\n}\n\n// If registry is empty, client is NEW\nif (registryRows.length === 0) {\n  return [{\n    json: {\n      client_name_raw: clientNameRaw,\n      client_normalized: clientNormalized,\n      parent_folder_id: parentFolderId,\n      client_status: 'NEW',\n      root_folder_id: null,\n      staging_folder_id: null\n    }\n  }];\n}\n\n// Search registry for matching client (with same normalization)\nconst clientRow = registryRows.find(row => {\n  const registryClientName = row.json.Client_Name || '';\n  const normalizedRegistryName = registryClientName\n    .toLowerCase()\n    .trim()\n    .replace(/ä/g, 'ae')\n    .replace(/ö/g, 'oe')\n    .replace(/ü/g, 'ue')\n    .replace(/ß/g, 'ss')\n    .replace(/\\s*(gmbh|ag|kg|e\\.v\\.|mbh|co\\.|&\\s*co\\.?)\\s*/gi, '')\n    .replace(/[^a-z0-9]/g, '_')\n    .replace(/_+/g, '_')\n    .replace(/^_|_$/g, '');\n  \n  return normalizedRegistryName === clientNormalized;\n});\n\nif (clientRow) {\n  // Client exists → EXISTING path\n  return [{\n    json: {\n      client_name_raw: clientNameRaw,\n      client_normalized: clientNormalized,\n      parent_folder_id: parentFolderId,\n      client_status: 'EXISTING',\n      root_folder_id: clientRow.json.Root_Folder_ID,\n      staging_folder_id: clientRow.json.Staging_Folder_ID\n    }\n  }];\n} else {\n  // Client not in registry → NEW path\n  return [{\n    json: {\n      client_name_raw: clientNameRaw,\n      client_normalized: clientNormalized,\n      parent_folder_id: parentFolderId,\n      client_status: 'NEW',\n      root_folder_id: null,\n      staging_folder_id: null\n    }\n  }];\n}"
      },
      "name": "Check Client Exists",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1904,
        480
      ],
      "id": "check-exists-001"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.client_normalized }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "isEmpty"
                    }
                  },
                  {
                    "leftValue": "={{ $json.client_status }}",
                    "rightValue": "UNKNOWN",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "or"
              },
              "renameOutput": true,
              "outputKey": "no_client_identified"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.client_status }}",
                    "rightValue": "NEW",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "create_folders"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.client_status }}",
                    "rightValue": "EXISTING",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "folders_exist"
            }
          ]
        },
        "options": {}
      },
      "name": "Decision Gate",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        2128,
        464
      ],
      "id": "decision-gate-001"
    }
  ],
  "connections": {
    "Gmail Trigger - Unread with Attachments": {
      "main": [
        [
          {
            "node": "Filter PDF/ZIP Attachments",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter PDF/ZIP Attachments": {
      "main": [
        [
          {
            "node": "Upload PDF to Temp Folder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload PDF to Temp Folder": {
      "main": [
        [
          {
            "node": "Extract File ID & Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract File ID & Metadata": {
      "main": [
        [
          {
            "node": "Download PDF from Drive",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download PDF from Drive": {
      "main": [
        [
          {
            "node": "Extract Text from PDF",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Text from PDF": {
      "main": [
        [
          {
            "node": "Evaluate Extraction Quality",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Evaluate Extraction Quality": {
      "main": [
        [
          {
            "node": "AI Extract Client Name",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Extract Client Name": {
      "main": [
        [
          {
            "node": "Normalize Client Name",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Client Name": {
      "main": [
        [
          {
            "node": "Lookup Client Registry",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Lookup Client Registry": {
      "main": [
        [
          {
            "node": "Check Client Exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Client Exists": {
      "main": [
        [
          {
            "node": "Decision Gate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}
