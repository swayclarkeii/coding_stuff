{
  "success": true,
  "data": {
    "updatedAt": "2026-01-21T23:15:46.748Z",
    "createdAt": "2026-01-19T21:47:26.231Z",
    "id": "p0X9PrpCShIgxxMP",
    "name": "AMA Pre-Chunk 0 - REBUILT v1",
    "description": null,
    "active": true,
    "isArchived": false,
    "nodes": [
      {
        "parameters": {
          "pollTimes": {
            "item": [
              {
                "mode": "everyMinute"
              }
            ]
          },
          "simple": false,
          "filters": {
            "labelIds": [
              "INBOX",
              "UNREAD",
              "Label_8011160688574026773"
            ],
            "q": "has:attachment"
          },
          "options": {
            "downloadAttachments": true
          }
        },
        "id": "gmail-trigger-001",
        "name": "Gmail Trigger - Unread with Attachments",
        "type": "n8n-nodes-base.gmailTrigger",
        "typeVersion": 1.3,
        "position": [
          112,
          152
        ],
        "credentials": {
          "gmailOAuth2": {
            "id": "aYzk7sZF8ZVyfOan",
            "name": "Gmail account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Extract Email Metadata for V10 Batch Analysis\n\nconst item = $input.first();\nconst email = item.json;\n\n// Handle different formats of 'from' field\nlet senderEmail = '';\nlet senderName = '';\n\nif (email.from) {\n  if (typeof email.from === 'string') {\n    // String format: \"Name <email@example.com>\"\n    const emailMatch = email.from.match(/<([^>]+)>/) || email.from.match(/([^\\s]+@[^\\s]+)/);\n    senderEmail = emailMatch ? emailMatch[1].toLowerCase().trim() : email.from.toLowerCase().trim();\n    const nameMatch = email.from.match(/^([^<]+)</);\n    senderName = nameMatch ? nameMatch[1].trim() : '';\n  } else if (email.from.value && Array.isArray(email.from.value) && email.from.value[0]) {\n    // Gmail format: { value: [{ address: \"...\", name: \"...\" }] }\n    senderEmail = (email.from.value[0].address || '').toLowerCase().trim();\n    senderName = email.from.value[0].name || '';\n  } else if (typeof email.from === 'object') {\n    // Object format: { email: \"...\", name: \"...\" } or { address: \"...\" }\n    senderEmail = (email.from.email || email.from.address || '').toLowerCase().trim();\n    senderName = email.from.name || '';\n  }\n}\n\n// Fallback: check 'sender' field\nif (!senderEmail && email.sender) {\n  if (typeof email.sender === 'string') {\n    senderEmail = email.sender.toLowerCase().trim();\n  } else if (email.sender.value && email.sender.value[0]) {\n    senderEmail = (email.sender.value[0].address || '').toLowerCase().trim();\n    senderName = email.sender.value[0].name || '';\n  }\n}\n\n// Fallback for sender name\nif (!senderName && senderEmail) {\n  senderName = senderEmail.split('@')[0];\n}\n\nconst subject = email.subject || '';\n\nlet bodyText = email.text || email.snippet || email.body || '';\nbodyText = bodyText.replace(/\\s+/g, ' ').trim();\n\n// Count attachments from binary data\nconst binaryData = item.binary || {};\nconst binaryKeys = Object.keys(binaryData);\nconst attachmentCount = binaryKeys.length;\n\nconst emailId = email.id || email.messageId || '';\nconst receivedAt = email.date || email.internalDate || new Date().toISOString();\n\n// IMPORTANT: Return both json AND binary data\nreturn [{\n  json: {\n    ...email,\n    emailId,\n    senderEmail,\n    senderName,\n    subject,\n    bodyText,\n    receivedAt,\n    attachmentCount,\n    analysisResults: [],\n    emailBodyMentions: []\n  },\n  binary: binaryData\n}];"
        },
        "id": "extract-email-metadata-001",
        "name": "Extract Email Metadata",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          336,
          152
        ]
      },
      {
        "parameters": {
          "jsCode": "// Filter PDF and ZIP attachments only\nconst items = $input.all();\nconst filtered = [];\n\nfor (const item of items) {\n  // Gmail trigger stores attachments in item.binary, not item.json.attachments\n  if (!item.binary) continue;\n  \n  // Iterate over binary keys (attachment_0, attachment_1, etc.)\n  for (const [key, attachment] of Object.entries(item.binary)) {\n    const filename = attachment.fileName;\n    if (!filename) continue;\n    \n    const ext = filename.toLowerCase().split('.').pop();\n    \n    if (['pdf', 'zip'].includes(ext)) {\n      filtered.push({\n        json: {\n          emailId: item.json.id,\n          emailSubject: item.json.Subject || item.json.subject,\n          emailFrom: item.json.From || item.json.from,\n          emailDate: item.json.date,\n          attachmentKey: key,\n          filename: filename,\n          mimeType: attachment.mimeType,\n          size: attachment.fileSize\n        },\n        binary: {\n          data: attachment\n        }\n      });\n    }\n  }\n}\n\nreturn filtered;"
        },
        "id": "filter-attachments-001",
        "name": "Filter PDF/ZIP Attachments",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          560,
          152
        ]
      },
      {
        "parameters": {
          "options": {}
        },
        "id": "split-batches-001",
        "name": "Split Into Batches - Process Each PDF",
        "type": "n8n-nodes-base.splitInBatches",
        "typeVersion": 3,
        "position": [
          784,
          152
        ]
      },
      {
        "parameters": {
          "driveId": {
            "__rl": true,
            "mode": "list",
            "value": "My Drive"
          },
          "folderId": {
            "__rl": true,
            "mode": "list",
            "value": "root",
            "cachedResultName": "/ (Root folder)"
          },
          "options": {}
        },
        "id": "upload-pdf-gdrive-001",
        "name": "Upload PDF to Temp Folder",
        "type": "n8n-nodes-base.googleDrive",
        "typeVersion": 3,
        "position": [
          1008,
          -168
        ],
        "retryOnFail": true,
        "maxTries": 3,
        "waitBetweenTries": 5000,
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "a4m50EefR3DJoU0R",
            "name": "Google Drive account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Extract Google Drive file ID from upload response and preserve email metadata\nconst uploadResult = $input.first().json;\nconst emailData = $('Filter PDF/ZIP Attachments').first().json;\n\nreturn [{\n  json: {\n    file_id: uploadResult.id,\n    filename: uploadResult.name,\n    emailId: emailData.emailId,\n    emailSubject: emailData.emailSubject,\n    emailFrom: emailData.emailFrom,\n    emailDate: emailData.emailDate\n  }\n}];"
        },
        "id": "extract-file-id-001",
        "name": "Extract File ID & Metadata",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1232,
          -168
        ]
      },
      {
        "parameters": {
          "operation": "download",
          "fileId": {
            "__rl": true,
            "mode": "id",
            "value": "={{ $json.file_id }}"
          },
          "options": {}
        },
        "id": "download-pdf-from-gdrive-001",
        "name": "Download PDF from Drive",
        "type": "n8n-nodes-base.googleDrive",
        "typeVersion": 3,
        "position": [
          1456,
          -168
        ],
        "retryOnFail": true,
        "maxTries": 3,
        "waitBetweenTries": 5000,
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "a4m50EefR3DJoU0R",
            "name": "Google Drive account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Convert PDF to Base64 - V10 Sprint 6\n// For large files (>5MB), flag for thumbnail route\n\nconst item = $input.first();\nconst binaryKey = Object.keys(item.binary)[0];\nconst buffer = await this.helpers.getBinaryDataBuffer(0, binaryKey);\n\n// Calculate file size\nconst fileSizeBytes = buffer.length;\nconst fileSizeMB = fileSizeBytes / (1024 * 1024);\nconst SIZE_THRESHOLD_MB = 5;\n\nconsole.log(`File size: ${fileSizeMB.toFixed(2)} MB, Threshold: ${SIZE_THRESHOLD_MB} MB`);\n\nif (fileSizeMB > SIZE_THRESHOLD_MB) {\n  // Large file - flag it for thumbnail route\n  // HTTP Request nodes will fetch the thumbnail\n  console.log('Large file detected - routing to thumbnail fetch');\n  return {\n    json: {\n      ...item.json,\n      fileSizeMB: fileSizeMB,\n      isLargeFile: true\n    },\n    binary: item.binary\n  };\n}\n\n// Normal path: Convert full PDF to Base64\nconst base64Content = buffer.toString('base64');\n\nreturn {\n  json: {\n    ...item.json,\n    fileSizeMB: fileSizeMB,\n    isLargeFile: false,\n    imageData: {\n      type: 'base64',\n      media_type: 'application/pdf',\n      data: base64Content\n    }\n  },\n  binary: item.binary\n};"
        },
        "id": "convert-pdf-base64-001",
        "name": "Convert PDF to Base64",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1680,
          -168
        ]
      },
      {
        "parameters": {
          "jsCode": "// Build Claude API Request - V10 Sprint 7\n// Handles both PDF documents and image thumbnails\n// UPDATED: Stricter prompt to prevent description outputs\n\nconst item = $input.first();\n\nconst prompt = `# Role\nYou are extracting property identifiers from German real estate documents.\n\n# Task\nExtract the PRIMARY identifier from this document.\n\n# Output Format\nRespond with ONLY the name. No explanations. No descriptions. No sentences.\n\nGOOD outputs:\n- Villa Martens\n- Schlossbergstrasse 13\n- Projekt Sonnenberg\n- Mueller Immobilien GmbH\n- UNKNOWN\n\nBAD outputs (NEVER do this):\n- \"The primary identifier is Villa Martens\"\n- \"The document shows a property called...\"\n- \"Based on the header, the name is...\"\n- Any sentence or explanation\n\n# Priority\n1. Property/Project name (header, title, watermark)\n2. Client/Company name if no property name\n3. Street address as fallback\n4. UNKNOWN if nothing found\n\n# Rules\n- Output ONLY the name itself (2-5 words max)\n- Normalize German: √ü‚Üíss, √§‚Üíae, √∂‚Üíoe, √º‚Üíue\n- If confidence <70%, output: UNKNOWN\n- NEVER explain your answer\n- NEVER start with \"The...\"`;\n\nconst mediaType = item.json.imageData.media_type;\nconst isImage = mediaType.startsWith('image/');\n\n// Build content array based on whether it's a PDF or image\nlet contentArray;\n\nif (isImage) {\n  // Image content (thumbnail)\n  contentArray = [\n    {\n      type: \"image\",\n      source: {\n        type: \"base64\",\n        media_type: mediaType,\n        data: item.json.imageData.data\n      }\n    },\n    {\n      type: \"text\",\n      text: prompt\n    }\n  ];\n  console.log('Using IMAGE format (thumbnail) for Claude Vision');\n} else {\n  // PDF document\n  contentArray = [\n    {\n      type: \"document\",\n      source: {\n        type: \"base64\",\n        media_type: mediaType,\n        data: item.json.imageData.data\n      }\n    },\n    {\n      type: \"text\",\n      text: prompt\n    }\n  ];\n  console.log('Using DOCUMENT format (PDF) for Claude Vision');\n}\n\nconst apiBody = {\n  model: \"claude-sonnet-4-20250514\",\n  max_tokens: 30,  // Reduced to force shorter output\n  messages: [\n    {\n      role: \"user\",\n      content: contentArray\n    }\n  ]\n};\n\nreturn {\n  json: {\n    file_id: item.json.file_id,\n    filename: item.json.filename,\n    emailId: item.json.emailId,\n    emailSubject: item.json.emailSubject,\n    emailFrom: item.json.emailFrom,\n    emailDate: item.json.emailDate,\n    fileSizeMB: item.json.fileSizeMB,\n    isLargeFile: item.json.isLargeFile,\n    usedThumbnail: item.json.usedThumbnail,\n    claudeApiBody: apiBody\n  }\n};"
        },
        "id": "build-claude-request-001",
        "name": "Build Claude API Request",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2800,
          -168
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://api.anthropic.com/v1/messages",
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "anthropic-version",
                "value": "2023-06-01"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ $json.claudeApiBody }}",
          "options": {}
        },
        "id": "7b5637a2-9b8e-4651-83a9-b2e5838c1f3a",
        "name": "Claude Tesxt Extration",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.3,
        "position": [
          3024,
          -168
        ],
        "credentials": {
          "httpHeaderAuth": {
            "id": "vfoYopBRX35Znmq6",
            "name": "Anthropic API key"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "const item = $input.first();\nconst response = item.json;\n\n// Get Claude's response text\nlet rawResponse = response.content[0].text.trim();\n\n// Extract just the identifier from verbose responses\nlet identifier = rawResponse;\n\n// Pattern 1: Look for \"‚Üí identifier\" format (Claude's normalization output)\nconst arrowMatch = rawResponse.match(/‚Üí\\s*([^\\n*]+)/);\nif (arrowMatch) {\n  identifier = arrowMatch[1].trim();\n}\n// Pattern 2: Look for quoted identifier\nelse if (rawResponse.includes('\"')) {\n  const quoteMatch = rawResponse.match(/\"([^\"]+)\"/);\n  if (quoteMatch) {\n    identifier = quoteMatch[1].trim();\n  }\n}\n// Pattern 3: If response has multiple lines, take the last non-empty line\nelse if (rawResponse.includes('\\n')) {\n  const lines = rawResponse.split('\\n').filter(line => line.trim().length > 0);\n  identifier = lines[lines.length - 1].trim();\n  \n  // Remove common prefixes\n  identifier = identifier.replace(/^[-*‚Ä¢]\\s*/, ''); // Remove bullet points\n  identifier = identifier.replace(/^\\d+\\.\\s*/, ''); // Remove numbering\n  identifier = identifier.replace(/^[*_]+$/, ''); // Remove markdown formatting\n}\n\n// Clean up any remaining markdown or formatting\nidentifier = identifier.replace(/\\*\\*/g, ''); // Remove bold\nidentifier = identifier.replace(/\\*/g, ''); // Remove italics\nidentifier = identifier.replace(/^[:\\-]\\s*/, ''); // Remove leading colons/dashes\n\n// Final validation\nif (!identifier || identifier.length < 2 || identifier.length > 100) {\n  identifier = 'UNKNOWN';\n}\n\n// Get original data from upstream (Download PDF node)\nconst originalData = $('Download PDF from Drive').first().json;\n\nreturn {\n  json: {\n    ...originalData,\n    identifier: identifier,           // KEY FIX: Add identifier field for Store Analysis Result\n    client_name_raw: identifier,       // Keep for debugging/legacy\n    extractionMethod: 'claude_vision',\n    extractionModel: 'claude-sonnet-4-20250514',\n    rawClaudeResponse: rawResponse.substring(0, 500) // Keep first 500 chars for debugging\n  }\n};\n"
        },
        "id": "parse-claude-response-001",
        "name": "Parse Claude Response",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3248,
          -168
        ]
      },
      {
        "parameters": {
          "amount": 20
        },
        "id": "wait-between-vision-001",
        "name": "Wait Between Vision Calls",
        "type": "n8n-nodes-base.wait",
        "typeVersion": 1.1,
        "position": [
          3472,
          -168
        ],
        "webhookId": "eb97b8b7-9acd-49b9-8001-e2762aa4b5e3"
      },
      {
        "parameters": {
          "jsCode": "// Store Analysis Result - Accumulate PDF analysis results for batch voting\n// Uses GLOBAL static data so Aggregate node can read it\n\nconst currentItem = $input.first().json;\nconst context = $('Extract Email Metadata').first().json;\n\n// Use GLOBAL workflow static data (shared across all nodes)\nconst staticData = $getWorkflowStaticData('global');\n\n// Initialize or get the results array\nif (!staticData.analysisResults) {\n  staticData.analysisResults = [];\n}\n\n// Create result object for this PDF\nconst result = {\n  fileId: currentItem.file_id || currentItem.fileId,\n  fileName: currentItem.filename || currentItem.fileName,\n  identifier: currentItem.identifier || currentItem.clientName || currentItem.client_name_raw || 'UNKNOWN',\n  identifierType: currentItem.identifierType || 'unknown',\n  confidence: currentItem.confidence || (currentItem.identifier && currentItem.identifier !== 'UNKNOWN' ? 0.8 : 0),\n  alternates: currentItem.alternates || [],\n  source: 'pdf_vision',\n  extractionMethod: currentItem.extractionMethod || 'unknown'\n};\n\n// Append to global static data results array\nstaticData.analysisResults.push(result);\n\nconsole.log('Stored result #' + staticData.analysisResults.length + ': ' + result.identifier);\n\nreturn [{\n  json: {\n    ...currentItem,\n    analysisResults: staticData.analysisResults,\n    currentPdfIndex: staticData.analysisResults.length,\n    totalPdfs: context.attachmentCount\n  }\n}];"
        },
        "id": "store-analysis-result-001",
        "name": "Store Analysis Result",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3696,
          -176
        ]
      },
      {
        "parameters": {
          "jsCode": "// Aggregate All PDF Results - Combine all analysis results for batch voting\n// Reads from GLOBAL static data and clears it for next execution\n\nconst context = $('Extract Email Metadata').first().json;\n\n// Get GLOBAL static data (shared with Store Analysis Result)\nconst staticData = $getWorkflowStaticData('global');\n\n// Read accumulated results\nconst analysisResults = staticData.analysisResults || [];\n\n// IMPORTANT: Clear the static data for next email execution\nstaticData.analysisResults = [];\n\n// Calculate summary stats\nconst totalPdfs = analysisResults.length;\nconst avgConfidence = totalPdfs > 0 \n  ? analysisResults.reduce((sum, r) => sum + (r.confidence || 0), 0) / totalPdfs \n  : 0;\n\n// Find all unique identifiers with their counts\nconst identifierCounts = {};\nanalysisResults.forEach(r => {\n  const id = (r.identifier || '').toLowerCase();\n  if (id && id !== 'unknown') {\n    identifierCounts[id] = (identifierCounts[id] || 0) + 1;\n  }\n});\n\nconsole.log('Aggregated ' + totalPdfs + ' PDF results');\nconsole.log('Identifiers found:', Object.keys(identifierCounts));\n\nreturn [{\n  json: {\n    // Pass through email metadata\n    emailId: context.emailId,\n    senderEmail: context.senderEmail,\n    senderName: context.senderName,\n    subject: context.subject,\n    bodyText: context.bodyText,\n    attachmentCount: context.attachmentCount,\n    \n    // Analysis results\n    analysisResults,\n    totalPdfsAnalyzed: totalPdfs,\n    averageConfidence: avgConfidence,\n    identifierCounts,\n    \n    // Ready for batch voting\n    readyForVoting: true\n  }\n}];"
        },
        "id": "aggregate-results-001",
        "name": "Aggregate All PDF Results",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1008,
          296
        ]
      },
      {
        "parameters": {
          "jsCode": "// Parse Email Body for Mentions\n// Extract potential project/client names from email body and signature\n\nconst input = $input.first().json;\nconst bodyText = input.bodyText || '';\nconst subject = input.subject || '';\n\n// Combine subject and body for searching\nconst searchText = `${subject}\\n${bodyText}`.toLowerCase();\n\nconst mentions = [];\n\n// Pattern 1: \"Projekt [Name]\" or \"Project [Name]\"\nconst projektMatches = searchText.match(/(?:projekt|project)\\s*[:\\-]?\\s*([a-z√§√∂√º√ü][a-z√§√∂√º√ü0-9\\s\\-_.]+)/gi) || [];\nprojektMatches.forEach(match => {\n  const name = match.replace(/(?:projekt|project)\\s*[:\\-]?\\s*/i, '').trim();\n  if (name.length > 2 && name.length < 50) {\n    mentions.push({ value: name, source: 'projekt_pattern', confidence: 0.8 });\n  }\n});\n\n// Pattern 2: \"Villa [Name]\" or property names\nconst villaMatches = searchText.match(/(?:villa|haus|objekt)\\s+([a-z√§√∂√º√ü][a-z√§√∂√º√ü0-9\\s\\-]+)/gi) || [];\nvillaMatches.forEach(match => {\n  const name = match.trim();\n  if (name.length > 4 && name.length < 50) {\n    mentions.push({ value: name, source: 'property_pattern', confidence: 0.7 });\n  }\n});\n\n// Pattern 3: German street addresses (potential project identifiers)\nconst streetMatches = searchText.match(/([a-z√§√∂√º√ü][a-z√§√∂√º√ü\\-]+(?:stra√üe|strasse|weg|allee|platz|ring))\\s*\\d*/gi) || [];\nstreetMatches.forEach(match => {\n  const name = match.trim();\n  if (name.length > 5 && name.length < 50) {\n    mentions.push({ value: name, source: 'street_pattern', confidence: 0.6 });\n  }\n});\n\n// Pattern 4: \"Betreff:\" or \"Re:\" followed by potential project name\nconst betreffMatches = searchText.match(/(?:betreff|betrifft|re|subject)\\s*[:\\-]?\\s*([a-z√§√∂√º√ü][a-z√§√∂√º√ü0-9\\s\\-_.]+)/gi) || [];\nbetreffMatches.forEach(match => {\n  const name = match.replace(/(?:betreff|betrifft|re|subject)\\s*[:\\-]?\\s*/i, '').trim();\n  // Filter out generic subjects\n  if (name.length > 3 && name.length < 50 && !/^(invoice|rechnung|dokument|document|fwd|fw|aw)/i.test(name)) {\n    mentions.push({ value: name, source: 'betreff_pattern', confidence: 0.5 });\n  }\n});\n\n// Pattern 5: Company names in signature (GmbH, AG, etc.)\nconst companyMatches = searchText.match(/([a-z√§√∂√º√ü][a-z√§√∂√º√ü0-9\\s\\-&.]+)\\s*(?:gmbh|ag|kg|e\\.v\\.|mbh|co\\.)/gi) || [];\ncompanyMatches.forEach(match => {\n  const name = match.trim();\n  // Skip if it's likely the sender's own company (in signature at end)\n  if (name.length > 3 && name.length < 60) {\n    mentions.push({ value: name, source: 'company_pattern', confidence: 0.4 });\n  }\n});\n\n// Pattern 6: Check if any known identifiers from PDF analysis appear in email\nconst knownIdentifiers = (input.analysisResults || [])\n  .map(r => r.identifier)\n  .filter(id => id && id.toLowerCase() !== 'unknown');\n\nknownIdentifiers.forEach(identifier => {\n  const normalizedId = identifier.toLowerCase();\n  if (searchText.includes(normalizedId)) {\n    mentions.push({ value: identifier, source: 'pdf_match_in_email', confidence: 0.9 });\n  }\n});\n\n// Deduplicate mentions by normalized value\nconst seen = new Set();\nconst uniqueMentions = mentions.filter(m => {\n  const normalized = m.value.toLowerCase().replace(/[^a-z0-9]/g, '');\n  if (seen.has(normalized)) return false;\n  seen.add(normalized);\n  return true;\n});\n\n// Sort by confidence descending\nuniqueMentions.sort((a, b) => b.confidence - a.confidence);\n\n// Extract just the values for the voting node\nconst emailBodyMentions = uniqueMentions.map(m => m.value);\n\nreturn [{\n  json: {\n    ...input,\n    emailBodyMentions,\n    emailBodyMentionDetails: uniqueMentions.slice(0, 10), // Top 10 with details\n    emailBodyParsed: true\n  }\n}];"
        },
        "id": "parse-email-body-001",
        "name": "Parse Email Body for Mentions",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1232,
          296
        ]
      },
      {
        "parameters": {
          "jsCode": "// Batch Voting - Find Common Identifier - V10 Sprint 7.1\n// UPDATED: Added filename analysis for additional voting + validation\n\nconst input = $input.first().json;\nconst analysisResults = input.analysisResults || [];\nconst senderEmail = input.senderEmail || '';\nconst emailBodyMentions = input.emailBodyMentions || [];\n\n// ========== STEP 0: Filter out bad responses ==========\nconst isValidIdentifier = (identifier) => {\n  if (!identifier || typeof identifier !== 'string') return false;\n  const id = identifier.trim();\n  \n  if (id === '' || id.toLowerCase() === 'unknown') return false;\n  \n  const badPatterns = [\n    /^the\\s+(primary|main|document|identifier|property|name)/i,\n    /^based\\s+on/i,\n    /^this\\s+(document|appears|shows|is)/i,\n    /^i\\s+(can|cannot|couldn't|could not)/i,\n    /identifier\\s+is/i,\n    /appears\\s+to\\s+be/i,\n    /^according\\s+to/i,\n    /^from\\s+the/i\n  ];\n  \n  for (const pattern of badPatterns) {\n    if (pattern.test(id)) return false;\n  }\n  \n  if (id.split(/\\s+/).length > 7) return false;\n  \n  return true;\n};\n\n// ========== STEP 0.5: Extract identifier from filename ==========\nconst extractFromFilename = (filename) => {\n  if (!filename) return null;\n  \n  // Remove extension\n  let name = filename.replace(/\\.[^.]+$/, '');\n  \n  // Remove common patterns: dates (YYMMDD, YYYYMMDD), version numbers, parenthetical numbers\n  name = name\n    .replace(/^\\d{6,8}_?/, '')           // Leading date like 250814_ or 20250814_\n    .replace(/_?\\d{6,8}$/, '')           // Trailing date\n    .replace(/[_\\s]?\\(\\d+\\)$/g, '')      // Trailing (1), (11), etc.\n    .replace(/[_\\s]?v\\d+(\\.\\d+)?$/i, '') // Version numbers v1, v1.0\n    .replace(/_?(Entwurf|Draft|Final|Copy)_?/gi, '') // Common suffixes\n    .replace(/_+/g, ' ')                  // Underscores to spaces\n    .replace(/\\s+/g, ' ')                 // Multiple spaces to single\n    .trim();\n  \n  // Skip if too short or just numbers\n  if (name.length < 3 || /^\\d+$/.test(name)) return null;\n  \n  // Skip common non-identifier words\n  const skipWords = ['kalkulation', 'uebersicht', '√ºbersicht', 'verkaufsbaubeschreibung', \n                     'finanzierung', 'finanzierungen', 'banken', 'dokument', 'document'];\n  const nameLower = name.toLowerCase();\n  \n  // Extract the likely identifier part (first meaningful segment)\n  const words = name.split(/\\s+/);\n  const meaningfulWords = words.filter(w => \n    w.length >= 3 && \n    !skipWords.includes(w.toLowerCase()) &&\n    !/^\\d+$/.test(w)\n  );\n  \n  if (meaningfulWords.length === 0) return null;\n  \n  // Return the meaningful part\n  return meaningfulWords.slice(0, 3).join(' '); // Max 3 words\n};\n\n// ========== STEP 1: Extract root words for fuzzy matching ==========\nconst extractRoots = (identifier) => {\n  const normalized = identifier\n    .toLowerCase()\n    .replace(/√§/g, 'ae').replace(/√∂/g, 'oe').replace(/√º/g, 'ue').replace(/√ü/g, 'ss')\n    .replace(/[^a-z0-9\\s]/g, '')\n    .trim();\n  \n  const cleaned = normalized\n    .replace(/^(projekt|project|villa|residenz|haus|immobilie|objekt)\\s+/i, '')\n    .replace(/\\s+(gmbh|ag|kg|mbh|str|strasse|weg|platz|allee)$/i, '')\n    .replace(/\\s+\\d+$/, '');\n  \n  const words = cleaned.split(/\\s+/).filter(w => w.length >= 3);\n  \n  return {\n    full: normalized,\n    core: cleaned,\n    words: words,\n    primary: words[0] || normalized\n  };\n};\n\n// ========== STEP 2: Collect valid identifiers from Claude ==========\nconst validResults = [];\nanalysisResults.forEach((result, index) => {\n  if (isValidIdentifier(result.identifier)) {\n    validResults.push({\n      ...result,\n      sourceIndex: index,\n      sourceType: 'claude_vision',\n      roots: extractRoots(result.identifier),\n      weight: 1.0  // Full weight for Claude extractions\n    });\n  } else {\n    console.log(`Filtered out invalid Claude response from PDF ${index + 1}: \"${result.identifier}\"`);\n  }\n});\n\n// ========== STEP 2.5: Add filename identifiers ==========\nconst filenameIdentifiers = [];\nanalysisResults.forEach((result, index) => {\n  const filenameId = extractFromFilename(result.fileName);\n  if (filenameId && isValidIdentifier(filenameId)) {\n    filenameIdentifiers.push({\n      identifier: filenameId,\n      fileName: result.fileName,\n      sourceIndex: index,\n      sourceType: 'filename',\n      roots: extractRoots(filenameId),\n      weight: 0.5,  // Half weight for filename extractions\n      confidence: 0.7  // Assumed confidence for filenames\n    });\n    console.log(`Extracted from filename ${index + 1}: \"${filenameId}\"`);\n  }\n});\n\nconsole.log(`Valid Claude extractions: ${validResults.length}, Filename extractions: ${filenameIdentifiers.length}`);\n\n// Combine all sources\nconst allSources = [...validResults, ...filenameIdentifiers];\n\n// ========== STEP 3: Group by similarity ==========\nconst groups = [];\n\nconst findSimilarity = (roots1, roots2) => {\n  if (roots1.primary === roots2.primary) return 1.0;\n  if (roots1.core.includes(roots2.core) || roots2.core.includes(roots1.core)) return 0.9;\n  \n  const commonWords = roots1.words.filter(w => roots2.words.includes(w));\n  if (commonWords.length > 0) {\n    return 0.7 + (0.2 * commonWords.length / Math.max(roots1.words.length, roots2.words.length));\n  }\n  \n  if (roots1.primary.length >= 4 && roots2.primary.length >= 4) {\n    if (roots1.primary.includes(roots2.primary) || roots2.primary.includes(roots1.primary)) return 0.6;\n  }\n  \n  return 0;\n};\n\nallSources.forEach(result => {\n  let bestGroup = null;\n  let bestSimilarity = 0;\n  \n  for (const group of groups) {\n    const similarity = findSimilarity(result.roots, group.representative.roots);\n    if (similarity > 0.5 && similarity > bestSimilarity) {\n      bestSimilarity = similarity;\n      bestGroup = group;\n    }\n  }\n  \n  if (bestGroup) {\n    bestGroup.members.push(result);\n    bestGroup.totalWeight += result.weight;\n    bestGroup.totalConfidence += (result.confidence || 0.8) * result.weight;\n    bestGroup.hasFilenameMatch = bestGroup.hasFilenameMatch || result.sourceType === 'filename';\n    bestGroup.hasClaudeMatch = bestGroup.hasClaudeMatch || result.sourceType === 'claude_vision';\n    \n    // Prefer Claude extraction as representative, but keep shortest\n    if (result.sourceType === 'claude_vision' && \n        (bestGroup.representative.sourceType !== 'claude_vision' ||\n         result.identifier.length < bestGroup.representative.identifier.length)) {\n      bestGroup.representative = result;\n    }\n  } else {\n    groups.push({\n      representative: result,\n      members: [result],\n      totalWeight: result.weight,\n      totalConfidence: (result.confidence || 0.8) * result.weight,\n      hasFilenameMatch: result.sourceType === 'filename',\n      hasClaudeMatch: result.sourceType === 'claude_vision'\n    });\n  }\n});\n\nconsole.log(`Grouped into ${groups.length} distinct identifiers`);\n\n// ========== STEP 4: Score groups ==========\nconst scoredGroups = groups.map(group => {\n  const votes = group.totalWeight;\n  const avgConfidence = group.totalConfidence / votes;\n  const claudeCount = group.members.filter(m => m.sourceType === 'claude_vision').length;\n  const filenameCount = group.members.filter(m => m.sourceType === 'filename').length;\n  \n  // Bonus if both Claude AND filename agree\n  const crossValidationBonus = (group.hasClaudeMatch && group.hasFilenameMatch) ? 0.15 : 0;\n  \n  return {\n    name: group.representative.identifier,\n    normalized: group.representative.roots.full,\n    votes: votes,\n    claudeVotes: claudeCount,\n    filenameVotes: filenameCount,\n    avgConfidence: avgConfidence,\n    crossValidated: group.hasClaudeMatch && group.hasFilenameMatch,\n    sources: group.members.map(m => \n      m.sourceType === 'filename' ? `file_${m.sourceIndex + 1}` : `pdf_${m.sourceIndex + 1}`\n    ),\n    finalScore: (votes * avgConfidence * (1 + crossValidationBonus))\n  };\n}).sort((a, b) => b.finalScore - a.finalScore);\n\n// ========== STEP 5: Determine winner ==========\nconst winner = scoredGroups[0] || null;\nconst runnerUp = scoredGroups[1] || null;\n\nlet overallConfidence = 0;\nlet votingMethod = 'no_valid_candidates';\n\nif (winner && allSources.length > 0) {\n  const voteShare = winner.votes / allSources.reduce((sum, s) => sum + s.weight, 0);\n  const marginOverRunnerUp = runnerUp ? (winner.votes - runnerUp.votes) / winner.votes : 1;\n  const crossValidationBoost = winner.crossValidated ? 0.1 : 0;\n  \n  overallConfidence = Math.min(1.0, (\n    winner.avgConfidence * 0.35 +\n    voteShare * 0.35 +\n    marginOverRunnerUp * 0.2 +\n    crossValidationBoost\n  ));\n  \n  votingMethod = scoredGroups.length === 1 ? 'unanimous' : \n                 winner.votes > allSources.length / 2 ? 'majority' : 'plurality';\n  \n  if (winner.crossValidated) votingMethod += '_cross_validated';\n}\n\n// ========== STEP 6: Normalize winner ==========\nconst normalizeString = (str) => {\n  return str\n    .toLowerCase()\n    .trim()\n    .replace(/√§/g, 'ae').replace(/√∂/g, 'oe').replace(/√º/g, 'ue').replace(/√ü/g, 'ss')\n    .replace(/\\s*(gmbh|ag|kg|e\\.v\\.|mbh|co\\.|&\\s*co\\.?)\\s*/gi, '')\n    .replace(/[^a-z0-9]/g, '_')\n    .replace(/_+/g, '_')\n    .replace(/^_|_$/g, '');\n};\n\nconst projectName = winner ? winner.name : 'UNKNOWN';\nconst projectNameNormalized = winner ? normalizeString(winner.name) : 'unknown';\n\nconsole.log(`Winner: \"${projectName}\" with ${winner?.votes?.toFixed(1) || 0} weighted votes`);\nconsole.log(`  - Claude votes: ${winner?.claudeVotes || 0}, Filename votes: ${winner?.filenameVotes || 0}`);\nconsole.log(`  - Cross-validated: ${winner?.crossValidated || false}`);\nconsole.log(`  - Overall confidence: ${(overallConfidence * 100).toFixed(0)}%`);\n\n// ========== STEP 7: Build output ==========\nreturn [{\n  json: {\n    // Winning identifier\n    clientName: projectName,\n    clientNormalized: projectNameNormalized,\n    projectName: projectName,\n    projectNameNormalized: projectNameNormalized,\n    \n    // Confidence metrics\n    overallConfidence: Math.round(overallConfidence * 100) / 100,\n    votingMethod,\n    winnerVotes: winner ? Math.round(winner.votes * 10) / 10 : 0,\n    winnerClaudeVotes: winner ? winner.claudeVotes : 0,\n    winnerFilenameVotes: winner ? winner.filenameVotes : 0,\n    crossValidated: winner ? winner.crossValidated : false,\n    winnerSources: winner ? winner.sources : [],\n    validClaudeCount: validResults.length,\n    filenameCount: filenameIdentifiers.length,\n    filteredOutCount: analysisResults.length - validResults.length,\n    \n    // Runner-up for comparison\n    runnerUpName: runnerUp ? runnerUp.name : null,\n    runnerUpScore: runnerUp ? Math.round(runnerUp.finalScore * 100) / 100 : 0,\n    \n    // All groups for debugging\n    allCandidates: scoredGroups.slice(0, 5),\n    \n    // Pass through email metadata\n    senderEmail: input.senderEmail,\n    senderName: input.senderName,\n    subject: input.subject,\n    emailId: input.emailId,\n    attachmentCount: input.attachmentCount,\n    \n    // Pass through for downstream\n    analysisResults,\n    totalPdfsAnalyzed: input.totalPdfsAnalyzed,\n    \n    // File info\n    fileId: analysisResults[0]?.fileId,\n    fileName: analysisResults[0]?.fileName\n  }\n}];"
        },
        "id": "normalize-name-001",
        "name": "Batch Voting - Find Common Identifier",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1456,
          296
        ]
      },
      {
        "parameters": {
          "documentId": {
            "__rl": true,
            "mode": "id",
            "value": "1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI"
          },
          "sheetName": {
            "__rl": true,
            "mode": "list",
            "value": 762792134,
            "cachedResultName": "Client_Registry",
            "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI/edit#gid=762792134"
          },
          "options": {}
        },
        "id": "lookup-registry-001",
        "name": "Lookup Client Registry",
        "type": "n8n-nodes-base.googleSheets",
        "typeVersion": 4.7,
        "position": [
          1680,
          296
        ],
        "alwaysOutputData": true,
        "credentials": {
          "googleSheetsOAuth2Api": {
            "id": "H7ewI1sOrDYabelt",
            "name": "Google Sheets account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Check Client Exists - V10 Sprint 6 - FIXED routing logic\n// NEW: If Claude identified a name but not in registry ‚Üí NEW (not UNKNOWN)\n// UNKNOWN: Only when Claude couldn't identify the client at all\n\n// Get the batch voting results directly (not from $input which has Google Sheets rows)\nconst batchVotingData = $('Batch Voting - Find Common Identifier').first().json;\nconst registryData = $('Lookup Client Registry').all();\n\n// Extract values from batch voting output\nconst clientNormalized = batchVotingData.clientNormalized || batchVotingData.projectNameNormalized || '';\nconst senderEmail = batchVotingData.senderEmail || '';\nconst overallConfidence = batchVotingData.overallConfidence || 0;\nconst clientName = batchVotingData.clientName || batchVotingData.projectName || '';\n\nconsole.log('Checking client: ' + clientName + ' (normalized: ' + clientNormalized + ')');\nconsole.log('Confidence: ' + overallConfidence);\nconsole.log('Registry has ' + registryData.length + ' entries');\n\n// Check if client was found by project name (primary lookup)\nlet projectMatch = null;\nlet emailMatch = null;\n\nif (registryData && registryData.length > 0) {\n  // Check each row for matches\n  registryData.forEach(row => {\n    const rowData = row.json;\n    \n    // Skip the generic unknown_client row\n    const rowClientNormalized = (rowData.Client_Normalized || rowData.client_normalized || '')\n      .toLowerCase().trim();\n    if (rowClientNormalized === 'unknown_client') {\n      return; // Skip this row\n    }\n    \n    // Check project name match (primary) - compare normalized versions\n    if (clientNormalized && rowClientNormalized === clientNormalized.toLowerCase()) {\n      projectMatch = rowData;\n      console.log('Found project match: ' + rowData.Client_Name);\n    }\n    \n    // Check sender email match (secondary)\n    const rowSenderEmail = (rowData.sender_email || rowData.Sender_Email || '')\n      .toLowerCase().trim();\n    if (rowSenderEmail && senderEmail && rowSenderEmail === senderEmail.toLowerCase()) {\n      emailMatch = rowData;\n      console.log('Found email match: ' + rowData.Client_Name);\n    }\n  });\n}\n\n// Determine routing based on matches\nlet routingDecision = '';\nlet matchedRow = null;\nlet matchType = 'none';\n\n// Check if Claude successfully identified a client name\nconst hasValidIdentification = clientName && \n                               clientName !== '' && \n                               clientName.toUpperCase() !== 'UNKNOWN' &&\n                               overallConfidence >= 0.5;\n\nconsole.log('Has valid identification: ' + hasValidIdentification + ' (name: ' + clientName + ', confidence: ' + overallConfidence + ')');\n\nif (projectMatch) {\n  // PRIMARY MATCH: Project name found in registry ‚Üí EXISTING\n  routingDecision = 'EXISTING';\n  matchedRow = projectMatch;\n  matchType = 'project_name';\n  \n  // Check if email also matches (full match vs partial)\n  const projectEmail = (projectMatch.sender_email || projectMatch.Sender_Email || '').toLowerCase();\n  if (projectEmail && senderEmail && projectEmail !== senderEmail.toLowerCase()) {\n    matchType = 'project_name_email_mismatch';\n  }\n  console.log('EXISTING client - project name matched in registry');\n  \n} else if (emailMatch) {\n  // SECONDARY MATCH: Sender email found but different project ‚Üí NEW\n  routingDecision = 'NEW';\n  matchedRow = emailMatch;\n  matchType = 'sender_email_only';\n  console.log('NEW client - known sender, new project');\n  \n} else if (hasValidIdentification) {\n  // NEW CLIENT: Claude identified the name but not in registry ‚Üí NEW\n  // This is the key fix - identified clients go to NEW, not UNKNOWN\n  routingDecision = 'NEW';\n  matchedRow = null;\n  matchType = 'new_client_identified';\n  console.log('NEW client - Claude identified \"' + clientName + '\" but not in registry');\n  \n} else {\n  // UNKNOWN: Claude couldn't identify the client at all\n  routingDecision = 'UNKNOWN';\n  matchedRow = null;\n  matchType = 'no_identification';\n  console.log('UNKNOWN - Claude could not identify client (name: \"' + clientName + '\", confidence: ' + overallConfidence + ')');\n}\n\nconsole.log('Final routing decision: ' + routingDecision + ' (' + matchType + ')');\n\nreturn [{\n  json: {\n    // Pass through ALL batch voting data\n    ...batchVotingData,\n    \n    // Routing decision\n    routingDecision,\n    matchType,\n    clientFound: routingDecision === 'EXISTING',\n    isNewClient: routingDecision === 'NEW',\n    \n    // Match details\n    matchedRow,\n    projectNameMatched: !!projectMatch,\n    senderEmailMatched: !!emailMatch,\n    \n    // Registry data for downstream (only if EXISTING)\n    folderId: matchedRow?.Root_Folder_ID || matchedRow?.folder_id || null,\n    stagingFolderId: matchedRow?.Staging_Folder_ID || matchedRow?.staging_folder_id || null,\n    registryClientName: matchedRow?.Client_Name || matchedRow?.client_name || null,\n    \n    // Ensure these are passed through correctly\n    overallConfidence,\n    senderEmail,\n    projectNameNormalized: clientNormalized,\n    clientName: clientName || 'UNKNOWN'\n  }\n}];"
        },
        "id": "check-exists-001",
        "name": "Check Client Exists",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1904,
          296
        ]
      },
      {
        "parameters": {
          "jsCode": "// Check Flag Conditions - V10 Flagging System\nconst input = $input.first().json;\n\nconst overallConfidence = input.overallConfidence || 0;\nconst attachmentCount = input.attachmentCount || 0;\nconst routingDecision = input.routingDecision || 'UNKNOWN';\nconst matchType = input.matchType || 'no_match';\nconst senderEmail = input.senderEmail || '';\nconst projectName = input.projectName || input.clientName || 'UNKNOWN';\n\n// Flagging conditions\nconst isSingleDoc = attachmentCount === 1;\nconst isNewSender = routingDecision === 'UNKNOWN' || routingDecision === 'NEW_FROM_KNOWN';\nconst isLowConfidence = overallConfidence < 0.6;\nconst isMediumConfidence = overallConfidence >= 0.6 && overallConfidence < 0.8;\nconst isHighConfidence = overallConfidence >= 0.8;\nconst isEmailMismatch = matchType === 'project_name_email_mismatch';\n\n// Determine flag status\nlet needsReview = false;\nlet flagPriority = 'NONE';\nlet flagReasons = [];\nlet sendReviewEmail = false;\n\n// HIGH priority flags (send email)\nif (isSingleDoc && isNewSender) {\n  needsReview = true;\n  flagPriority = 'HIGH';\n  flagReasons.push('single_doc_new_sender');\n  sendReviewEmail = true;\n}\n\nif (isLowConfidence) {\n  needsReview = true;\n  flagPriority = 'HIGH';\n  flagReasons.push('low_confidence');\n  sendReviewEmail = true;\n}\n\n// MEDIUM priority flags (log only)\nif (isMediumConfidence && !flagReasons.includes('low_confidence')) {\n  needsReview = true;\n  if (flagPriority !== 'HIGH') flagPriority = 'MEDIUM';\n  flagReasons.push('medium_confidence');\n}\n\n// LOW priority flags (log only)\nif (isEmailMismatch) {\n  needsReview = true;\n  if (flagPriority === 'NONE') flagPriority = 'LOW';\n  flagReasons.push('project_email_mismatch');\n}\n\n// Build review summary\nconst reviewSummary = {\n  projectName,\n  senderEmail,\n  confidence: Math.round(overallConfidence * 100),\n  attachmentCount,\n  routingDecision,\n  matchType,\n  flagReasons: flagReasons.join(', '),\n  timestamp: new Date().toISOString()\n};\n\nreturn [{\n  json: {\n    ...input,\n    \n    // Flagging results\n    needsReview,\n    flagPriority,\n    flagReasons,\n    sendReviewEmail,\n    reviewSummary,\n    \n    // For downstream routing\n    proceedWithProcessing: true\n  }\n}];"
        },
        "id": "check-flag-conditions-001",
        "name": "Check Flag Conditions",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2128,
          296
        ]
      },
      {
        "parameters": {
          "conditions": {
            "combinator": "and",
            "conditions": [
              {
                "id": "condition-0",
                "leftValue": "={{ $json.sendReviewEmail }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals",
                  "singleValue": true
                }
              }
            ],
            "options": {
              "version": 2,
              "caseSensitive": true,
              "typeValidation": "loose"
            }
          },
          "options": {
            "looseTypeValidation": true
          }
        },
        "id": "if-send-review-001",
        "name": "Should Send Review Email?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          2352,
          296
        ]
      },
      {
        "parameters": {
          "jsCode": "// Prepare Review Email Data\nconst input = $input.first().json;\n\nconst summary = input.reviewSummary || {};\n\nconst emailSubject = `[Review Needed] New document: ${summary.projectName || 'Unknown'}`;\n\nconst emailBody = `\nA new document has been processed that may need your review.\n\nüìã DOCUMENT DETAILS\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nProject: ${summary.projectName || 'Unknown'}\nSender: ${summary.senderEmail || 'Unknown'}\nConfidence: ${summary.confidence || 0}%\nDocuments: ${summary.attachmentCount || 0}\nRouting: ${summary.routingDecision || 'Unknown'}\n\n‚ö†Ô∏è REVIEW REASONS\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n${(input.flagReasons || []).map(r => `‚Ä¢ ${r.replace(/_/g, ' ')}`).join('\\n')}\n\nüìå ACTION REQUIRED\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nPlease verify the classification is correct in the Client Tracker.\nIf incorrect, manually update the folder assignment.\n\n---\nAutomated message from Eugene Document Organizer V10\nTimestamp: ${summary.timestamp || new Date().toISOString()}\n`;\n\nreturn [{\n  json: {\n    ...input,\n    reviewEmailSubject: emailSubject,\n    reviewEmailBody: emailBody.trim(),\n    reviewEmailTo: 'sway@oloxa.ai'\n  }\n}];"
        },
        "id": "prepare-review-email-001",
        "name": "Prepare Review Email",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2576,
          504
        ]
      },
      {
        "parameters": {
          "sendTo": "={{ $json.reviewEmailTo }}",
          "subject": "={{ $json.reviewEmailSubject }}",
          "message": "={{ $json.reviewEmailBody }}",
          "options": {}
        },
        "id": "send-review-email-001",
        "name": "Send Review Email",
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.2,
        "position": [
          2800,
          504
        ],
        "webhookId": "bd30b99d-eb9f-4495-bdcf-1fa26483eb99",
        "credentials": {
          "gmailOAuth2": {
            "id": "aYzk7sZF8ZVyfOan",
            "name": "Gmail account"
          }
        }
      },
      {
        "parameters": {
          "rules": {
            "values": [
              {
                "conditions": {
                  "options": {
                    "caseSensitive": true,
                    "leftValue": "",
                    "typeValidation": "strict",
                    "version": 3
                  },
                  "conditions": [
                    {
                      "leftValue": "={{ $('Check Flag Conditions').first().json.routingDecision }}",
                      "rightValue": "UNKNOWN",
                      "operator": {
                        "type": "string",
                        "operation": "equals"
                      },
                      "id": "fdaa4cce-f659-4578-9c46-202690c03765"
                    }
                  ],
                  "combinator": "and"
                },
                "renameOutput": true,
                "outputKey": "unknown"
              },
              {
                "conditions": {
                  "options": {
                    "caseSensitive": true,
                    "leftValue": "",
                    "typeValidation": "strict",
                    "version": 3
                  },
                  "conditions": [
                    {
                      "leftValue": "={{ $('Check Flag Conditions').first().json.routingDecision }}",
                      "rightValue": "NEW",
                      "operator": {
                        "type": "string",
                        "operation": "equals"
                      },
                      "id": "80183d52-64e0-42d4-8909-3f740283fc72"
                    }
                  ],
                  "combinator": "and"
                },
                "renameOutput": true,
                "outputKey": "new"
              },
              {
                "conditions": {
                  "options": {
                    "caseSensitive": true,
                    "leftValue": "",
                    "typeValidation": "strict",
                    "version": 3
                  },
                  "conditions": [
                    {
                      "leftValue": "={{ $('Check Flag Conditions').first().json.routingDecision }}",
                      "rightValue": "EXISTING",
                      "operator": {
                        "type": "string",
                        "operation": "equals"
                      },
                      "id": "222204cf-bfa8-4db1-9aa2-49253f27b77a"
                    }
                  ],
                  "combinator": "and"
                },
                "renameOutput": true,
                "outputKey": "existing"
              }
            ]
          },
          "options": {
            "fallbackOutput": "none"
          }
        },
        "id": "decision-gate-001",
        "name": "Decision Gate",
        "type": "n8n-nodes-base.switch",
        "typeVersion": 3.4,
        "position": [
          3024,
          280
        ]
      },
      {
        "parameters": {
          "jsCode": "// Handle unidentified client - send to manual queue\n  const items = $input.all();\n  const results = [];\n\n  for (const item of items) {\n    results.push({\n      json: {\n        status: 'FAILED',\n        reason: 'Client name could not be identified',\n        email_id: item.json.emailId,\n        email_subject: item.json.emailSubject,\n        timestamp: new Date().toISOString()\n      }\n    });\n  }\n\n  return results;"
        },
        "id": "handle-unknown-001",
        "name": "Handle Unidentified Client",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3248,
          24
        ]
      },
      {
        "parameters": {
          "jsCode": "// Prepare UNKNOWN client data with simple static naming\n// V3: Use simple UNKNOWN_CLIENT naming instead of timestamp\nconst inputData = $input.first().json;\n\nconst clientName = \"unknown_client\";\n\nreturn [{\n  json: {\n    client_name: clientName,\n    parent_folder_id: inputData.parent_folder_id,\n    client_name_raw: inputData.client_name_raw,\n    client_status: inputData.client_status,\n    root_folder_id: inputData.root_folder_id,\n    staging_folder_id: inputData.staging_folder_id,\n    extraction_failure: inputData.extraction_failure,\n    extraction_error_message: inputData.extraction_error_message,\n    is_unknown_client: true,\n    unknown_timestamp: new Date().toISOString()\n  },\n  binary: $input.first().binary\n}];"
        },
        "id": "prepare-unknown-data-001",
        "name": "Prepare UNKNOWN Client Data",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3472,
          24
        ]
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "value": "zbxHkXOoD1qaz6OS",
            "mode": "list",
            "cachedResultUrl": "/workflow/zbxHkXOoD1qaz6OS",
            "cachedResultName": "AMA Chunk 0: Folder Initialization (V4 - Parameterized)"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "client_name": "={{ $json.clientName }}",
              "client_normalized": "={{ $json.clientNormalized }}",
              "sender_email": "={{ $json.senderEmail }}",
              "sender_name": "={{ $json.senderName }}",
              "email_subject": "={{ $json.subject }}"
            },
            "matchingColumns": [],
            "schema": [
              {
                "id": "client_name",
                "displayName": "client_name",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "client_normalized",
                "displayName": "client_normalized",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "sender_email",
                "displayName": "sender_email",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "sender_name",
                "displayName": "sender_name",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "email_subject",
                "displayName": "email_subject",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              }
            ],
            "attemptToConvertTypes": false,
            "convertFieldsToString": true
          },
          "options": {}
        },
        "id": "bc9b052a-1fdf-412c-990a-7c3e58178304",
        "name": "Execute Chunk 0 - Create Folders (UNKNOWN)",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.3,
        "position": [
          3696,
          200
        ]
      },
      {
        "parameters": {
          "jsCode": "// Extract 38_Unknowns folder ID from Chunk 0 response\n// ALSO get file_id from earlier in workflow\n\nconst chunk0Response = $input.first().json;\nconst folderData = chunk0Response.folderIDs || [];\n\nconst unknownsFolder = folderData.find(item =>\n  item.Variable_Name === 'FOLDER_38_UNKNOWNS'\n);\n\nif (!unknownsFolder || !unknownsFolder.Folder_ID) {\n  throw new Error('FOLDER_38_UNKNOWNS not found in Chunk 0 response');\n}\n\n// Get file_id from Extract File ID & Metadata node\nconst fileMetadata = $('Extract File ID & Metadata').first().json;\nconst fileId = fileMetadata.file_id;\n\nif (!fileId) {\n  throw new Error('file_id not found from Extract File ID & Metadata node');\n}\n\nreturn {\n  json: {\n    unknowns_folder_id: unknownsFolder.Folder_ID,\n    temp_pdf_file_id: fileId,\n    root_folder_id: chunk0Response.Root_Folder_ID,\n    client_name: chunk0Response.Client_Name,\n    ...chunk0Response\n  },\n  binary: $input.first().binary\n};\n"
        },
        "id": "extract-unknowns-folder-001",
        "name": "Extract 38_Unknowns Folder ID",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3920,
          200
        ]
      },
      {
        "parameters": {
          "jsCode": "const folderId = $json.unknowns_folder_id;\nconst fileId = $json.temp_pdf_file_id;\n\nif (!folderId || folderId === '') {\n  throw new Error('Missing unknowns_folder_id - cannot move file');\n}\n\nif (!fileId || fileId === '') {\n  throw new Error('Missing temp_pdf_file_id - no file to move');\n}\n\nreturn {\n  json: {\n    unknowns_folder_id: folderId,\n    temp_pdf_file_id: fileId,\n    ...$json\n  },\n  binary: $input.first().binary\n};"
        },
        "id": "validate-folder-ids-001",
        "name": "Validate Folder IDs",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          4144,
          200
        ]
      },
      {
        "parameters": {
          "operation": "move",
          "fileId": {
            "__rl": true,
            "value": "={{ $json.temp_pdf_file_id }}",
            "mode": "id"
          },
          "driveId": {
            "__rl": true,
            "mode": "list",
            "value": "My Drive"
          },
          "folderId": {
            "__rl": true,
            "value": "={{ $('Execute Chunk 0 - Create Folders (UNKNOWN)').item.json.folderIDs[43].Folder_ID }}",
            "mode": "id"
          }
        },
        "id": "move-pdf-unknowns-001",
        "name": "Move PDF to 38_Unknowns",
        "type": "n8n-nodes-base.googleDrive",
        "typeVersion": 3,
        "position": [
          4368,
          200
        ],
        "retryOnFail": true,
        "maxTries": 3,
        "waitBetweenTries": 5000,
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "a4m50EefR3DJoU0R",
            "name": "Google Drive account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Get data from correct sources\n// CRITICAL FIX: Get root_folder_id from Validate Folder IDs (before Move PDF wiped data)\nconst folderData = $('Validate Folder IDs').first().json;\nconst emailData = $('Gmail Trigger - Unread with Attachments').first().json;\nconst moveResult = $input.first().json;\n\nconst rootFolderId = folderData.Root_Folder_ID || folderData.root_folder_id;\nconst rootFolderName = folderData.Client_Name || folderData.client_name || 'UNKNOWN';\nconst unknownsFolderId = folderData.unknowns_folder_id;\nconst pdfFileId = moveResult.id || folderData.temp_pdf_file_id;\n\nconst pdfLink = `https://drive.google.com/file/d/${pdfFileId}/view`;\nconst rootFolderLink = `https://drive.google.com/drive/folders/${rootFolderId}`;\n\nconst emailFrom = emailData.from || 'Unknown Sender';\nconst emailSubject = emailData.subject || 'No Subject';\nconst pdfFilename = folderData.pdf_filename || 'unknown.pdf';\n\nconst timestamp = new Date().toLocaleString('en-US', {\n  timeZone: 'Europe/Berlin',\n  year: 'numeric',\n  month: '2-digit',\n  day: '2-digit',\n  hour: '2-digit',\n  minute: '2-digit',\n  hour12: false\n});\n\nreturn [{\n  json: {\n    to: 'swayclarkeii@gmail.com',\n    pdf_filename: pdfFilename,\n    email_from: emailFrom,\n    email_subject: emailSubject,\n    root_folder_name: rootFolderName,\n    pdf_link: pdfLink,\n    root_folder_link: rootFolderLink,\n    timestamp: timestamp\n  },\n  binary: $input.first().binary\n}];"
        },
        "id": "prepare-email-data-001",
        "name": "Prepare Email Notification Data",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          4592,
          200
        ]
      },
      {
        "parameters": {
          "jsCode": "// Build HTML email body for UNKNOWN client notification\nconst data = $input.first().json;\n\n// Extract just the email address (not the display name)\nconst emailAddress = data.email_from?.value?.[0]?.address || 'Unknown Sender';\n\nconst htmlBody = `<!DOCTYPE html>\n<html>\n<body style=\"font-family: Arial, sans-serif; line-height: 1.6; color: #333;\">\n  <div style=\"max-width: 600px; margin: 0 auto; padding: 20px;\">\n    <h2 style=\"color: #d32f2f;\">‚ö†Ô∏è Unknown Client Document Received</h2>\n    \n    <p>A document was received but the client could not be identified. Manual review is required.</p>\n    \n    <div style=\"background: #f5f5f5; padding: 15px; border-left: 4px solid #1976d2; margin: 20px 0;\">\n      <h3 style=\"margin-top: 0;\">Document Details</h3>\n      <ul style=\"list-style: none; padding: 0;\">\n        <li><strong>Filename:</strong> ${data.pdf_filename}</li>\n        <li><strong>From:</strong> ${emailAddress}</li>\n        <li><strong>Subject:</strong> ${data.email_subject}</li>\n      </ul>\n    </div>\n    \n    <div style=\"background: #fff3e0; padding: 15px; border-left: 4px solid #f57c00; margin: 20px 0;\">\n      <h3 style=\"margin-top: 0;\">üìÇ Created Folder Structure</h3>\n      <p>A temporary folder structure has been created:</p>\n      <ul style=\"list-style: none; padding: 0;\">\n        <li><strong>Root Folder:</strong> ${data.root_folder_name}</li>\n        <li><strong>Document Location:</strong> SONSTIGES/38_Unknowns/</li>\n      </ul>\n    </div>\n    \n    <div style=\"margin: 30px 0;\">\n      <h3>üîó Quick Actions</h3>\n      <div style=\"margin: 10px 0;\">\n        <a href=\"${data.pdf_link}\" \n           style=\"display: inline-block; padding: 12px 24px; background: #1976d2; color: white; text-decoration: none; border-radius: 4px; margin-right: 10px;\">\n          üìÑ View PDF\n        </a>\n        <a href=\"${data.root_folder_link}\" \n           style=\"display: inline-block; padding: 12px 24px; background: #43a047; color: white; text-decoration: none; border-radius: 4px;\">\n          üìÅ Open Folder Structure\n        </a>\n      </div>\n    </div>\n    \n    <div style=\"background: #e3f2fd; padding: 15px; border-left: 4px solid #1976d2; margin: 20px 0;\">\n      <h3 style=\"margin-top: 0;\">‚úÖ Next Steps</h3>\n      <ol>\n        <li>Review the PDF to identify the client</li>\n        <li>Rename the root folder to the correct client name</li>\n        <li>Update the Client_Registry sheet with the correct client name</li>\n        <li>Move the PDF from 38_Unknowns to the appropriate subfolder</li>\n      </ol>\n    </div>\n    \n    <hr style=\"border: none; border-top: 1px solid #ddd; margin: 30px 0;\">\n    \n    <p style=\"font-size: 12px; color: #666;\">\n      <strong>System:</strong> Eugene AMA Document Organizer V4<br>\n      <strong>Timestamp:</strong> ${data.timestamp}\n    </p>\n  </div>\n</body>\n</html>`;\n\nreturn [{\n  json: {\n    ...data,\n    html_body: htmlBody\n  },\n  binary: $input.first().binary\n}];"
        },
        "id": "build-email-html-001",
        "name": "Build Email HTML Body",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          4816,
          200
        ]
      },
      {
        "parameters": {
          "sendTo": "swayclarkeii@gmail.com",
          "subject": "={{ $json.emailSubject || '[ACTION REQUIRED] Unknown Client Document' }}",
          "message": "={{ $json.html_body }}",
          "options": {}
        },
        "id": "send-email-notification-001",
        "name": "Send Email Notification",
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2,
        "position": [
          5040,
          200
        ],
        "webhookId": "dc7eb55f-c28e-4cdc-83a8-fe7d1c1a01c4",
        "credentials": {
          "gmailOAuth2": {
            "id": "aYzk7sZF8ZVyfOan",
            "name": "Gmail account"
          }
        }
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "value": "zbxHkXOoD1qaz6OS",
            "mode": "list",
            "cachedResultUrl": "/workflow/zbxHkXOoD1qaz6OS",
            "cachedResultName": "AMA Chunk 0: Folder Initialization (V4 - Parameterized)"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "client_name": "={{ $('Batch Voting - Find Common Identifier').first().json.clientName }}",
              "client_normalized": "={{ $('Batch Voting - Find Common Identifier').first().json.clientNormalized }}",
              "sender_email": "={{ $('Batch Voting - Find Common Identifier').first().json.senderEmail }}",
              "sender_name": "={{ $('Batch Voting - Find Common Identifier').first().json.senderName }}",
              "email_subject": "={{ $('Batch Voting - Find Common Identifier').first().json.subject }}"
            },
            "matchingColumns": [],
            "schema": [
              {
                "id": "client_name",
                "displayName": "client_name",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "client_normalized",
                "displayName": "client_normalized",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "sender_email",
                "displayName": "sender_email",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "sender_name",
                "displayName": "sender_name",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "email_subject",
                "displayName": "email_subject",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              }
            ],
            "attemptToConvertTypes": false,
            "convertFieldsToString": true
          },
          "options": {}
        },
        "id": "execute-chunk0-001",
        "name": "Execute Chunk 0 - Create Folders (NEW)",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.3,
        "position": [
          3248,
          216
        ]
      },
      {
        "parameters": {
          "jsCode": "// Merge Chunk 0 output with file data - output ONE item per file\nconst chunk0Output = $input.first().json;\n\n// Get analysisResults from Batch Voting (NOT Decision Gate - which might have Gmail response)\nconst batchVotingData = $('Batch Voting - Find Common Identifier').first().json;\nconst analysisResults = batchVotingData.analysisResults || [];\n\n// Output one item per file (n8n will loop automatically)\nreturn analysisResults.map(file => ({\n  json: {\n    ...chunk0Output,\n    file_id: file.fileId,\n    email_id: batchVotingData.emailId,\n    filename: file.fileName,\n    // Keep all original chunk0 data\n    clientName: chunk0Output.Client_Name || batchVotingData.clientName,\n    clientNormalized: chunk0Output.Client_Normalized || batchVotingData.clientNormalized,\n    Staging_Folder_ID: chunk0Output.Staging_Folder_ID,\n    Root_Folder_ID: chunk0Output.Root_Folder_ID,\n    analysisResults: analysisResults  // Keep full array for downstream\n  }\n}));"
        },
        "id": "0180f051-407b-453b-89fc-faaf3439c20d",
        "name": "Merge Chunk 0 Output (NEW)",
        "type": "n8n-nodes-base.code",
        "typeVersion": 1,
        "position": [
          3472,
          216
        ]
      },
      {
        "parameters": {
          "operation": "move",
          "fileId": {
            "__rl": true,
            "value": "={{ $json.file_id }}",
            "mode": "id"
          },
          "driveId": {
            "__rl": true,
            "mode": "list",
            "value": "My Drive"
          },
          "folderId": {
            "__rl": true,
            "value": "={{ $json.Staging_Folder_ID }}",
            "mode": "id"
          }
        },
        "id": "b767c01a-345c-4a94-ba35-35f8dda0fb2c",
        "name": "Move PDF to _Staging (NEW)",
        "type": "n8n-nodes-base.googleDrive",
        "typeVersion": 3,
        "position": [
          3696,
          392
        ],
        "retryOnFail": true,
        "maxTries": 3,
        "waitBetweenTries": 5000,
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "a4m50EefR3DJoU0R",
            "name": "Google Drive account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Prepare for Chunk 2.5 (NEW) - Multi-file version\n// This node now receives N items (one per file moved to staging)\n// Process each item individually\n\nconst items = $input.all();\n\n// Get shared data from upstream nodes (same for all files)\nconst emailData = $('Gmail Trigger - Unread with Attachments').first().json;\nconst binaryData = $('Gmail Trigger - Unread with Attachments').first().binary;\nconst clientData = $('Batch Voting - Find Common Identifier').first().json;\n\n// Get first attachment key for size info\nconst attachmentKeys = Object.keys(binaryData || {});\n\n// Extract email sender\nlet emailFrom = '';\nif (emailData.from && emailData.from.value && emailData.from.value[0]) {\n  emailFrom = emailData.from.value[0].address;\n}\n\n// Process each file\nreturn items.map((item, index) => {\n  const driveFile = item.json;\n  const fileName = driveFile.name || 'unknown.pdf';\n  const extension = fileName.substring(fileName.lastIndexOf('.') + 1).toLowerCase();\n  \n  // Get size from corresponding attachment if available\n  let fileSizeBytes = 0;\n  const attachmentKey = attachmentKeys[index] || attachmentKeys[0];\n  const attachment = binaryData?.[attachmentKey] || {};\n  if (attachment.fileSize) {\n    const sizeStr = attachment.fileSize;\n    const match = sizeStr.match(/^([\\d.]+)\\s*(KB|MB|GB)$/i);\n    if (match) {\n      const value = parseFloat(match[1]);\n      const unit = match[2].toUpperCase();\n      const multipliers = { KB: 1024, MB: 1024 * 1024, GB: 1024 * 1024 * 1024 };\n      fileSizeBytes = Math.round(value * multipliers[unit]);\n    }\n  }\n  \n  // Construct stagingPath\n  const clientName = clientData.clientNormalized || clientData.clientName || 'unknown';\n  const stagingPath = `${clientName}/_Staging/${fileName}`;\n  \n  // Find analysis result for this file\n  const analysisResults = clientData.analysisResults || [];\n  const fileAnalysis = analysisResults.find(a => a.fileId === driveFile.id) || analysisResults[index] || {};\n  const extractedText = fileAnalysis.identifier || clientData.clientName || '';\n  const extractionMethod = fileAnalysis.extractionMethod || 'claude_vision';\n  const textLength = extractedText.length || 0;\n  \n  return {\n    json: {\n      fileId: driveFile.id,\n      fileName: driveFile.name,\n      mimeType: driveFile.mimeType,\n      extension: extension,\n      size: fileSizeBytes,\n      emailId: emailData.id,\n      emailFrom: emailFrom,\n      emailSubject: emailData.subject,\n      emailDate: emailData.date,\n      stagingPath: stagingPath,\n      originalFileName: attachment.fileName || fileName,\n      extractedFromZip: false,\n      zipFileName: null,\n      client_name: clientData.clientName,\n      client_normalized: clientData.clientNormalized,\n      \n      // Pass Claude Vision extracted identifier to Chunk 2.5\n      extractedText: extractedText,\n      extractionMethod: extractionMethod,\n      extractionModel: 'claude-sonnet-4-20250514',\n      textLength: textLength,\n      skipDownload: textLength > 5,\n      \n      // Track file index\n      fileIndex: index,\n      totalFiles: items.length\n    }\n  };\n});"
        },
        "id": "prepare-chunk2-new-001",
        "name": "Prepare for Chunk 2.5 (NEW)",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          4144,
          392
        ],
        "notes": "Enriches Google Drive data with email metadata for Chunk 2"
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "value": "okg8wTqLtPUwjQ18",
            "mode": "list",
            "cachedResultName": "Chunk 2.5 - Client Document Tracking (Eugene Document Organizer)"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {}
          },
          "options": {}
        },
        "id": "execute-chunk2-new-001",
        "name": "Execute Chunk 2.5 (NEW)",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.3,
        "position": [
          4368,
          392
        ],
        "notes": "Executes Chunk 2 text extraction workflow"
      },
      {
        "parameters": {
          "operation": "markAsRead",
          "messageId": "={{ $('Gmail Trigger - Unread with Attachments').first().json.id }}"
        },
        "id": "mark-read-new-001",
        "name": "Mark Email as Read (NEW)",
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          4592,
          392
        ],
        "webhookId": "aa32d8bd-c351-4f48-9356-212f242a6ea6",
        "credentials": {
          "gmailOAuth2": {
            "id": "aYzk7sZF8ZVyfOan",
            "name": "Gmail account"
          }
        },
        "notes": "Marks the processed email as read"
      },
      {
        "parameters": {},
        "id": "noop-new-complete-001",
        "name": "NoOp - NEW Complete",
        "type": "n8n-nodes-base.noOp",
        "typeVersion": 1,
        "position": [
          4816,
          392
        ]
      },
      {
        "parameters": {
          "documentId": {
            "__rl": true,
            "mode": "id",
            "value": "1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI"
          },
          "sheetName": {
            "__rl": true,
            "value": 762792134,
            "mode": "list",
            "cachedResultName": "Client_Registry",
            "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI/edit#gid=762792134"
          },
          "options": {}
        },
        "id": "lookup-staging-folder-001",
        "name": "Lookup Staging Folder",
        "type": "n8n-nodes-base.googleSheets",
        "typeVersion": 4.7,
        "position": [
          3248,
          504
        ],
        "credentials": {
          "googleSheetsOAuth2Api": {
            "id": "H7ewI1sOrDYabelt",
            "name": "Google Sheets account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// V7: FIXED - Use clientNormalized instead of client_name\n// Extract staging_folder_id from Client Registry lookup AND file_id from upload\nconst clientNormalized = $('Batch Voting - Find Common Identifier').first().json.clientNormalized;\nconst sheetRows = $input.all();\nconst batchVotingData = $('Batch Voting - Find Common Identifier').first().json;\nconst analysisResults = batchVotingData.analysisResults || [];\n\n// Find matching row by normalizing Client_Name the same way as \"Batch Voting\" node\nconst matchingRow = sheetRows.find(row => {\n  const registryClientName = row.json.Client_Name || '';\n  \n  // Normalize Client_Name to match clientNormalized format\n  const normalizedName = registryClientName\n    .toLowerCase()\n    .trim()\n    .replace(/√§/g, 'ae')\n    .replace(/√∂/g, 'oe')\n    .replace(/√º/g, 'ue')\n    .replace(/√ü/g, 'ss')\n    .replace(/\\s*(gmbh|ag|kg|e\\.v\\.|mbh|co\\.|&\\s*co\\.?)\\s*/gi, '')\n    .replace(/[^a-z0-9]/g, '_')\n    .replace(/_+/g, '_')\n    .replace(/^_|_$/g, '');\n  \n  return normalizedName === clientNormalized;\n});\n\n// GRACEFUL HANDLING: Route to 38_Unknowns if no matching row\nif (!matchingRow) {\n  return analysisResults.map(file => ({\n    json: {\n      file_id: file.fileId,\n      filename: file.fileName,\n      email_id: batchVotingData.emailId,\n      clientNormalized: clientNormalized,\n      clientName: batchVotingData.clientName,\n      error: `No staging folder found for client: ${clientNormalized}`,\n      routeTo38Unknowns: true,\n      errorType: 'missing_client_in_registry',\n      skipChunk1: true,\n      analysisResults: analysisResults\n    }\n  }));\n}\n\nconst stagingFolderId = matchingRow.json.Staging_Folder_ID || matchingRow.json['01_Staging'];\n\n// GRACEFUL HANDLING: Route to 38_Unknowns if staging folder ID is empty\nif (!stagingFolderId) {\n  return analysisResults.map(file => ({\n    json: {\n      file_id: file.fileId,\n      filename: file.fileName,\n      email_id: batchVotingData.emailId,\n      clientNormalized: clientNormalized,\n      clientName: batchVotingData.clientName,\n      error: `Staging_Folder_ID is empty for client: ${clientNormalized}`,\n      routeTo38Unknowns: true,\n      errorType: 'missing_staging_folder',\n      skipChunk1: true,\n      analysisResults: analysisResults\n    }\n  }));\n}\n\n// SUCCESS PATH: Output one item per file\nreturn analysisResults.map(file => ({\n  json: {\n    clientNormalized: clientNormalized,\n    clientName: batchVotingData.clientName,\n    Staging_Folder_ID: stagingFolderId,\n    email_id: batchVotingData.emailId,\n    file_id: file.fileId,\n    filename: file.fileName,\n    routeTo38Unknowns: false,\n    analysisResults: analysisResults\n  }\n}));"
        },
        "id": "filter-staging-folder-001",
        "name": "Filter Staging Folder ID",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3472,
          504
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "strict",
              "version": 1
            },
            "conditions": [
              {
                "id": "route-unknowns-check",
                "leftValue": "={{ $json.routeTo38Unknowns }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "true",
                  "singleValue": true
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "check-routing-decision-001",
        "name": "Check Routing Decision",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          3696,
          624
        ]
      },
      {
        "parameters": {
          "operation": "move",
          "fileId": {
            "__rl": true,
            "value": "={{ $json.file_id }}",
            "mode": "id"
          },
          "driveId": {
            "__rl": true,
            "mode": "list",
            "value": "My Drive"
          },
          "folderId": {
            "__rl": true,
            "value": "={{ $json.Staging_Folder_ID }}",
            "mode": "id"
          }
        },
        "id": "90cc99fd-908d-4149-a2f7-35f42ab2e232",
        "name": "Move PDF to _Staging (EXISTING)",
        "type": "n8n-nodes-base.googleDrive",
        "typeVersion": 3,
        "position": [
          3920,
          584
        ],
        "alwaysOutputData": true,
        "retryOnFail": true,
        "maxTries": 3,
        "waitBetweenTries": 5000,
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "a4m50EefR3DJoU0R",
            "name": "Google Drive account"
          }
        }
      },
      {
        "parameters": {
          "amount": 3
        },
        "id": "wait-staging-existing-001",
        "name": "Wait After Staging (EXISTING)",
        "type": "n8n-nodes-base.wait",
        "typeVersion": 1.1,
        "position": [
          4144,
          584
        ],
        "alwaysOutputData": true,
        "executeOnce": false,
        "webhookId": "582865bf-87ef-485e-9074-f3538bf7e781"
      },
      {
        "parameters": {
          "jsCode": "// Prepare for Chunk 2.5 (EXISTING) - V10 Fixed node references\n// Get Google Drive upload result from previous node\nconst driveUpload = $input.first().json;\n\n// Retrieve email metadata from Gmail Trigger\nconst emailData = $('Gmail Trigger - Unread with Attachments').first().json;\n\n// Retrieve binary metadata from Gmail Trigger\nconst binaryData = $('Gmail Trigger - Unread with Attachments').first().binary;\n\n// Get first attachment key\nconst attachmentKeys = Object.keys(binaryData || {});\nconst attachmentKey = attachmentKeys[0] || 'attachment_0';\nconst attachment = binaryData?.[attachmentKey] || {};\n\n// Extract file extension from filename\nconst fileName = driveUpload.name || 'unknown.pdf';\nconst extension = fileName.substring(fileName.lastIndexOf('.') + 1).toLowerCase();\n\n// FIXED: Get client data from Batch Voting node (was incorrectly referencing 'Normalize Client Name')\nconst clientData = $('Batch Voting - Find Common Identifier').first().json;\nconst clientName = clientData.clientNormalized || clientData.clientName || 'unknown';\n\n// Construct stagingPath\nconst stagingPath = `${clientName}/_Staging/${fileName}`;\n\n// Parse file size\nlet fileSizeBytes = 0;\nif (attachment.fileSize) {\n  const sizeStr = attachment.fileSize;\n  const match = sizeStr.match(/^([\\d.]+)\\s*(KB|MB|GB)$/i);\n  if (match) {\n    const value = parseFloat(match[1]);\n    const unit = match[2].toUpperCase();\n    const multipliers = { KB: 1024, MB: 1024 * 1024, GB: 1024 * 1024 * 1024 };\n    fileSizeBytes = Math.round(value * multipliers[unit]);\n  }\n}\n\n// Extract email sender\nlet emailFrom = '';\nif (emailData.from && emailData.from.value && emailData.from.value[0]) {\n  emailFrom = emailData.from.value[0].address;\n}\n\n// Get extracted identifier from Batch Voting (which has analysisResults from Claude)\nconst analysisResults = clientData.analysisResults || [];\nconst firstAnalysis = analysisResults[0] || {};\nconst extractedText = firstAnalysis.identifier || clientData.clientName || '';\nconst extractionMethod = firstAnalysis.extractionMethod || 'claude_vision';\nconst textLength = extractedText.length || 0;\n\n// Build complete Chunk 2.5 input\nreturn [{\n  json: {\n    fileId: driveUpload.id,\n    fileName: driveUpload.name,\n    mimeType: driveUpload.mimeType,\n    extension: extension,\n    size: fileSizeBytes,\n    emailId: emailData.id,\n    emailFrom: emailFrom,\n    emailSubject: emailData.subject,\n    emailDate: emailData.date,\n    stagingPath: stagingPath,\n    originalFileName: attachment.fileName || fileName,\n    extractedFromZip: false,\n    zipFileName: null,\n    client_name: clientData.clientName,\n    client_normalized: clientData.clientNormalized,\n\n    // Pass Claude Vision extracted identifier to Chunk 2.5\n    extractedText: extractedText,\n    extractionMethod: extractionMethod,\n    extractionModel: 'claude-sonnet-4-20250514',\n    textLength: textLength,\n    skipDownload: textLength > 5\n  }\n}];"
        },
        "id": "prepare-chunk2-existing-001",
        "name": "Prepare for Chunk 2.5 (EXISTING)",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          4368,
          584
        ],
        "notes": "Enriches Google Drive data with email metadata for Chunk 2"
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "value": "okg8wTqLtPUwjQ18",
            "mode": "list",
            "cachedResultName": "Chunk 2.5 - Client Document Tracking (Eugene Document Organizer)"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {}
          },
          "options": {}
        },
        "id": "execute-chunk2-existing-001",
        "name": "Execute Chunk 2.5 (EXISTING)",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.3,
        "position": [
          4592,
          584
        ],
        "notes": "Executes Chunk 2 text extraction workflow"
      },
      {
        "parameters": {
          "operation": "markAsRead",
          "messageId": "={{ $('Gmail Trigger - Unread with Attachments').first().json.id }}"
        },
        "id": "mark-read-existing-001",
        "name": "Mark Email as Read (EXISTING)",
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          4816,
          584
        ],
        "webhookId": "2542dae1-6ffe-419e-9bff-6be0b9b8b5be",
        "credentials": {
          "gmailOAuth2": {
            "id": "aYzk7sZF8ZVyfOan",
            "name": "Gmail account"
          }
        },
        "notes": "Marks the processed email as read"
      },
      {
        "parameters": {},
        "id": "noop-existing-complete-001",
        "name": "NoOp - EXISTING Complete",
        "type": "n8n-nodes-base.noOp",
        "typeVersion": 1,
        "position": [
          5040,
          584
        ]
      },
      {
        "parameters": {
          "jsCode": "// V2: Multi-file handling - Prepare data for routing to 38_Unknowns when staging folder is missing\nconst items = $input.all();\n\n// Output one error item per file\nreturn items.map(item => ({\n  json: {\n    client_name: 'unknown_client',\n    parent_folder_id: '1ikw3k-EgpVg_h2ySDdqdUFB7-FQyYDFm',\n    client_status: 'UNKNOWN',\n    is_unknown_client: true,\n    error_reason: item.json.error || 'Missing staging folder',\n    error_type: item.json.errorType || 'missing_staging_folder',\n    file_id: item.json.file_id,\n    filename: item.json.filename,\n    email_id: item.json.email_id,\n    unknown_timestamp: new Date().toISOString(),\n    analysisResults: item.json.analysisResults\n  }\n}));"
        },
        "id": "prepare-missing-folder-error-001",
        "name": "Prepare Missing Folder Error",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3920,
          776
        ]
      },
      {
        "parameters": {
          "jsCode": "// Format error email data for registry corruption\nconst inputData = $input.all();\n\nconst output = inputData.map(item => {\n  const clientName = item.json.client_name || 'Unknown Client';\n  const fileName = item.json.file_name || 'Unknown File';\n  const emailSubject = item.json.email_subject || 'N/A';\n  const emailFrom = item.json.email_from || 'N/A';\n  const emailDate = item.json.email_date || 'N/A';\n  \n  return {\n    json: {\n      ...item.json,\n      email_to: 'swayclarkeii@gmail.com',\n      email_subject: `[URGENT] Registry Error: ${clientName} - Missing Staging Folder`,\n      email_message: `CRITICAL REGISTRY ERROR DETECTED\n\nClient: ${clientName}\nError Type: Client marked EXISTING but staging_folder_id is MISSING in Client Registry\n\n--- ACTION TAKEN ---\nFile moved to 38_Unknowns folder for manual review\n\n--- ORIGINAL EMAIL DETAILS ---\nSubject: ${emailSubject}\nFrom: ${emailFrom}\nDate: ${emailDate}\nAttachment: ${fileName}\n\n--- NEXT STEPS ---\nPlease:\n1. Open the Client Registry spreadsheet\n2. Find the row for \"${clientName}\"\n3. Add the missing staging_folder_id to column E\n4. Manually move the file from 38_Unknowns to the correct staging folder\n\nThis is a data integrity issue that needs immediate attention.\n\n---\nWorkflow: AMA Pre-Chunk 0\nNode: Registry Error Handler`\n    }\n  };\n});\n\nreturn output;"
        },
        "id": "prepare-registry-error-email-001",
        "name": "Prepare Registry Error Email Data",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          4144,
          776
        ]
      },
      {
        "parameters": {
          "sendTo": "={{ $json.email_to }}",
          "subject": "={{ $json.email_subject }}",
          "message": "={{ $json.email_message }}",
          "options": {}
        },
        "id": "send-registry-error-email-001",
        "name": "Send Registry Error Email",
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          4368,
          776
        ],
        "webhookId": "95afad2f-dd9b-48e1-ab8f-1054d2466b08",
        "credentials": {
          "gmailOAuth2": {
            "id": "aYzk7sZF8ZVyfOan",
            "name": "Gmail account"
          }
        }
      },
      {
        "parameters": {
          "operation": "move",
          "fileId": {
            "__rl": true,
            "mode": "id",
            "value": "={{ $json.file_id }}"
          },
          "driveId": {
            "__rl": true,
            "mode": "list",
            "value": "My Drive"
          },
          "folderId": {
            "__rl": true,
            "mode": "list",
            "value": "1qdUu-dIkQR0oDaZKAL_8OhI0jST89_Vu"
          }
        },
        "id": "move-to-unknowns-registry-001",
        "name": "Move to 38_Unknowns (Registry Error)",
        "type": "n8n-nodes-base.googleDrive",
        "typeVersion": 3,
        "position": [
          4592,
          776
        ],
        "retryOnFail": true,
        "maxTries": 3,
        "waitBetweenTries": 5000,
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "a4m50EefR3DJoU0R",
            "name": "Google Drive account"
          }
        }
      },
      {
        "parameters": {
          "operation": "addLabels",
          "messageId": "={{ $json.email_id }}",
          "labelIds": [
            "INBOX"
          ]
        },
        "id": "mark-read-registry-error-001",
        "name": "Mark Email as Read (Registry Error)",
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          4816,
          776
        ],
        "webhookId": "dbf7cd2a-877f-4ff9-85a5-a04f5f4fa02a",
        "credentials": {
          "gmailOAuth2": {
            "id": "aYzk7sZF8ZVyfOan",
            "name": "Gmail account"
          }
        }
      },
      {
        "parameters": {},
        "id": "noop-registry-complete-001",
        "name": "NoOp - Registry Error Complete",
        "type": "n8n-nodes-base.noOp",
        "typeVersion": 1,
        "position": [
          5040,
          776
        ]
      },
      {
        "parameters": {
          "operation": "pdf",
          "options": {
            "joinPages": true,
            "keepSource": "json"
          }
        },
        "id": "extract-text-001",
        "name": "Extract Text from PDF",
        "type": "n8n-nodes-base.extractFromFile",
        "typeVersion": 1.1,
        "position": [
          784,
          1016
        ],
        "disabled": true,
        "notes": "‚ö†Ô∏è OLD METHOD - Disabled. Use 'Prepare Document AI Request' path instead for proper OCR."
      },
      {
        "parameters": {
          "jsCode": "// V4: Evaluate extraction quality for each PDF\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  // FIX: Check both extractedText (from OCR) and text (from digital extraction)\n  const extractedText = item.json.extractedText || item.json.text || '';\n  const wordCount = extractedText.trim().split(/\\s+/).length;\n\n  results.push({\n    json: {\n      ...item.json,\n      wordCount: wordCount,\n      needsOCR: wordCount < 10,\n      extractionQuality: wordCount < 10 ? 'poor' : 'good',\n      \n      // Keep extracted text for downstream use\n      extractedText: extractedText,\n      textLength: extractedText.trim().length,\n      extractionMethod: 'digital_pre_chunk'\n    },\n    binary: item.binary\n  });\n}\n\nreturn results;"
        },
        "id": "evaluate-extraction-001",
        "name": "Evaluate Extraction Quality",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1008,
          872
        ],
        "disabled": true
      },
      {
        "parameters": {
          "resource": "chat",
          "chatModel": "gpt-4.1-mini",
          "prompt": {
            "messages": [
              {
                "role": "system",
                "content": "Extract the PROJECT or PROPERTY IDENTIFIER from this German real estate document.\n\nValid identifiers (in order of priority):\n\n1. STREET ADDRESS + CITY (MOST COMMON IN THESE DOCUMENTS):\n   - \"Schlo√übergstra√üe 13, T√ºbingen\" ‚Üí \"Schlossberg 13\"\n   - \"Schlo√übergstr. 13\" ‚Üí \"Schlossberg 13\"\n   - Normalize: Remove \"stra√üe/str.\", keep number\n\n2. PROJECT CODES/ABBREVIATIONS:\n   - \"BV Propos\" ‚Üí \"Propos\"\n   - \"Projekt Schlo√überg\" ‚Üí \"Schlossberg\"\n\n3. PROPERTY/VILLA NAMES\n\n4. COMPANY NAMES (if property-related)\n\n5. PERSON/RECIPIENT NAMES (last resort)\n\nEXTRACTION RULES:\n- Look for street addresses FIRST\n- \"Schlo√überg\" and \"Schlossberg\" are the same (normalize to \"Schlossberg\")\n- Combine street name + number: \"Schlo√übergstra√üe 13\" ‚Üí \"Schlossberg 13\"\n\nReturn ONLY the normalized identifier, nothing else.\nIf no identifiable project/property exists, return exactly: UNKNOWN"
              },
              {
                "content": "={{ $json.extractedText }}"
              }
            ]
          },
          "options": {},
          "requestOptions": {}
        },
        "id": "ai-extract-client-001",
        "name": "AI Extract Client Name",
        "type": "n8n-nodes-base.openAi",
        "typeVersion": 1.1,
        "position": [
          1232,
          872
        ],
        "credentials": {
          "openAiApi": {
            "id": "xmJ7t6kaKgMwA1ce",
            "name": "OpenAi account"
          }
        },
        "disabled": true
      },
      {
        "parameters": {
          "jsCode": "const crypto = require('crypto');\n\n// Google Service Account credentials\nconst serviceAccount = {\n  projectId: 'n8n-integrations-482020',\n  clientEmail: 'n8n-document-ai@n8n-integrations-482020.iam.gserviceaccount.com',\n  privateKey: `-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCwWo8CBWPs5tvS\nP01jLTf6Rc54JrOCEU1KIOpkZryrT082kD/eXx73unpLGUCb9t5u9kjCjiU8BPMp\nqnPQSCVzeuMNWLYcyQfGIUFRfCSi/7bg5q1mwv+DkLsgNWx0mRAk5pfPCv9qW9qk\n+XyNYtqk3FlgWBRtynwd49cCN1FoaRgTQTv6KsRtqV7nc6MyE+VyyhMY64uoQfCN\nd+PrXkE20yDaNg/yZU/re3/2kqeWVt3F5nxZFbuM2wBof0wLQcqkZ/ggN9/C/zdp\nBpTnZlTadNzjPePKGBaMHyDP01/E4xUU9d9TJMM4OWc5ReFIMlSdYnzjhuir1+5A\no2JmvpmRAgMBAAECggEADZAkGC4H8wwHnfzmW8P6M9Jd6xm24UBUEb5u/c0fojaV\noLGpZ9XS+48o9qZONMXgx5HuI0sWtq3+xuvoFP280PaDiImTv/+qDGU5sSWmFQSB\nBn0B8GRQ4x0kzHkEtVb29I+TigXjgkTm5PHserHpSkKe0Re/wniPNnvzvk+OKu8W\nvnSleUP8NamyIxoMRZNWYdUI/yJvU6o2nuxZKe6aVvaF2T3eQ/3pYucvfgsV7L1i\nkle6T//NjEmrpeFtZEAgrnAAWLso7R+pbN08zc3Jbxb5Q1E6WABlTi6gbI9tmwuu\n53pe1GY4AGNpfGUiIO/UX/R+9/DSYCMrQMhqTdD8fQKBgQDptBqfAmcDgC9hFkSA\nopIxslCCsQ56eXTyZ0BL+qQiFyhQFmV3Do4vVLatJvZiUIWonNYxZYfxEMP06dW+\nk/Bu4NAoSc46wlvY1Bj9xOn7s/afNlY4J0YKrSpIuqQZHyhjERvK7Nn1UHDZ92qJ\nFXvaNJ0uUUYry5xuYrbwrfECKwKBgQDBLcNJsXKVYmaMh/xkucAKeeOWy/ME2kZz\noyEFcmgQhKU0Sr7C0OdLE3JnlL+9oz0ashBPb06Y0vsqDzl+0iwU81oc1RD/wBZz\nBgV2NB0jYvsIHFkI4BY5p4fePF5Q97UCaGttBf3JL1fFFeif/r1Rq2FbAnnpXsqF\npHrOFKsBMwKBgQC6CmjiyhvNWp7c78gKiuBMdYHH+EDpWISzb2Rs15MPnFW4I4wU\nUd74aLyfbJPYwfcUuf19BzFHwyvrbLZ95vEQoyCx4cctWYmaO4XFhpsphyK9rZjH\nTORiHWW6zfFSGk6hRn5UdWYw9h9QNLh3dkXI9/dkZsiwln7qFOVDBYUFTwKBgC7r\nnJlTnk8mXV4Y0XbtnvVscZj45IfzNFV189lM1nXcofu3g+nxr5wOlyUNfhzjfz3y\nrf99O4vnAtZOaFqjVc2o5eRG5CAaWdmKRt1U/xbPPcXUjNOZCgzq4hdadlYYNEDn\nd+A9Kk0pUJowHhZuWzFw/O6MBWxnd61KLAHOB1L9AoGARwyJIEwHeUeoAuCRlQyS\nxYzI8eMIDJ7HSiaFms+j8cuNy76O9U5E0KVBz6BEeTfq+aym0vyZ6iKJ3+q/IXQ4\no5jc6G6zgrMAgeuKzKFEwKNK/tm5j3FiDEzcUqLI00AfdG/f+QI/dTxbqnlB1tPn\nT0v0rf9bjMnUWoH9kXFM+XA=\n-----END PRIVATE KEY-----`\n};\n\n// Step 1: Create JWT token\nconst now = Math.floor(Date.now() / 1000);\nconst jwtHeader = {\n  alg: 'RS256',\n  typ: 'JWT'\n};\n\nconst jwtClaims = {\n  iss: serviceAccount.clientEmail,\n  scope: 'https://www.googleapis.com/auth/cloud-platform',\n  aud: 'https://oauth2.googleapis.com/token',\n  exp: now + 3600,\n  iat: now\n};\n\n// Encode header and claims\nconst base64UrlEncode = (str) => {\n  return Buffer.from(str)\n    .toString('base64')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '');\n};\n\nconst encodedHeader = base64UrlEncode(JSON.stringify(jwtHeader));\nconst encodedClaims = base64UrlEncode(JSON.stringify(jwtClaims));\nconst signatureInput = `${encodedHeader}.${encodedClaims}`;\n\n// Sign with private key using crypto module\nconst sign = crypto.createSign('RSA-SHA256');\nsign.update(signatureInput);\nconst signature = sign.sign(serviceAccount.privateKey, 'base64')\n  .replace(/\\+/g, '-')\n  .replace(/\\//g, '_')\n  .replace(/=/g, '');\n\nconst jwt = `${signatureInput}.${signature}`;\n\n// Step 2: Exchange JWT for access token\nconst tokenResponse = await this.helpers.httpRequest({\n  method: 'POST',\n  url: 'https://oauth2.googleapis.com/token',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded'\n  },\n  body: `grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer&assertion=${jwt}`\n});\n\nconst accessToken = tokenResponse.access_token;\n\n// Step 3: Get PDF binary and convert to base64\nconst item = $input.first();\nconst binaryKey = Object.keys(item.binary)[0];\nconst buffer = await this.helpers.getBinaryDataBuffer(0, binaryKey);\nconst base64Content = buffer.toString('base64');\n\n// Step 4: Prepare Document AI request body\nconst documentAiRequest = {\n  rawDocument: {\n    content: base64Content,\n    mimeType: 'application/pdf'\n  }\n};\n\n// Return access token, request body, and original data\nreturn {\n  json: {\n    ...item.json,\n    accessToken: accessToken,\n    documentAiRequest: documentAiRequest\n  },\n  binary: item.binary\n};"
        },
        "id": "prepare-docai-request-001",
        "name": "Prepare Document AI Request",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          336,
          824
        ],
        "disabled": true
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://eu-documentai.googleapis.com/v1/projects/504943079120/locations/eu/processors/954baa10f2e87364:process",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Authorization",
                "value": "=Bearer {{ $json.accessToken }}"
              },
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify($json.documentAiRequest) }}",
          "options": {}
        },
        "id": "call-docai-ocr-001",
        "name": "Call Document AI OCR",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.3,
        "position": [
          560,
          824
        ],
        "disabled": true,
        "notes": "Google Document AI OCR\n\nProcessor: 954baa10f2e87364\nRegion: eu\nProject: n8n-integrations-482020"
      },
      {
        "parameters": {
          "jsCode": "// Parse Google Document AI response\nconst item = $input.first();\nconst docAiResponse = item.json;\n\nlet extractedText = '';\nlet pageCount = 0;\n\n// Extract text from Document AI response\nif (docAiResponse.document && docAiResponse.document.text) {\n  extractedText = docAiResponse.document.text;\n  pageCount = docAiResponse.document.pages ? docAiResponse.document.pages.length : 0;\n}\n\n// Get original data from upstream node (Download PDF from Drive)\nconst originalData = $('Download PDF from Drive').first().json;\n\nreturn {\n  json: {\n    ...originalData,\n    extractedText: extractedText.trim(),\n    ocrSuccess: extractedText.length > 0,\n    ocrEngine: 'Google Document AI',\n    pageCount: pageCount\n  },\n  binary: item.binary\n};"
        },
        "id": "parse-docai-response-001",
        "name": "Parse Document AI Response",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          784,
          824
        ],
        "disabled": true
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "strict",
              "version": 1
            },
            "conditions": [
              {
                "id": "size-check",
                "leftValue": "={{ $json.isLargeFile }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "check-size-route-001",
        "name": "Check Size Route",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          1904,
          -168
        ]
      },
      {
        "parameters": {
          "url": "=https://www.googleapis.com/drive/v3/files/{{ $json.file_id }}?fields=thumbnailLink",
          "authentication": "predefinedCredentialType",
          "nodeCredentialType": "googleDriveOAuth2Api",
          "options": {}
        },
        "id": "get-thumbnail-001",
        "name": "Get Thumbnail URL",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          2128,
          -240
        ],
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "a4m50EefR3DJoU0R",
            "name": "Google Drive account"
          }
        }
      },
      {
        "parameters": {
          "url": "={{ $json.thumbnailLink.replace('=s220', '=s1600') }}",
          "options": {
            "response": {
              "response": {
                "responseFormat": "file"
              }
            }
          }
        },
        "id": "fetch-thumbnail-001",
        "name": "Fetch Thumbnail Image",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          2352,
          -240
        ]
      },
      {
        "parameters": {
          "jsCode": "// Convert thumbnail to Base64 for Claude\nconst item = $input.first();\nconst prevData = $('Check Size Route').first().json;\n\nconst binaryKey = Object.keys(item.binary)[0];\nconst buffer = await this.helpers.getBinaryDataBuffer(0, binaryKey);\nconst base64Content = buffer.toString('base64');\n\nreturn {\n  json: {\n    ...prevData,\n    usedThumbnail: true,\n    imageData: {\n      type: 'base64',\n      media_type: 'image/png',\n      data: base64Content\n    }\n  }\n};"
        },
        "id": "convert-thumbnail-001",
        "name": "Convert Thumbnail to Base64",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2576,
          -240
        ]
      },
      {
        "parameters": {
          "jsCode": "// Pass through each moved file with enriched metadata\n// This node receives N items (one per file moved to staging)\n// It preserves them as N items for Chunk 2.5 to process each\n\nconst items = $input.all();\n\n// Get shared data from upstream nodes\nconst clientData = $('Batch Voting - Find Common Identifier').first().json;\nconst chunk0Output = $('Execute Chunk 0 - Create Folders (NEW)').first().json;\n\nreturn items.map((item, index) => {\n  // item.json has Google Drive move result: {kind, id, name, mimeType}\n  const driveResult = item.json;\n  \n  return {\n    json: {\n      // Google Drive file info (what Prepare for Chunk 2.5 expects)\n      id: driveResult.id,\n      name: driveResult.name,\n      mimeType: driveResult.mimeType,\n      kind: driveResult.kind,\n      \n      // Client/folder metadata\n      clientName: clientData.clientName,\n      clientNormalized: clientData.clientNormalized,\n      Staging_Folder_ID: chunk0Output.Staging_Folder_ID,\n      Root_Folder_ID: chunk0Output.Root_Folder_ID,\n      \n      // Analysis results for this file\n      analysisResults: clientData.analysisResults,\n      \n      // Track which file this is\n      fileIndex: index,\n      totalFiles: items.length\n    }\n  };\n});"
        },
        "id": "aggregate-staging-files-001",
        "name": "Aggregate Staged Files",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3920,
          392
        ]
      }
    ],
    "connections": {
      "Gmail Trigger - Unread with Attachments": {
        "main": [
          [
            {
              "node": "Extract Email Metadata",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract Email Metadata": {
        "main": [
          [
            {
              "node": "Filter PDF/ZIP Attachments",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Filter PDF/ZIP Attachments": {
        "main": [
          [
            {
              "node": "Split Into Batches - Process Each PDF",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Split Into Batches - Process Each PDF": {
        "main": [
          [
            {
              "node": "Aggregate All PDF Results",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Upload PDF to Temp Folder",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Upload PDF to Temp Folder": {
        "main": [
          [
            {
              "node": "Extract File ID & Metadata",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract File ID & Metadata": {
        "main": [
          [
            {
              "node": "Download PDF from Drive",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Download PDF from Drive": {
        "main": [
          [
            {
              "node": "Convert PDF to Base64",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Claude Tesxt Extration": {
        "main": [
          [
            {
              "node": "Parse Claude Response",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Claude Response": {
        "main": [
          [
            {
              "node": "Wait Between Vision Calls",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Wait Between Vision Calls": {
        "main": [
          [
            {
              "node": "Store Analysis Result",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Store Analysis Result": {
        "main": [
          [
            {
              "node": "Split Into Batches - Process Each PDF",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Aggregate All PDF Results": {
        "main": [
          [
            {
              "node": "Parse Email Body for Mentions",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Email Body for Mentions": {
        "main": [
          [
            {
              "node": "Batch Voting - Find Common Identifier",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Batch Voting - Find Common Identifier": {
        "main": [
          [
            {
              "node": "Lookup Client Registry",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Lookup Client Registry": {
        "main": [
          [
            {
              "node": "Check Client Exists",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check Client Exists": {
        "main": [
          [
            {
              "node": "Check Flag Conditions",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check Flag Conditions": {
        "main": [
          [
            {
              "node": "Should Send Review Email?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Should Send Review Email?": {
        "main": [
          [
            {
              "node": "Prepare Review Email",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Decision Gate",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Review Email": {
        "main": [
          [
            {
              "node": "Send Review Email",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Send Review Email": {
        "main": [
          [
            {
              "node": "Decision Gate",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Decision Gate": {
        "main": [
          [
            {
              "node": "Handle Unidentified Client",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Execute Chunk 0 - Create Folders (NEW)",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Lookup Staging Folder",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Handle Unidentified Client": {
        "main": [
          [
            {
              "node": "Prepare UNKNOWN Client Data",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare UNKNOWN Client Data": {
        "main": [
          [
            {
              "node": "Execute Chunk 0 - Create Folders (UNKNOWN)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Execute Chunk 0 - Create Folders (UNKNOWN)": {
        "main": [
          [
            {
              "node": "Extract 38_Unknowns Folder ID",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract 38_Unknowns Folder ID": {
        "main": [
          [
            {
              "node": "Validate Folder IDs",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Validate Folder IDs": {
        "main": [
          [
            {
              "node": "Move PDF to 38_Unknowns",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Move PDF to 38_Unknowns": {
        "main": [
          [
            {
              "node": "Prepare Email Notification Data",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Email Notification Data": {
        "main": [
          [
            {
              "node": "Build Email HTML Body",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Email HTML Body": {
        "main": [
          [
            {
              "node": "Send Email Notification",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Execute Chunk 0 - Create Folders (NEW)": {
        "main": [
          [
            {
              "node": "Merge Chunk 0 Output (NEW)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Merge Chunk 0 Output (NEW)": {
        "main": [
          [
            {
              "node": "Move PDF to _Staging (NEW)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Move PDF to _Staging (NEW)": {
        "main": [
          [
            {
              "node": "Aggregate Staged Files",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare for Chunk 2.5 (NEW)": {
        "main": [
          [
            {
              "node": "Execute Chunk 2.5 (NEW)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Execute Chunk 2.5 (NEW)": {
        "main": [
          [
            {
              "node": "Mark Email as Read (NEW)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Mark Email as Read (NEW)": {
        "main": [
          [
            {
              "node": "NoOp - NEW Complete",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Lookup Staging Folder": {
        "main": [
          [
            {
              "node": "Filter Staging Folder ID",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Filter Staging Folder ID": {
        "main": [
          [
            {
              "node": "Check Routing Decision",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Move PDF to _Staging (EXISTING)": {
        "main": [
          [
            {
              "node": "Wait After Staging (EXISTING)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Wait After Staging (EXISTING)": {
        "main": [
          [
            {
              "node": "Prepare for Chunk 2.5 (EXISTING)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare for Chunk 2.5 (EXISTING)": {
        "main": [
          [
            {
              "node": "Execute Chunk 2.5 (EXISTING)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Execute Chunk 2.5 (EXISTING)": {
        "main": [
          [
            {
              "node": "Mark Email as Read (EXISTING)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Mark Email as Read (EXISTING)": {
        "main": [
          [
            {
              "node": "NoOp - EXISTING Complete",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Missing Folder Error": {
        "main": [
          [
            {
              "node": "Prepare Registry Error Email Data",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Registry Error Email Data": {
        "main": [
          [
            {
              "node": "Send Registry Error Email",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Send Registry Error Email": {
        "main": [
          [
            {
              "node": "Move to 38_Unknowns (Registry Error)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Move to 38_Unknowns (Registry Error)": {
        "main": [
          [
            {
              "node": "Mark Email as Read (Registry Error)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Mark Email as Read (Registry Error)": {
        "main": [
          [
            {
              "node": "NoOp - Registry Error Complete",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract Text from PDF": {
        "main": [
          [
            {
              "node": "Evaluate Extraction Quality",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Evaluate Extraction Quality": {
        "main": [
          [
            {
              "node": "AI Extract Client Name",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "AI Extract Client Name": {
        "main": [
          [
            {
              "node": "Batch Voting - Find Common Identifier",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Document AI Request": {
        "main": [
          [
            {
              "node": "Call Document AI OCR",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Call Document AI OCR": {
        "main": [
          [
            {
              "node": "Parse Document AI Response",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Document AI Response": {
        "main": [
          [
            {
              "node": "Evaluate Extraction Quality",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Claude API Request": {
        "main": [
          [
            {
              "node": "Claude Tesxt Extration",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Convert PDF to Base64": {
        "main": [
          [
            {
              "node": "Check Size Route",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check Size Route": {
        "1": [
          [
            {
              "node": "Build Claude API Request",
              "type": "1",
              "index": 0
            }
          ]
        ],
        "main": [
          [
            {
              "node": "Get Thumbnail URL",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Build Claude API Request",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Get Thumbnail URL": {
        "main": [
          [
            {
              "node": "Fetch Thumbnail Image",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch Thumbnail Image": {
        "main": [
          [
            {
              "node": "Convert Thumbnail to Base64",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Convert Thumbnail to Base64": {
        "main": [
          [
            {
              "node": "Build Claude API Request",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Aggregate Staged Files": {
        "main": [
          [
            {
              "node": "Prepare for Chunk 2.5 (NEW)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check Routing Decision": {
        "main": [
          [
            {
              "node": "Prepare Missing Folder Error",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Move PDF to _Staging (EXISTING)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "settings": {
      "executionOrder": "v1",
      "saveDataErrorExecution": "all",
      "saveDataSuccessExecution": "all",
      "saveManualExecutions": true,
      "saveExecutionProgress": true,
      "callerPolicy": "workflowsFromSameOwner",
      "availableInMCP": false
    },
    "staticData": {
      "node:Gmail Trigger - Unread with Attachments": {
        "Gmail Trigger - Unread with Attachments": {
          "lastTimeChecked": 1769037355,
          "possibleDuplicates": [
            "19be2d811aff40ca"
          ]
        }
      },
      "global": {
        "analysisResults": []
      }
    },
    "meta": null,
    "pinData": {},
    "versionId": "659937fd-18fe-4ad8-ab36-ce661b1f17bf",
    "activeVersionId": "659937fd-18fe-4ad8-ab36-ce661b1f17bf",
    "versionCounter": 201,
    "triggerCount": 1,
    "shared": [
      {
        "updatedAt": "2026-01-19T21:47:26.231Z",
        "createdAt": "2026-01-19T21:47:26.231Z",
        "role": "workflow:owner",
        "workflowId": "p0X9PrpCShIgxxMP",
        "projectId": "Rs8mhw052fnrzWZM",
        "project": {
          "updatedAt": "2025-12-31T15:54:29.115Z",
          "createdAt": "2025-12-31T15:27:33.865Z",
          "id": "Rs8mhw052fnrzWZM",
          "name": "Sway Clarke <sway@oloxa.ai>",
          "type": "personal",
          "icon": null,
          "description": null,
          "creatorId": "e9bd9112-c2e3-4f67-873a-e1001baeafd8",
          "projectRelations": [
            {
              "updatedAt": "2025-12-31T15:27:33.865Z",
              "createdAt": "2025-12-31T15:27:33.865Z",
              "userId": "e9bd9112-c2e3-4f67-873a-e1001baeafd8",
              "projectId": "Rs8mhw052fnrzWZM",
              "user": {
                "updatedAt": "2026-01-21T23:00:05.159Z",
                "createdAt": "2025-12-31T15:27:33.119Z",
                "id": "e9bd9112-c2e3-4f67-873a-e1001baeafd8",
                "email": "sway@oloxa.ai",
                "firstName": "Sway",
                "lastName": "Clarke",
                "personalizationAnswers": {
                  "version": "v4",
                  "personalization_survey_submitted_at": "2025-12-31T15:54:37.562Z",
                  "personalization_survey_n8n_version": "2.1.4"
                },
                "settings": {
                  "userActivated": true,
                  "easyAIWorkflowOnboarded": true,
                  "firstSuccessfulWorkflowId": "zbxHkXOoD1qaz6OS",
                  "userActivatedAt": 1767398053308,
                  "npsSurvey": {
                    "responded": true,
                    "lastShownAt": 1767684846804
                  }
                },
                "disabled": false,
                "mfaEnabled": false,
                "lastActiveAt": "2026-01-21",
                "isPending": false
              }
            }
          ]
        }
      }
    ],
    "tags": [],
    "activeVersion": {
      "updatedAt": "2026-01-21T23:13:06.224Z",
      "createdAt": "2026-01-21T23:13:01.573Z",
      "versionId": "659937fd-18fe-4ad8-ab36-ce661b1f17bf",
      "workflowId": "p0X9PrpCShIgxxMP",
      "nodes": [
        {
          "parameters": {
            "pollTimes": {
              "item": [
                {
                  "mode": "everyMinute"
                }
              ]
            },
            "simple": false,
            "filters": {
              "labelIds": [
                "INBOX",
                "UNREAD",
                "Label_8011160688574026773"
              ],
              "q": "has:attachment"
            },
            "options": {
              "downloadAttachments": true
            }
          },
          "id": "gmail-trigger-001",
          "name": "Gmail Trigger - Unread with Attachments",
          "type": "n8n-nodes-base.gmailTrigger",
          "typeVersion": 1.3,
          "position": [
            112,
            152
          ],
          "credentials": {
            "gmailOAuth2": {
              "id": "aYzk7sZF8ZVyfOan",
              "name": "Gmail account"
            }
          }
        },
        {
          "parameters": {
            "jsCode": "// Extract Email Metadata for V10 Batch Analysis\n\nconst item = $input.first();\nconst email = item.json;\n\n// Handle different formats of 'from' field\nlet senderEmail = '';\nlet senderName = '';\n\nif (email.from) {\n  if (typeof email.from === 'string') {\n    // String format: \"Name <email@example.com>\"\n    const emailMatch = email.from.match(/<([^>]+)>/) || email.from.match(/([^\\s]+@[^\\s]+)/);\n    senderEmail = emailMatch ? emailMatch[1].toLowerCase().trim() : email.from.toLowerCase().trim();\n    const nameMatch = email.from.match(/^([^<]+)</);\n    senderName = nameMatch ? nameMatch[1].trim() : '';\n  } else if (email.from.value && Array.isArray(email.from.value) && email.from.value[0]) {\n    // Gmail format: { value: [{ address: \"...\", name: \"...\" }] }\n    senderEmail = (email.from.value[0].address || '').toLowerCase().trim();\n    senderName = email.from.value[0].name || '';\n  } else if (typeof email.from === 'object') {\n    // Object format: { email: \"...\", name: \"...\" } or { address: \"...\" }\n    senderEmail = (email.from.email || email.from.address || '').toLowerCase().trim();\n    senderName = email.from.name || '';\n  }\n}\n\n// Fallback: check 'sender' field\nif (!senderEmail && email.sender) {\n  if (typeof email.sender === 'string') {\n    senderEmail = email.sender.toLowerCase().trim();\n  } else if (email.sender.value && email.sender.value[0]) {\n    senderEmail = (email.sender.value[0].address || '').toLowerCase().trim();\n    senderName = email.sender.value[0].name || '';\n  }\n}\n\n// Fallback for sender name\nif (!senderName && senderEmail) {\n  senderName = senderEmail.split('@')[0];\n}\n\nconst subject = email.subject || '';\n\nlet bodyText = email.text || email.snippet || email.body || '';\nbodyText = bodyText.replace(/\\s+/g, ' ').trim();\n\n// Count attachments from binary data\nconst binaryData = item.binary || {};\nconst binaryKeys = Object.keys(binaryData);\nconst attachmentCount = binaryKeys.length;\n\nconst emailId = email.id || email.messageId || '';\nconst receivedAt = email.date || email.internalDate || new Date().toISOString();\n\n// IMPORTANT: Return both json AND binary data\nreturn [{\n  json: {\n    ...email,\n    emailId,\n    senderEmail,\n    senderName,\n    subject,\n    bodyText,\n    receivedAt,\n    attachmentCount,\n    analysisResults: [],\n    emailBodyMentions: []\n  },\n  binary: binaryData\n}];"
          },
          "id": "extract-email-metadata-001",
          "name": "Extract Email Metadata",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            336,
            152
          ]
        },
        {
          "parameters": {
            "jsCode": "// Filter PDF and ZIP attachments only\nconst items = $input.all();\nconst filtered = [];\n\nfor (const item of items) {\n  // Gmail trigger stores attachments in item.binary, not item.json.attachments\n  if (!item.binary) continue;\n  \n  // Iterate over binary keys (attachment_0, attachment_1, etc.)\n  for (const [key, attachment] of Object.entries(item.binary)) {\n    const filename = attachment.fileName;\n    if (!filename) continue;\n    \n    const ext = filename.toLowerCase().split('.').pop();\n    \n    if (['pdf', 'zip'].includes(ext)) {\n      filtered.push({\n        json: {\n          emailId: item.json.id,\n          emailSubject: item.json.Subject || item.json.subject,\n          emailFrom: item.json.From || item.json.from,\n          emailDate: item.json.date,\n          attachmentKey: key,\n          filename: filename,\n          mimeType: attachment.mimeType,\n          size: attachment.fileSize\n        },\n        binary: {\n          data: attachment\n        }\n      });\n    }\n  }\n}\n\nreturn filtered;"
          },
          "id": "filter-attachments-001",
          "name": "Filter PDF/ZIP Attachments",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            560,
            152
          ]
        },
        {
          "parameters": {
            "options": {}
          },
          "id": "split-batches-001",
          "name": "Split Into Batches - Process Each PDF",
          "type": "n8n-nodes-base.splitInBatches",
          "typeVersion": 3,
          "position": [
            784,
            152
          ]
        },
        {
          "parameters": {
            "driveId": {
              "__rl": true,
              "mode": "list",
              "value": "My Drive"
            },
            "folderId": {
              "__rl": true,
              "mode": "list",
              "value": "root",
              "cachedResultName": "/ (Root folder)"
            },
            "options": {}
          },
          "id": "upload-pdf-gdrive-001",
          "name": "Upload PDF to Temp Folder",
          "type": "n8n-nodes-base.googleDrive",
          "typeVersion": 3,
          "position": [
            1008,
            -168
          ],
          "retryOnFail": true,
          "maxTries": 3,
          "waitBetweenTries": 5000,
          "credentials": {
            "googleDriveOAuth2Api": {
              "id": "a4m50EefR3DJoU0R",
              "name": "Google Drive account"
            }
          }
        },
        {
          "parameters": {
            "jsCode": "// Extract Google Drive file ID from upload response and preserve email metadata\nconst uploadResult = $input.first().json;\nconst emailData = $('Filter PDF/ZIP Attachments').first().json;\n\nreturn [{\n  json: {\n    file_id: uploadResult.id,\n    filename: uploadResult.name,\n    emailId: emailData.emailId,\n    emailSubject: emailData.emailSubject,\n    emailFrom: emailData.emailFrom,\n    emailDate: emailData.emailDate\n  }\n}];"
          },
          "id": "extract-file-id-001",
          "name": "Extract File ID & Metadata",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            1232,
            -168
          ]
        },
        {
          "parameters": {
            "operation": "download",
            "fileId": {
              "__rl": true,
              "mode": "id",
              "value": "={{ $json.file_id }}"
            },
            "options": {}
          },
          "id": "download-pdf-from-gdrive-001",
          "name": "Download PDF from Drive",
          "type": "n8n-nodes-base.googleDrive",
          "typeVersion": 3,
          "position": [
            1456,
            -168
          ],
          "retryOnFail": true,
          "maxTries": 3,
          "waitBetweenTries": 5000,
          "credentials": {
            "googleDriveOAuth2Api": {
              "id": "a4m50EefR3DJoU0R",
              "name": "Google Drive account"
            }
          }
        },
        {
          "parameters": {
            "jsCode": "// Convert PDF to Base64 - V10 Sprint 6\n// For large files (>5MB), flag for thumbnail route\n\nconst item = $input.first();\nconst binaryKey = Object.keys(item.binary)[0];\nconst buffer = await this.helpers.getBinaryDataBuffer(0, binaryKey);\n\n// Calculate file size\nconst fileSizeBytes = buffer.length;\nconst fileSizeMB = fileSizeBytes / (1024 * 1024);\nconst SIZE_THRESHOLD_MB = 5;\n\nconsole.log(`File size: ${fileSizeMB.toFixed(2)} MB, Threshold: ${SIZE_THRESHOLD_MB} MB`);\n\nif (fileSizeMB > SIZE_THRESHOLD_MB) {\n  // Large file - flag it for thumbnail route\n  // HTTP Request nodes will fetch the thumbnail\n  console.log('Large file detected - routing to thumbnail fetch');\n  return {\n    json: {\n      ...item.json,\n      fileSizeMB: fileSizeMB,\n      isLargeFile: true\n    },\n    binary: item.binary\n  };\n}\n\n// Normal path: Convert full PDF to Base64\nconst base64Content = buffer.toString('base64');\n\nreturn {\n  json: {\n    ...item.json,\n    fileSizeMB: fileSizeMB,\n    isLargeFile: false,\n    imageData: {\n      type: 'base64',\n      media_type: 'application/pdf',\n      data: base64Content\n    }\n  },\n  binary: item.binary\n};"
          },
          "id": "convert-pdf-base64-001",
          "name": "Convert PDF to Base64",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            1680,
            -168
          ]
        },
        {
          "parameters": {
            "jsCode": "// Build Claude API Request - V10 Sprint 7\n// Handles both PDF documents and image thumbnails\n// UPDATED: Stricter prompt to prevent description outputs\n\nconst item = $input.first();\n\nconst prompt = `# Role\nYou are extracting property identifiers from German real estate documents.\n\n# Task\nExtract the PRIMARY identifier from this document.\n\n# Output Format\nRespond with ONLY the name. No explanations. No descriptions. No sentences.\n\nGOOD outputs:\n- Villa Martens\n- Schlossbergstrasse 13\n- Projekt Sonnenberg\n- Mueller Immobilien GmbH\n- UNKNOWN\n\nBAD outputs (NEVER do this):\n- \"The primary identifier is Villa Martens\"\n- \"The document shows a property called...\"\n- \"Based on the header, the name is...\"\n- Any sentence or explanation\n\n# Priority\n1. Property/Project name (header, title, watermark)\n2. Client/Company name if no property name\n3. Street address as fallback\n4. UNKNOWN if nothing found\n\n# Rules\n- Output ONLY the name itself (2-5 words max)\n- Normalize German: √ü‚Üíss, √§‚Üíae, √∂‚Üíoe, √º‚Üíue\n- If confidence <70%, output: UNKNOWN\n- NEVER explain your answer\n- NEVER start with \"The...\"`;\n\nconst mediaType = item.json.imageData.media_type;\nconst isImage = mediaType.startsWith('image/');\n\n// Build content array based on whether it's a PDF or image\nlet contentArray;\n\nif (isImage) {\n  // Image content (thumbnail)\n  contentArray = [\n    {\n      type: \"image\",\n      source: {\n        type: \"base64\",\n        media_type: mediaType,\n        data: item.json.imageData.data\n      }\n    },\n    {\n      type: \"text\",\n      text: prompt\n    }\n  ];\n  console.log('Using IMAGE format (thumbnail) for Claude Vision');\n} else {\n  // PDF document\n  contentArray = [\n    {\n      type: \"document\",\n      source: {\n        type: \"base64\",\n        media_type: mediaType,\n        data: item.json.imageData.data\n      }\n    },\n    {\n      type: \"text\",\n      text: prompt\n    }\n  ];\n  console.log('Using DOCUMENT format (PDF) for Claude Vision');\n}\n\nconst apiBody = {\n  model: \"claude-sonnet-4-20250514\",\n  max_tokens: 30,  // Reduced to force shorter output\n  messages: [\n    {\n      role: \"user\",\n      content: contentArray\n    }\n  ]\n};\n\nreturn {\n  json: {\n    file_id: item.json.file_id,\n    filename: item.json.filename,\n    emailId: item.json.emailId,\n    emailSubject: item.json.emailSubject,\n    emailFrom: item.json.emailFrom,\n    emailDate: item.json.emailDate,\n    fileSizeMB: item.json.fileSizeMB,\n    isLargeFile: item.json.isLargeFile,\n    usedThumbnail: item.json.usedThumbnail,\n    claudeApiBody: apiBody\n  }\n};"
          },
          "id": "build-claude-request-001",
          "name": "Build Claude API Request",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            2800,
            -168
          ]
        },
        {
          "parameters": {
            "method": "POST",
            "url": "https://api.anthropic.com/v1/messages",
            "authentication": "genericCredentialType",
            "genericAuthType": "httpHeaderAuth",
            "sendHeaders": true,
            "headerParameters": {
              "parameters": [
                {
                  "name": "anthropic-version",
                  "value": "2023-06-01"
                }
              ]
            },
            "sendBody": true,
            "specifyBody": "json",
            "jsonBody": "={{ $json.claudeApiBody }}",
            "options": {}
          },
          "id": "7b5637a2-9b8e-4651-83a9-b2e5838c1f3a",
          "name": "Claude Tesxt Extration",
          "type": "n8n-nodes-base.httpRequest",
          "typeVersion": 4.3,
          "position": [
            3024,
            -168
          ],
          "credentials": {
            "httpHeaderAuth": {
              "id": "vfoYopBRX35Znmq6",
              "name": "Anthropic API key"
            }
          }
        },
        {
          "parameters": {
            "jsCode": "const item = $input.first();\nconst response = item.json;\n\n// Get Claude's response text\nlet rawResponse = response.content[0].text.trim();\n\n// Extract just the identifier from verbose responses\nlet identifier = rawResponse;\n\n// Pattern 1: Look for \"‚Üí identifier\" format (Claude's normalization output)\nconst arrowMatch = rawResponse.match(/‚Üí\\s*([^\\n*]+)/);\nif (arrowMatch) {\n  identifier = arrowMatch[1].trim();\n}\n// Pattern 2: Look for quoted identifier\nelse if (rawResponse.includes('\"')) {\n  const quoteMatch = rawResponse.match(/\"([^\"]+)\"/);\n  if (quoteMatch) {\n    identifier = quoteMatch[1].trim();\n  }\n}\n// Pattern 3: If response has multiple lines, take the last non-empty line\nelse if (rawResponse.includes('\\n')) {\n  const lines = rawResponse.split('\\n').filter(line => line.trim().length > 0);\n  identifier = lines[lines.length - 1].trim();\n  \n  // Remove common prefixes\n  identifier = identifier.replace(/^[-*‚Ä¢]\\s*/, ''); // Remove bullet points\n  identifier = identifier.replace(/^\\d+\\.\\s*/, ''); // Remove numbering\n  identifier = identifier.replace(/^[*_]+$/, ''); // Remove markdown formatting\n}\n\n// Clean up any remaining markdown or formatting\nidentifier = identifier.replace(/\\*\\*/g, ''); // Remove bold\nidentifier = identifier.replace(/\\*/g, ''); // Remove italics\nidentifier = identifier.replace(/^[:\\-]\\s*/, ''); // Remove leading colons/dashes\n\n// Final validation\nif (!identifier || identifier.length < 2 || identifier.length > 100) {\n  identifier = 'UNKNOWN';\n}\n\n// Get original data from upstream (Download PDF node)\nconst originalData = $('Download PDF from Drive').first().json;\n\nreturn {\n  json: {\n    ...originalData,\n    identifier: identifier,           // KEY FIX: Add identifier field for Store Analysis Result\n    client_name_raw: identifier,       // Keep for debugging/legacy\n    extractionMethod: 'claude_vision',\n    extractionModel: 'claude-sonnet-4-20250514',\n    rawClaudeResponse: rawResponse.substring(0, 500) // Keep first 500 chars for debugging\n  }\n};\n"
          },
          "id": "parse-claude-response-001",
          "name": "Parse Claude Response",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3248,
            -168
          ]
        },
        {
          "parameters": {
            "amount": 20
          },
          "id": "wait-between-vision-001",
          "name": "Wait Between Vision Calls",
          "type": "n8n-nodes-base.wait",
          "typeVersion": 1.1,
          "position": [
            3472,
            -168
          ],
          "webhookId": "eb97b8b7-9acd-49b9-8001-e2762aa4b5e3"
        },
        {
          "parameters": {
            "jsCode": "// Store Analysis Result - Accumulate PDF analysis results for batch voting\n// Uses GLOBAL static data so Aggregate node can read it\n\nconst currentItem = $input.first().json;\nconst context = $('Extract Email Metadata').first().json;\n\n// Use GLOBAL workflow static data (shared across all nodes)\nconst staticData = $getWorkflowStaticData('global');\n\n// Initialize or get the results array\nif (!staticData.analysisResults) {\n  staticData.analysisResults = [];\n}\n\n// Create result object for this PDF\nconst result = {\n  fileId: currentItem.file_id || currentItem.fileId,\n  fileName: currentItem.filename || currentItem.fileName,\n  identifier: currentItem.identifier || currentItem.clientName || currentItem.client_name_raw || 'UNKNOWN',\n  identifierType: currentItem.identifierType || 'unknown',\n  confidence: currentItem.confidence || (currentItem.identifier && currentItem.identifier !== 'UNKNOWN' ? 0.8 : 0),\n  alternates: currentItem.alternates || [],\n  source: 'pdf_vision',\n  extractionMethod: currentItem.extractionMethod || 'unknown'\n};\n\n// Append to global static data results array\nstaticData.analysisResults.push(result);\n\nconsole.log('Stored result #' + staticData.analysisResults.length + ': ' + result.identifier);\n\nreturn [{\n  json: {\n    ...currentItem,\n    analysisResults: staticData.analysisResults,\n    currentPdfIndex: staticData.analysisResults.length,\n    totalPdfs: context.attachmentCount\n  }\n}];"
          },
          "id": "store-analysis-result-001",
          "name": "Store Analysis Result",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3696,
            -176
          ]
        },
        {
          "parameters": {
            "jsCode": "// Aggregate All PDF Results - Combine all analysis results for batch voting\n// Reads from GLOBAL static data and clears it for next execution\n\nconst context = $('Extract Email Metadata').first().json;\n\n// Get GLOBAL static data (shared with Store Analysis Result)\nconst staticData = $getWorkflowStaticData('global');\n\n// Read accumulated results\nconst analysisResults = staticData.analysisResults || [];\n\n// IMPORTANT: Clear the static data for next email execution\nstaticData.analysisResults = [];\n\n// Calculate summary stats\nconst totalPdfs = analysisResults.length;\nconst avgConfidence = totalPdfs > 0 \n  ? analysisResults.reduce((sum, r) => sum + (r.confidence || 0), 0) / totalPdfs \n  : 0;\n\n// Find all unique identifiers with their counts\nconst identifierCounts = {};\nanalysisResults.forEach(r => {\n  const id = (r.identifier || '').toLowerCase();\n  if (id && id !== 'unknown') {\n    identifierCounts[id] = (identifierCounts[id] || 0) + 1;\n  }\n});\n\nconsole.log('Aggregated ' + totalPdfs + ' PDF results');\nconsole.log('Identifiers found:', Object.keys(identifierCounts));\n\nreturn [{\n  json: {\n    // Pass through email metadata\n    emailId: context.emailId,\n    senderEmail: context.senderEmail,\n    senderName: context.senderName,\n    subject: context.subject,\n    bodyText: context.bodyText,\n    attachmentCount: context.attachmentCount,\n    \n    // Analysis results\n    analysisResults,\n    totalPdfsAnalyzed: totalPdfs,\n    averageConfidence: avgConfidence,\n    identifierCounts,\n    \n    // Ready for batch voting\n    readyForVoting: true\n  }\n}];"
          },
          "id": "aggregate-results-001",
          "name": "Aggregate All PDF Results",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            1008,
            296
          ]
        },
        {
          "parameters": {
            "jsCode": "// Parse Email Body for Mentions\n// Extract potential project/client names from email body and signature\n\nconst input = $input.first().json;\nconst bodyText = input.bodyText || '';\nconst subject = input.subject || '';\n\n// Combine subject and body for searching\nconst searchText = `${subject}\\n${bodyText}`.toLowerCase();\n\nconst mentions = [];\n\n// Pattern 1: \"Projekt [Name]\" or \"Project [Name]\"\nconst projektMatches = searchText.match(/(?:projekt|project)\\s*[:\\-]?\\s*([a-z√§√∂√º√ü][a-z√§√∂√º√ü0-9\\s\\-_.]+)/gi) || [];\nprojektMatches.forEach(match => {\n  const name = match.replace(/(?:projekt|project)\\s*[:\\-]?\\s*/i, '').trim();\n  if (name.length > 2 && name.length < 50) {\n    mentions.push({ value: name, source: 'projekt_pattern', confidence: 0.8 });\n  }\n});\n\n// Pattern 2: \"Villa [Name]\" or property names\nconst villaMatches = searchText.match(/(?:villa|haus|objekt)\\s+([a-z√§√∂√º√ü][a-z√§√∂√º√ü0-9\\s\\-]+)/gi) || [];\nvillaMatches.forEach(match => {\n  const name = match.trim();\n  if (name.length > 4 && name.length < 50) {\n    mentions.push({ value: name, source: 'property_pattern', confidence: 0.7 });\n  }\n});\n\n// Pattern 3: German street addresses (potential project identifiers)\nconst streetMatches = searchText.match(/([a-z√§√∂√º√ü][a-z√§√∂√º√ü\\-]+(?:stra√üe|strasse|weg|allee|platz|ring))\\s*\\d*/gi) || [];\nstreetMatches.forEach(match => {\n  const name = match.trim();\n  if (name.length > 5 && name.length < 50) {\n    mentions.push({ value: name, source: 'street_pattern', confidence: 0.6 });\n  }\n});\n\n// Pattern 4: \"Betreff:\" or \"Re:\" followed by potential project name\nconst betreffMatches = searchText.match(/(?:betreff|betrifft|re|subject)\\s*[:\\-]?\\s*([a-z√§√∂√º√ü][a-z√§√∂√º√ü0-9\\s\\-_.]+)/gi) || [];\nbetreffMatches.forEach(match => {\n  const name = match.replace(/(?:betreff|betrifft|re|subject)\\s*[:\\-]?\\s*/i, '').trim();\n  // Filter out generic subjects\n  if (name.length > 3 && name.length < 50 && !/^(invoice|rechnung|dokument|document|fwd|fw|aw)/i.test(name)) {\n    mentions.push({ value: name, source: 'betreff_pattern', confidence: 0.5 });\n  }\n});\n\n// Pattern 5: Company names in signature (GmbH, AG, etc.)\nconst companyMatches = searchText.match(/([a-z√§√∂√º√ü][a-z√§√∂√º√ü0-9\\s\\-&.]+)\\s*(?:gmbh|ag|kg|e\\.v\\.|mbh|co\\.)/gi) || [];\ncompanyMatches.forEach(match => {\n  const name = match.trim();\n  // Skip if it's likely the sender's own company (in signature at end)\n  if (name.length > 3 && name.length < 60) {\n    mentions.push({ value: name, source: 'company_pattern', confidence: 0.4 });\n  }\n});\n\n// Pattern 6: Check if any known identifiers from PDF analysis appear in email\nconst knownIdentifiers = (input.analysisResults || [])\n  .map(r => r.identifier)\n  .filter(id => id && id.toLowerCase() !== 'unknown');\n\nknownIdentifiers.forEach(identifier => {\n  const normalizedId = identifier.toLowerCase();\n  if (searchText.includes(normalizedId)) {\n    mentions.push({ value: identifier, source: 'pdf_match_in_email', confidence: 0.9 });\n  }\n});\n\n// Deduplicate mentions by normalized value\nconst seen = new Set();\nconst uniqueMentions = mentions.filter(m => {\n  const normalized = m.value.toLowerCase().replace(/[^a-z0-9]/g, '');\n  if (seen.has(normalized)) return false;\n  seen.add(normalized);\n  return true;\n});\n\n// Sort by confidence descending\nuniqueMentions.sort((a, b) => b.confidence - a.confidence);\n\n// Extract just the values for the voting node\nconst emailBodyMentions = uniqueMentions.map(m => m.value);\n\nreturn [{\n  json: {\n    ...input,\n    emailBodyMentions,\n    emailBodyMentionDetails: uniqueMentions.slice(0, 10), // Top 10 with details\n    emailBodyParsed: true\n  }\n}];"
          },
          "id": "parse-email-body-001",
          "name": "Parse Email Body for Mentions",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            1232,
            296
          ]
        },
        {
          "parameters": {
            "jsCode": "// Batch Voting - Find Common Identifier - V10 Sprint 7.1\n// UPDATED: Added filename analysis for additional voting + validation\n\nconst input = $input.first().json;\nconst analysisResults = input.analysisResults || [];\nconst senderEmail = input.senderEmail || '';\nconst emailBodyMentions = input.emailBodyMentions || [];\n\n// ========== STEP 0: Filter out bad responses ==========\nconst isValidIdentifier = (identifier) => {\n  if (!identifier || typeof identifier !== 'string') return false;\n  const id = identifier.trim();\n  \n  if (id === '' || id.toLowerCase() === 'unknown') return false;\n  \n  const badPatterns = [\n    /^the\\s+(primary|main|document|identifier|property|name)/i,\n    /^based\\s+on/i,\n    /^this\\s+(document|appears|shows|is)/i,\n    /^i\\s+(can|cannot|couldn't|could not)/i,\n    /identifier\\s+is/i,\n    /appears\\s+to\\s+be/i,\n    /^according\\s+to/i,\n    /^from\\s+the/i\n  ];\n  \n  for (const pattern of badPatterns) {\n    if (pattern.test(id)) return false;\n  }\n  \n  if (id.split(/\\s+/).length > 7) return false;\n  \n  return true;\n};\n\n// ========== STEP 0.5: Extract identifier from filename ==========\nconst extractFromFilename = (filename) => {\n  if (!filename) return null;\n  \n  // Remove extension\n  let name = filename.replace(/\\.[^.]+$/, '');\n  \n  // Remove common patterns: dates (YYMMDD, YYYYMMDD), version numbers, parenthetical numbers\n  name = name\n    .replace(/^\\d{6,8}_?/, '')           // Leading date like 250814_ or 20250814_\n    .replace(/_?\\d{6,8}$/, '')           // Trailing date\n    .replace(/[_\\s]?\\(\\d+\\)$/g, '')      // Trailing (1), (11), etc.\n    .replace(/[_\\s]?v\\d+(\\.\\d+)?$/i, '') // Version numbers v1, v1.0\n    .replace(/_?(Entwurf|Draft|Final|Copy)_?/gi, '') // Common suffixes\n    .replace(/_+/g, ' ')                  // Underscores to spaces\n    .replace(/\\s+/g, ' ')                 // Multiple spaces to single\n    .trim();\n  \n  // Skip if too short or just numbers\n  if (name.length < 3 || /^\\d+$/.test(name)) return null;\n  \n  // Skip common non-identifier words\n  const skipWords = ['kalkulation', 'uebersicht', '√ºbersicht', 'verkaufsbaubeschreibung', \n                     'finanzierung', 'finanzierungen', 'banken', 'dokument', 'document'];\n  const nameLower = name.toLowerCase();\n  \n  // Extract the likely identifier part (first meaningful segment)\n  const words = name.split(/\\s+/);\n  const meaningfulWords = words.filter(w => \n    w.length >= 3 && \n    !skipWords.includes(w.toLowerCase()) &&\n    !/^\\d+$/.test(w)\n  );\n  \n  if (meaningfulWords.length === 0) return null;\n  \n  // Return the meaningful part\n  return meaningfulWords.slice(0, 3).join(' '); // Max 3 words\n};\n\n// ========== STEP 1: Extract root words for fuzzy matching ==========\nconst extractRoots = (identifier) => {\n  const normalized = identifier\n    .toLowerCase()\n    .replace(/√§/g, 'ae').replace(/√∂/g, 'oe').replace(/√º/g, 'ue').replace(/√ü/g, 'ss')\n    .replace(/[^a-z0-9\\s]/g, '')\n    .trim();\n  \n  const cleaned = normalized\n    .replace(/^(projekt|project|villa|residenz|haus|immobilie|objekt)\\s+/i, '')\n    .replace(/\\s+(gmbh|ag|kg|mbh|str|strasse|weg|platz|allee)$/i, '')\n    .replace(/\\s+\\d+$/, '');\n  \n  const words = cleaned.split(/\\s+/).filter(w => w.length >= 3);\n  \n  return {\n    full: normalized,\n    core: cleaned,\n    words: words,\n    primary: words[0] || normalized\n  };\n};\n\n// ========== STEP 2: Collect valid identifiers from Claude ==========\nconst validResults = [];\nanalysisResults.forEach((result, index) => {\n  if (isValidIdentifier(result.identifier)) {\n    validResults.push({\n      ...result,\n      sourceIndex: index,\n      sourceType: 'claude_vision',\n      roots: extractRoots(result.identifier),\n      weight: 1.0  // Full weight for Claude extractions\n    });\n  } else {\n    console.log(`Filtered out invalid Claude response from PDF ${index + 1}: \"${result.identifier}\"`);\n  }\n});\n\n// ========== STEP 2.5: Add filename identifiers ==========\nconst filenameIdentifiers = [];\nanalysisResults.forEach((result, index) => {\n  const filenameId = extractFromFilename(result.fileName);\n  if (filenameId && isValidIdentifier(filenameId)) {\n    filenameIdentifiers.push({\n      identifier: filenameId,\n      fileName: result.fileName,\n      sourceIndex: index,\n      sourceType: 'filename',\n      roots: extractRoots(filenameId),\n      weight: 0.5,  // Half weight for filename extractions\n      confidence: 0.7  // Assumed confidence for filenames\n    });\n    console.log(`Extracted from filename ${index + 1}: \"${filenameId}\"`);\n  }\n});\n\nconsole.log(`Valid Claude extractions: ${validResults.length}, Filename extractions: ${filenameIdentifiers.length}`);\n\n// Combine all sources\nconst allSources = [...validResults, ...filenameIdentifiers];\n\n// ========== STEP 3: Group by similarity ==========\nconst groups = [];\n\nconst findSimilarity = (roots1, roots2) => {\n  if (roots1.primary === roots2.primary) return 1.0;\n  if (roots1.core.includes(roots2.core) || roots2.core.includes(roots1.core)) return 0.9;\n  \n  const commonWords = roots1.words.filter(w => roots2.words.includes(w));\n  if (commonWords.length > 0) {\n    return 0.7 + (0.2 * commonWords.length / Math.max(roots1.words.length, roots2.words.length));\n  }\n  \n  if (roots1.primary.length >= 4 && roots2.primary.length >= 4) {\n    if (roots1.primary.includes(roots2.primary) || roots2.primary.includes(roots1.primary)) return 0.6;\n  }\n  \n  return 0;\n};\n\nallSources.forEach(result => {\n  let bestGroup = null;\n  let bestSimilarity = 0;\n  \n  for (const group of groups) {\n    const similarity = findSimilarity(result.roots, group.representative.roots);\n    if (similarity > 0.5 && similarity > bestSimilarity) {\n      bestSimilarity = similarity;\n      bestGroup = group;\n    }\n  }\n  \n  if (bestGroup) {\n    bestGroup.members.push(result);\n    bestGroup.totalWeight += result.weight;\n    bestGroup.totalConfidence += (result.confidence || 0.8) * result.weight;\n    bestGroup.hasFilenameMatch = bestGroup.hasFilenameMatch || result.sourceType === 'filename';\n    bestGroup.hasClaudeMatch = bestGroup.hasClaudeMatch || result.sourceType === 'claude_vision';\n    \n    // Prefer Claude extraction as representative, but keep shortest\n    if (result.sourceType === 'claude_vision' && \n        (bestGroup.representative.sourceType !== 'claude_vision' ||\n         result.identifier.length < bestGroup.representative.identifier.length)) {\n      bestGroup.representative = result;\n    }\n  } else {\n    groups.push({\n      representative: result,\n      members: [result],\n      totalWeight: result.weight,\n      totalConfidence: (result.confidence || 0.8) * result.weight,\n      hasFilenameMatch: result.sourceType === 'filename',\n      hasClaudeMatch: result.sourceType === 'claude_vision'\n    });\n  }\n});\n\nconsole.log(`Grouped into ${groups.length} distinct identifiers`);\n\n// ========== STEP 4: Score groups ==========\nconst scoredGroups = groups.map(group => {\n  const votes = group.totalWeight;\n  const avgConfidence = group.totalConfidence / votes;\n  const claudeCount = group.members.filter(m => m.sourceType === 'claude_vision').length;\n  const filenameCount = group.members.filter(m => m.sourceType === 'filename').length;\n  \n  // Bonus if both Claude AND filename agree\n  const crossValidationBonus = (group.hasClaudeMatch && group.hasFilenameMatch) ? 0.15 : 0;\n  \n  return {\n    name: group.representative.identifier,\n    normalized: group.representative.roots.full,\n    votes: votes,\n    claudeVotes: claudeCount,\n    filenameVotes: filenameCount,\n    avgConfidence: avgConfidence,\n    crossValidated: group.hasClaudeMatch && group.hasFilenameMatch,\n    sources: group.members.map(m => \n      m.sourceType === 'filename' ? `file_${m.sourceIndex + 1}` : `pdf_${m.sourceIndex + 1}`\n    ),\n    finalScore: (votes * avgConfidence * (1 + crossValidationBonus))\n  };\n}).sort((a, b) => b.finalScore - a.finalScore);\n\n// ========== STEP 5: Determine winner ==========\nconst winner = scoredGroups[0] || null;\nconst runnerUp = scoredGroups[1] || null;\n\nlet overallConfidence = 0;\nlet votingMethod = 'no_valid_candidates';\n\nif (winner && allSources.length > 0) {\n  const voteShare = winner.votes / allSources.reduce((sum, s) => sum + s.weight, 0);\n  const marginOverRunnerUp = runnerUp ? (winner.votes - runnerUp.votes) / winner.votes : 1;\n  const crossValidationBoost = winner.crossValidated ? 0.1 : 0;\n  \n  overallConfidence = Math.min(1.0, (\n    winner.avgConfidence * 0.35 +\n    voteShare * 0.35 +\n    marginOverRunnerUp * 0.2 +\n    crossValidationBoost\n  ));\n  \n  votingMethod = scoredGroups.length === 1 ? 'unanimous' : \n                 winner.votes > allSources.length / 2 ? 'majority' : 'plurality';\n  \n  if (winner.crossValidated) votingMethod += '_cross_validated';\n}\n\n// ========== STEP 6: Normalize winner ==========\nconst normalizeString = (str) => {\n  return str\n    .toLowerCase()\n    .trim()\n    .replace(/√§/g, 'ae').replace(/√∂/g, 'oe').replace(/√º/g, 'ue').replace(/√ü/g, 'ss')\n    .replace(/\\s*(gmbh|ag|kg|e\\.v\\.|mbh|co\\.|&\\s*co\\.?)\\s*/gi, '')\n    .replace(/[^a-z0-9]/g, '_')\n    .replace(/_+/g, '_')\n    .replace(/^_|_$/g, '');\n};\n\nconst projectName = winner ? winner.name : 'UNKNOWN';\nconst projectNameNormalized = winner ? normalizeString(winner.name) : 'unknown';\n\nconsole.log(`Winner: \"${projectName}\" with ${winner?.votes?.toFixed(1) || 0} weighted votes`);\nconsole.log(`  - Claude votes: ${winner?.claudeVotes || 0}, Filename votes: ${winner?.filenameVotes || 0}`);\nconsole.log(`  - Cross-validated: ${winner?.crossValidated || false}`);\nconsole.log(`  - Overall confidence: ${(overallConfidence * 100).toFixed(0)}%`);\n\n// ========== STEP 7: Build output ==========\nreturn [{\n  json: {\n    // Winning identifier\n    clientName: projectName,\n    clientNormalized: projectNameNormalized,\n    projectName: projectName,\n    projectNameNormalized: projectNameNormalized,\n    \n    // Confidence metrics\n    overallConfidence: Math.round(overallConfidence * 100) / 100,\n    votingMethod,\n    winnerVotes: winner ? Math.round(winner.votes * 10) / 10 : 0,\n    winnerClaudeVotes: winner ? winner.claudeVotes : 0,\n    winnerFilenameVotes: winner ? winner.filenameVotes : 0,\n    crossValidated: winner ? winner.crossValidated : false,\n    winnerSources: winner ? winner.sources : [],\n    validClaudeCount: validResults.length,\n    filenameCount: filenameIdentifiers.length,\n    filteredOutCount: analysisResults.length - validResults.length,\n    \n    // Runner-up for comparison\n    runnerUpName: runnerUp ? runnerUp.name : null,\n    runnerUpScore: runnerUp ? Math.round(runnerUp.finalScore * 100) / 100 : 0,\n    \n    // All groups for debugging\n    allCandidates: scoredGroups.slice(0, 5),\n    \n    // Pass through email metadata\n    senderEmail: input.senderEmail,\n    senderName: input.senderName,\n    subject: input.subject,\n    emailId: input.emailId,\n    attachmentCount: input.attachmentCount,\n    \n    // Pass through for downstream\n    analysisResults,\n    totalPdfsAnalyzed: input.totalPdfsAnalyzed,\n    \n    // File info\n    fileId: analysisResults[0]?.fileId,\n    fileName: analysisResults[0]?.fileName\n  }\n}];"
          },
          "id": "normalize-name-001",
          "name": "Batch Voting - Find Common Identifier",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            1456,
            296
          ]
        },
        {
          "parameters": {
            "documentId": {
              "__rl": true,
              "mode": "id",
              "value": "1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI"
            },
            "sheetName": {
              "__rl": true,
              "mode": "list",
              "value": 762792134,
              "cachedResultName": "Client_Registry",
              "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI/edit#gid=762792134"
            },
            "options": {}
          },
          "id": "lookup-registry-001",
          "name": "Lookup Client Registry",
          "type": "n8n-nodes-base.googleSheets",
          "typeVersion": 4.7,
          "position": [
            1680,
            296
          ],
          "alwaysOutputData": true,
          "credentials": {
            "googleSheetsOAuth2Api": {
              "id": "H7ewI1sOrDYabelt",
              "name": "Google Sheets account"
            }
          }
        },
        {
          "parameters": {
            "jsCode": "// Check Client Exists - V10 Sprint 6 - FIXED routing logic\n// NEW: If Claude identified a name but not in registry ‚Üí NEW (not UNKNOWN)\n// UNKNOWN: Only when Claude couldn't identify the client at all\n\n// Get the batch voting results directly (not from $input which has Google Sheets rows)\nconst batchVotingData = $('Batch Voting - Find Common Identifier').first().json;\nconst registryData = $('Lookup Client Registry').all();\n\n// Extract values from batch voting output\nconst clientNormalized = batchVotingData.clientNormalized || batchVotingData.projectNameNormalized || '';\nconst senderEmail = batchVotingData.senderEmail || '';\nconst overallConfidence = batchVotingData.overallConfidence || 0;\nconst clientName = batchVotingData.clientName || batchVotingData.projectName || '';\n\nconsole.log('Checking client: ' + clientName + ' (normalized: ' + clientNormalized + ')');\nconsole.log('Confidence: ' + overallConfidence);\nconsole.log('Registry has ' + registryData.length + ' entries');\n\n// Check if client was found by project name (primary lookup)\nlet projectMatch = null;\nlet emailMatch = null;\n\nif (registryData && registryData.length > 0) {\n  // Check each row for matches\n  registryData.forEach(row => {\n    const rowData = row.json;\n    \n    // Skip the generic unknown_client row\n    const rowClientNormalized = (rowData.Client_Normalized || rowData.client_normalized || '')\n      .toLowerCase().trim();\n    if (rowClientNormalized === 'unknown_client') {\n      return; // Skip this row\n    }\n    \n    // Check project name match (primary) - compare normalized versions\n    if (clientNormalized && rowClientNormalized === clientNormalized.toLowerCase()) {\n      projectMatch = rowData;\n      console.log('Found project match: ' + rowData.Client_Name);\n    }\n    \n    // Check sender email match (secondary)\n    const rowSenderEmail = (rowData.sender_email || rowData.Sender_Email || '')\n      .toLowerCase().trim();\n    if (rowSenderEmail && senderEmail && rowSenderEmail === senderEmail.toLowerCase()) {\n      emailMatch = rowData;\n      console.log('Found email match: ' + rowData.Client_Name);\n    }\n  });\n}\n\n// Determine routing based on matches\nlet routingDecision = '';\nlet matchedRow = null;\nlet matchType = 'none';\n\n// Check if Claude successfully identified a client name\nconst hasValidIdentification = clientName && \n                               clientName !== '' && \n                               clientName.toUpperCase() !== 'UNKNOWN' &&\n                               overallConfidence >= 0.5;\n\nconsole.log('Has valid identification: ' + hasValidIdentification + ' (name: ' + clientName + ', confidence: ' + overallConfidence + ')');\n\nif (projectMatch) {\n  // PRIMARY MATCH: Project name found in registry ‚Üí EXISTING\n  routingDecision = 'EXISTING';\n  matchedRow = projectMatch;\n  matchType = 'project_name';\n  \n  // Check if email also matches (full match vs partial)\n  const projectEmail = (projectMatch.sender_email || projectMatch.Sender_Email || '').toLowerCase();\n  if (projectEmail && senderEmail && projectEmail !== senderEmail.toLowerCase()) {\n    matchType = 'project_name_email_mismatch';\n  }\n  console.log('EXISTING client - project name matched in registry');\n  \n} else if (emailMatch) {\n  // SECONDARY MATCH: Sender email found but different project ‚Üí NEW\n  routingDecision = 'NEW';\n  matchedRow = emailMatch;\n  matchType = 'sender_email_only';\n  console.log('NEW client - known sender, new project');\n  \n} else if (hasValidIdentification) {\n  // NEW CLIENT: Claude identified the name but not in registry ‚Üí NEW\n  // This is the key fix - identified clients go to NEW, not UNKNOWN\n  routingDecision = 'NEW';\n  matchedRow = null;\n  matchType = 'new_client_identified';\n  console.log('NEW client - Claude identified \"' + clientName + '\" but not in registry');\n  \n} else {\n  // UNKNOWN: Claude couldn't identify the client at all\n  routingDecision = 'UNKNOWN';\n  matchedRow = null;\n  matchType = 'no_identification';\n  console.log('UNKNOWN - Claude could not identify client (name: \"' + clientName + '\", confidence: ' + overallConfidence + ')');\n}\n\nconsole.log('Final routing decision: ' + routingDecision + ' (' + matchType + ')');\n\nreturn [{\n  json: {\n    // Pass through ALL batch voting data\n    ...batchVotingData,\n    \n    // Routing decision\n    routingDecision,\n    matchType,\n    clientFound: routingDecision === 'EXISTING',\n    isNewClient: routingDecision === 'NEW',\n    \n    // Match details\n    matchedRow,\n    projectNameMatched: !!projectMatch,\n    senderEmailMatched: !!emailMatch,\n    \n    // Registry data for downstream (only if EXISTING)\n    folderId: matchedRow?.Root_Folder_ID || matchedRow?.folder_id || null,\n    stagingFolderId: matchedRow?.Staging_Folder_ID || matchedRow?.staging_folder_id || null,\n    registryClientName: matchedRow?.Client_Name || matchedRow?.client_name || null,\n    \n    // Ensure these are passed through correctly\n    overallConfidence,\n    senderEmail,\n    projectNameNormalized: clientNormalized,\n    clientName: clientName || 'UNKNOWN'\n  }\n}];"
          },
          "id": "check-exists-001",
          "name": "Check Client Exists",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            1904,
            296
          ]
        },
        {
          "parameters": {
            "jsCode": "// Check Flag Conditions - V10 Flagging System\nconst input = $input.first().json;\n\nconst overallConfidence = input.overallConfidence || 0;\nconst attachmentCount = input.attachmentCount || 0;\nconst routingDecision = input.routingDecision || 'UNKNOWN';\nconst matchType = input.matchType || 'no_match';\nconst senderEmail = input.senderEmail || '';\nconst projectName = input.projectName || input.clientName || 'UNKNOWN';\n\n// Flagging conditions\nconst isSingleDoc = attachmentCount === 1;\nconst isNewSender = routingDecision === 'UNKNOWN' || routingDecision === 'NEW_FROM_KNOWN';\nconst isLowConfidence = overallConfidence < 0.6;\nconst isMediumConfidence = overallConfidence >= 0.6 && overallConfidence < 0.8;\nconst isHighConfidence = overallConfidence >= 0.8;\nconst isEmailMismatch = matchType === 'project_name_email_mismatch';\n\n// Determine flag status\nlet needsReview = false;\nlet flagPriority = 'NONE';\nlet flagReasons = [];\nlet sendReviewEmail = false;\n\n// HIGH priority flags (send email)\nif (isSingleDoc && isNewSender) {\n  needsReview = true;\n  flagPriority = 'HIGH';\n  flagReasons.push('single_doc_new_sender');\n  sendReviewEmail = true;\n}\n\nif (isLowConfidence) {\n  needsReview = true;\n  flagPriority = 'HIGH';\n  flagReasons.push('low_confidence');\n  sendReviewEmail = true;\n}\n\n// MEDIUM priority flags (log only)\nif (isMediumConfidence && !flagReasons.includes('low_confidence')) {\n  needsReview = true;\n  if (flagPriority !== 'HIGH') flagPriority = 'MEDIUM';\n  flagReasons.push('medium_confidence');\n}\n\n// LOW priority flags (log only)\nif (isEmailMismatch) {\n  needsReview = true;\n  if (flagPriority === 'NONE') flagPriority = 'LOW';\n  flagReasons.push('project_email_mismatch');\n}\n\n// Build review summary\nconst reviewSummary = {\n  projectName,\n  senderEmail,\n  confidence: Math.round(overallConfidence * 100),\n  attachmentCount,\n  routingDecision,\n  matchType,\n  flagReasons: flagReasons.join(', '),\n  timestamp: new Date().toISOString()\n};\n\nreturn [{\n  json: {\n    ...input,\n    \n    // Flagging results\n    needsReview,\n    flagPriority,\n    flagReasons,\n    sendReviewEmail,\n    reviewSummary,\n    \n    // For downstream routing\n    proceedWithProcessing: true\n  }\n}];"
          },
          "id": "check-flag-conditions-001",
          "name": "Check Flag Conditions",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            2128,
            296
          ]
        },
        {
          "parameters": {
            "conditions": {
              "combinator": "and",
              "conditions": [
                {
                  "id": "condition-0",
                  "leftValue": "={{ $json.sendReviewEmail }}",
                  "rightValue": true,
                  "operator": {
                    "type": "boolean",
                    "operation": "equals",
                    "singleValue": true
                  }
                }
              ],
              "options": {
                "version": 2,
                "caseSensitive": true,
                "typeValidation": "loose"
              }
            },
            "options": {
              "looseTypeValidation": true
            }
          },
          "id": "if-send-review-001",
          "name": "Should Send Review Email?",
          "type": "n8n-nodes-base.if",
          "typeVersion": 2,
          "position": [
            2352,
            296
          ]
        },
        {
          "parameters": {
            "jsCode": "// Prepare Review Email Data\nconst input = $input.first().json;\n\nconst summary = input.reviewSummary || {};\n\nconst emailSubject = `[Review Needed] New document: ${summary.projectName || 'Unknown'}`;\n\nconst emailBody = `\nA new document has been processed that may need your review.\n\nüìã DOCUMENT DETAILS\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nProject: ${summary.projectName || 'Unknown'}\nSender: ${summary.senderEmail || 'Unknown'}\nConfidence: ${summary.confidence || 0}%\nDocuments: ${summary.attachmentCount || 0}\nRouting: ${summary.routingDecision || 'Unknown'}\n\n‚ö†Ô∏è REVIEW REASONS\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n${(input.flagReasons || []).map(r => `‚Ä¢ ${r.replace(/_/g, ' ')}`).join('\\n')}\n\nüìå ACTION REQUIRED\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nPlease verify the classification is correct in the Client Tracker.\nIf incorrect, manually update the folder assignment.\n\n---\nAutomated message from Eugene Document Organizer V10\nTimestamp: ${summary.timestamp || new Date().toISOString()}\n`;\n\nreturn [{\n  json: {\n    ...input,\n    reviewEmailSubject: emailSubject,\n    reviewEmailBody: emailBody.trim(),\n    reviewEmailTo: 'sway@oloxa.ai'\n  }\n}];"
          },
          "id": "prepare-review-email-001",
          "name": "Prepare Review Email",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            2576,
            504
          ]
        },
        {
          "parameters": {
            "sendTo": "={{ $json.reviewEmailTo }}",
            "subject": "={{ $json.reviewEmailSubject }}",
            "message": "={{ $json.reviewEmailBody }}",
            "options": {}
          },
          "id": "send-review-email-001",
          "name": "Send Review Email",
          "type": "n8n-nodes-base.gmail",
          "typeVersion": 2.2,
          "position": [
            2800,
            504
          ],
          "webhookId": "bd30b99d-eb9f-4495-bdcf-1fa26483eb99",
          "credentials": {
            "gmailOAuth2": {
              "id": "aYzk7sZF8ZVyfOan",
              "name": "Gmail account"
            }
          }
        },
        {
          "parameters": {
            "rules": {
              "values": [
                {
                  "conditions": {
                    "options": {
                      "caseSensitive": true,
                      "leftValue": "",
                      "typeValidation": "strict",
                      "version": 3
                    },
                    "conditions": [
                      {
                        "leftValue": "={{ $('Check Flag Conditions').first().json.routingDecision }}",
                        "rightValue": "UNKNOWN",
                        "operator": {
                          "type": "string",
                          "operation": "equals"
                        },
                        "id": "fdaa4cce-f659-4578-9c46-202690c03765"
                      }
                    ],
                    "combinator": "and"
                  },
                  "renameOutput": true,
                  "outputKey": "unknown"
                },
                {
                  "conditions": {
                    "options": {
                      "caseSensitive": true,
                      "leftValue": "",
                      "typeValidation": "strict",
                      "version": 3
                    },
                    "conditions": [
                      {
                        "leftValue": "={{ $('Check Flag Conditions').first().json.routingDecision }}",
                        "rightValue": "NEW",
                        "operator": {
                          "type": "string",
                          "operation": "equals"
                        },
                        "id": "80183d52-64e0-42d4-8909-3f740283fc72"
                      }
                    ],
                    "combinator": "and"
                  },
                  "renameOutput": true,
                  "outputKey": "new"
                },
                {
                  "conditions": {
                    "options": {
                      "caseSensitive": true,
                      "leftValue": "",
                      "typeValidation": "strict",
                      "version": 3
                    },
                    "conditions": [
                      {
                        "leftValue": "={{ $('Check Flag Conditions').first().json.routingDecision }}",
                        "rightValue": "EXISTING",
                        "operator": {
                          "type": "string",
                          "operation": "equals"
                        },
                        "id": "222204cf-bfa8-4db1-9aa2-49253f27b77a"
                      }
                    ],
                    "combinator": "and"
                  },
                  "renameOutput": true,
                  "outputKey": "existing"
                }
              ]
            },
            "options": {
              "fallbackOutput": "none"
            }
          },
          "id": "decision-gate-001",
          "name": "Decision Gate",
          "type": "n8n-nodes-base.switch",
          "typeVersion": 3.4,
          "position": [
            3024,
            280
          ]
        },
        {
          "parameters": {
            "jsCode": "// Handle unidentified client - send to manual queue\n  const items = $input.all();\n  const results = [];\n\n  for (const item of items) {\n    results.push({\n      json: {\n        status: 'FAILED',\n        reason: 'Client name could not be identified',\n        email_id: item.json.emailId,\n        email_subject: item.json.emailSubject,\n        timestamp: new Date().toISOString()\n      }\n    });\n  }\n\n  return results;"
          },
          "id": "handle-unknown-001",
          "name": "Handle Unidentified Client",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3248,
            24
          ]
        },
        {
          "parameters": {
            "jsCode": "// Prepare UNKNOWN client data with simple static naming\n// V3: Use simple UNKNOWN_CLIENT naming instead of timestamp\nconst inputData = $input.first().json;\n\nconst clientName = \"unknown_client\";\n\nreturn [{\n  json: {\n    client_name: clientName,\n    parent_folder_id: inputData.parent_folder_id,\n    client_name_raw: inputData.client_name_raw,\n    client_status: inputData.client_status,\n    root_folder_id: inputData.root_folder_id,\n    staging_folder_id: inputData.staging_folder_id,\n    extraction_failure: inputData.extraction_failure,\n    extraction_error_message: inputData.extraction_error_message,\n    is_unknown_client: true,\n    unknown_timestamp: new Date().toISOString()\n  },\n  binary: $input.first().binary\n}];"
          },
          "id": "prepare-unknown-data-001",
          "name": "Prepare UNKNOWN Client Data",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3472,
            24
          ]
        },
        {
          "parameters": {
            "workflowId": {
              "__rl": true,
              "value": "zbxHkXOoD1qaz6OS",
              "mode": "list",
              "cachedResultUrl": "/workflow/zbxHkXOoD1qaz6OS",
              "cachedResultName": "AMA Chunk 0: Folder Initialization (V4 - Parameterized)"
            },
            "workflowInputs": {
              "mappingMode": "defineBelow",
              "value": {
                "client_name": "={{ $json.clientName }}",
                "client_normalized": "={{ $json.clientNormalized }}",
                "sender_email": "={{ $json.senderEmail }}",
                "sender_name": "={{ $json.senderName }}",
                "email_subject": "={{ $json.subject }}"
              },
              "matchingColumns": [],
              "schema": [
                {
                  "id": "client_name",
                  "displayName": "client_name",
                  "required": false,
                  "defaultMatch": false,
                  "display": true,
                  "canBeUsedToMatch": true,
                  "type": "string"
                },
                {
                  "id": "client_normalized",
                  "displayName": "client_normalized",
                  "required": false,
                  "defaultMatch": false,
                  "display": true,
                  "canBeUsedToMatch": true,
                  "type": "string"
                },
                {
                  "id": "sender_email",
                  "displayName": "sender_email",
                  "required": false,
                  "defaultMatch": false,
                  "display": true,
                  "canBeUsedToMatch": true,
                  "type": "string"
                },
                {
                  "id": "sender_name",
                  "displayName": "sender_name",
                  "required": false,
                  "defaultMatch": false,
                  "display": true,
                  "canBeUsedToMatch": true,
                  "type": "string"
                },
                {
                  "id": "email_subject",
                  "displayName": "email_subject",
                  "required": false,
                  "defaultMatch": false,
                  "display": true,
                  "canBeUsedToMatch": true,
                  "type": "string"
                }
              ],
              "attemptToConvertTypes": false,
              "convertFieldsToString": true
            },
            "options": {}
          },
          "id": "bc9b052a-1fdf-412c-990a-7c3e58178304",
          "name": "Execute Chunk 0 - Create Folders (UNKNOWN)",
          "type": "n8n-nodes-base.executeWorkflow",
          "typeVersion": 1.3,
          "position": [
            3696,
            200
          ]
        },
        {
          "parameters": {
            "jsCode": "// Extract 38_Unknowns folder ID from Chunk 0 response\n// ALSO get file_id from earlier in workflow\n\nconst chunk0Response = $input.first().json;\nconst folderData = chunk0Response.folderIDs || [];\n\nconst unknownsFolder = folderData.find(item =>\n  item.Variable_Name === 'FOLDER_38_UNKNOWNS'\n);\n\nif (!unknownsFolder || !unknownsFolder.Folder_ID) {\n  throw new Error('FOLDER_38_UNKNOWNS not found in Chunk 0 response');\n}\n\n// Get file_id from Extract File ID & Metadata node\nconst fileMetadata = $('Extract File ID & Metadata').first().json;\nconst fileId = fileMetadata.file_id;\n\nif (!fileId) {\n  throw new Error('file_id not found from Extract File ID & Metadata node');\n}\n\nreturn {\n  json: {\n    unknowns_folder_id: unknownsFolder.Folder_ID,\n    temp_pdf_file_id: fileId,\n    root_folder_id: chunk0Response.Root_Folder_ID,\n    client_name: chunk0Response.Client_Name,\n    ...chunk0Response\n  },\n  binary: $input.first().binary\n};\n"
          },
          "id": "extract-unknowns-folder-001",
          "name": "Extract 38_Unknowns Folder ID",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3920,
            200
          ]
        },
        {
          "parameters": {
            "jsCode": "const folderId = $json.unknowns_folder_id;\nconst fileId = $json.temp_pdf_file_id;\n\nif (!folderId || folderId === '') {\n  throw new Error('Missing unknowns_folder_id - cannot move file');\n}\n\nif (!fileId || fileId === '') {\n  throw new Error('Missing temp_pdf_file_id - no file to move');\n}\n\nreturn {\n  json: {\n    unknowns_folder_id: folderId,\n    temp_pdf_file_id: fileId,\n    ...$json\n  },\n  binary: $input.first().binary\n};"
          },
          "id": "validate-folder-ids-001",
          "name": "Validate Folder IDs",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            4144,
            200
          ]
        },
        {
          "parameters": {
            "operation": "move",
            "fileId": {
              "__rl": true,
              "value": "={{ $json.temp_pdf_file_id }}",
              "mode": "id"
            },
            "driveId": {
              "__rl": true,
              "mode": "list",
              "value": "My Drive"
            },
            "folderId": {
              "__rl": true,
              "value": "={{ $('Execute Chunk 0 - Create Folders (UNKNOWN)').item.json.folderIDs[43].Folder_ID }}",
              "mode": "id"
            }
          },
          "id": "move-pdf-unknowns-001",
          "name": "Move PDF to 38_Unknowns",
          "type": "n8n-nodes-base.googleDrive",
          "typeVersion": 3,
          "position": [
            4368,
            200
          ],
          "retryOnFail": true,
          "maxTries": 3,
          "waitBetweenTries": 5000,
          "credentials": {
            "googleDriveOAuth2Api": {
              "id": "a4m50EefR3DJoU0R",
              "name": "Google Drive account"
            }
          }
        },
        {
          "parameters": {
            "jsCode": "// Get data from correct sources\n// CRITICAL FIX: Get root_folder_id from Validate Folder IDs (before Move PDF wiped data)\nconst folderData = $('Validate Folder IDs').first().json;\nconst emailData = $('Gmail Trigger - Unread with Attachments').first().json;\nconst moveResult = $input.first().json;\n\nconst rootFolderId = folderData.Root_Folder_ID || folderData.root_folder_id;\nconst rootFolderName = folderData.Client_Name || folderData.client_name || 'UNKNOWN';\nconst unknownsFolderId = folderData.unknowns_folder_id;\nconst pdfFileId = moveResult.id || folderData.temp_pdf_file_id;\n\nconst pdfLink = `https://drive.google.com/file/d/${pdfFileId}/view`;\nconst rootFolderLink = `https://drive.google.com/drive/folders/${rootFolderId}`;\n\nconst emailFrom = emailData.from || 'Unknown Sender';\nconst emailSubject = emailData.subject || 'No Subject';\nconst pdfFilename = folderData.pdf_filename || 'unknown.pdf';\n\nconst timestamp = new Date().toLocaleString('en-US', {\n  timeZone: 'Europe/Berlin',\n  year: 'numeric',\n  month: '2-digit',\n  day: '2-digit',\n  hour: '2-digit',\n  minute: '2-digit',\n  hour12: false\n});\n\nreturn [{\n  json: {\n    to: 'swayclarkeii@gmail.com',\n    pdf_filename: pdfFilename,\n    email_from: emailFrom,\n    email_subject: emailSubject,\n    root_folder_name: rootFolderName,\n    pdf_link: pdfLink,\n    root_folder_link: rootFolderLink,\n    timestamp: timestamp\n  },\n  binary: $input.first().binary\n}];"
          },
          "id": "prepare-email-data-001",
          "name": "Prepare Email Notification Data",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            4592,
            200
          ]
        },
        {
          "parameters": {
            "jsCode": "// Build HTML email body for UNKNOWN client notification\nconst data = $input.first().json;\n\n// Extract just the email address (not the display name)\nconst emailAddress = data.email_from?.value?.[0]?.address || 'Unknown Sender';\n\nconst htmlBody = `<!DOCTYPE html>\n<html>\n<body style=\"font-family: Arial, sans-serif; line-height: 1.6; color: #333;\">\n  <div style=\"max-width: 600px; margin: 0 auto; padding: 20px;\">\n    <h2 style=\"color: #d32f2f;\">‚ö†Ô∏è Unknown Client Document Received</h2>\n    \n    <p>A document was received but the client could not be identified. Manual review is required.</p>\n    \n    <div style=\"background: #f5f5f5; padding: 15px; border-left: 4px solid #1976d2; margin: 20px 0;\">\n      <h3 style=\"margin-top: 0;\">Document Details</h3>\n      <ul style=\"list-style: none; padding: 0;\">\n        <li><strong>Filename:</strong> ${data.pdf_filename}</li>\n        <li><strong>From:</strong> ${emailAddress}</li>\n        <li><strong>Subject:</strong> ${data.email_subject}</li>\n      </ul>\n    </div>\n    \n    <div style=\"background: #fff3e0; padding: 15px; border-left: 4px solid #f57c00; margin: 20px 0;\">\n      <h3 style=\"margin-top: 0;\">üìÇ Created Folder Structure</h3>\n      <p>A temporary folder structure has been created:</p>\n      <ul style=\"list-style: none; padding: 0;\">\n        <li><strong>Root Folder:</strong> ${data.root_folder_name}</li>\n        <li><strong>Document Location:</strong> SONSTIGES/38_Unknowns/</li>\n      </ul>\n    </div>\n    \n    <div style=\"margin: 30px 0;\">\n      <h3>üîó Quick Actions</h3>\n      <div style=\"margin: 10px 0;\">\n        <a href=\"${data.pdf_link}\" \n           style=\"display: inline-block; padding: 12px 24px; background: #1976d2; color: white; text-decoration: none; border-radius: 4px; margin-right: 10px;\">\n          üìÑ View PDF\n        </a>\n        <a href=\"${data.root_folder_link}\" \n           style=\"display: inline-block; padding: 12px 24px; background: #43a047; color: white; text-decoration: none; border-radius: 4px;\">\n          üìÅ Open Folder Structure\n        </a>\n      </div>\n    </div>\n    \n    <div style=\"background: #e3f2fd; padding: 15px; border-left: 4px solid #1976d2; margin: 20px 0;\">\n      <h3 style=\"margin-top: 0;\">‚úÖ Next Steps</h3>\n      <ol>\n        <li>Review the PDF to identify the client</li>\n        <li>Rename the root folder to the correct client name</li>\n        <li>Update the Client_Registry sheet with the correct client name</li>\n        <li>Move the PDF from 38_Unknowns to the appropriate subfolder</li>\n      </ol>\n    </div>\n    \n    <hr style=\"border: none; border-top: 1px solid #ddd; margin: 30px 0;\">\n    \n    <p style=\"font-size: 12px; color: #666;\">\n      <strong>System:</strong> Eugene AMA Document Organizer V4<br>\n      <strong>Timestamp:</strong> ${data.timestamp}\n    </p>\n  </div>\n</body>\n</html>`;\n\nreturn [{\n  json: {\n    ...data,\n    html_body: htmlBody\n  },\n  binary: $input.first().binary\n}];"
          },
          "id": "build-email-html-001",
          "name": "Build Email HTML Body",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            4816,
            200
          ]
        },
        {
          "parameters": {
            "sendTo": "swayclarkeii@gmail.com",
            "subject": "={{ $json.emailSubject || '[ACTION REQUIRED] Unknown Client Document' }}",
            "message": "={{ $json.html_body }}",
            "options": {}
          },
          "id": "send-email-notification-001",
          "name": "Send Email Notification",
          "type": "n8n-nodes-base.gmail",
          "typeVersion": 2,
          "position": [
            5040,
            200
          ],
          "webhookId": "dc7eb55f-c28e-4cdc-83a8-fe7d1c1a01c4",
          "credentials": {
            "gmailOAuth2": {
              "id": "aYzk7sZF8ZVyfOan",
              "name": "Gmail account"
            }
          }
        },
        {
          "parameters": {
            "workflowId": {
              "__rl": true,
              "value": "zbxHkXOoD1qaz6OS",
              "mode": "list",
              "cachedResultUrl": "/workflow/zbxHkXOoD1qaz6OS",
              "cachedResultName": "AMA Chunk 0: Folder Initialization (V4 - Parameterized)"
            },
            "workflowInputs": {
              "mappingMode": "defineBelow",
              "value": {
                "client_name": "={{ $('Batch Voting - Find Common Identifier').first().json.clientName }}",
                "client_normalized": "={{ $('Batch Voting - Find Common Identifier').first().json.clientNormalized }}",
                "sender_email": "={{ $('Batch Voting - Find Common Identifier').first().json.senderEmail }}",
                "sender_name": "={{ $('Batch Voting - Find Common Identifier').first().json.senderName }}",
                "email_subject": "={{ $('Batch Voting - Find Common Identifier').first().json.subject }}"
              },
              "matchingColumns": [],
              "schema": [
                {
                  "id": "client_name",
                  "displayName": "client_name",
                  "required": false,
                  "defaultMatch": false,
                  "display": true,
                  "canBeUsedToMatch": true,
                  "type": "string"
                },
                {
                  "id": "client_normalized",
                  "displayName": "client_normalized",
                  "required": false,
                  "defaultMatch": false,
                  "display": true,
                  "canBeUsedToMatch": true,
                  "type": "string"
                },
                {
                  "id": "sender_email",
                  "displayName": "sender_email",
                  "required": false,
                  "defaultMatch": false,
                  "display": true,
                  "canBeUsedToMatch": true,
                  "type": "string"
                },
                {
                  "id": "sender_name",
                  "displayName": "sender_name",
                  "required": false,
                  "defaultMatch": false,
                  "display": true,
                  "canBeUsedToMatch": true,
                  "type": "string"
                },
                {
                  "id": "email_subject",
                  "displayName": "email_subject",
                  "required": false,
                  "defaultMatch": false,
                  "display": true,
                  "canBeUsedToMatch": true,
                  "type": "string"
                }
              ],
              "attemptToConvertTypes": false,
              "convertFieldsToString": true
            },
            "options": {}
          },
          "id": "execute-chunk0-001",
          "name": "Execute Chunk 0 - Create Folders (NEW)",
          "type": "n8n-nodes-base.executeWorkflow",
          "typeVersion": 1.3,
          "position": [
            3248,
            216
          ]
        },
        {
          "parameters": {
            "jsCode": "// Merge Chunk 0 output with file data - output ONE item per file\nconst chunk0Output = $input.first().json;\n\n// Get analysisResults from Batch Voting (NOT Decision Gate - which might have Gmail response)\nconst batchVotingData = $('Batch Voting - Find Common Identifier').first().json;\nconst analysisResults = batchVotingData.analysisResults || [];\n\n// Output one item per file (n8n will loop automatically)\nreturn analysisResults.map(file => ({\n  json: {\n    ...chunk0Output,\n    file_id: file.fileId,\n    email_id: batchVotingData.emailId,\n    filename: file.fileName,\n    // Keep all original chunk0 data\n    clientName: chunk0Output.Client_Name || batchVotingData.clientName,\n    clientNormalized: chunk0Output.Client_Normalized || batchVotingData.clientNormalized,\n    Staging_Folder_ID: chunk0Output.Staging_Folder_ID,\n    Root_Folder_ID: chunk0Output.Root_Folder_ID,\n    analysisResults: analysisResults  // Keep full array for downstream\n  }\n}));"
          },
          "id": "0180f051-407b-453b-89fc-faaf3439c20d",
          "name": "Merge Chunk 0 Output (NEW)",
          "type": "n8n-nodes-base.code",
          "typeVersion": 1,
          "position": [
            3472,
            216
          ]
        },
        {
          "parameters": {
            "operation": "move",
            "fileId": {
              "__rl": true,
              "value": "={{ $json.file_id }}",
              "mode": "id"
            },
            "driveId": {
              "__rl": true,
              "mode": "list",
              "value": "My Drive"
            },
            "folderId": {
              "__rl": true,
              "value": "={{ $json.Staging_Folder_ID }}",
              "mode": "id"
            }
          },
          "id": "b767c01a-345c-4a94-ba35-35f8dda0fb2c",
          "name": "Move PDF to _Staging (NEW)",
          "type": "n8n-nodes-base.googleDrive",
          "typeVersion": 3,
          "position": [
            3696,
            392
          ],
          "retryOnFail": true,
          "maxTries": 3,
          "waitBetweenTries": 5000,
          "credentials": {
            "googleDriveOAuth2Api": {
              "id": "a4m50EefR3DJoU0R",
              "name": "Google Drive account"
            }
          }
        },
        {
          "parameters": {
            "jsCode": "// Prepare for Chunk 2.5 (NEW) - Multi-file version\n// This node now receives N items (one per file moved to staging)\n// Process each item individually\n\nconst items = $input.all();\n\n// Get shared data from upstream nodes (same for all files)\nconst emailData = $('Gmail Trigger - Unread with Attachments').first().json;\nconst binaryData = $('Gmail Trigger - Unread with Attachments').first().binary;\nconst clientData = $('Batch Voting - Find Common Identifier').first().json;\n\n// Get first attachment key for size info\nconst attachmentKeys = Object.keys(binaryData || {});\n\n// Extract email sender\nlet emailFrom = '';\nif (emailData.from && emailData.from.value && emailData.from.value[0]) {\n  emailFrom = emailData.from.value[0].address;\n}\n\n// Process each file\nreturn items.map((item, index) => {\n  const driveFile = item.json;\n  const fileName = driveFile.name || 'unknown.pdf';\n  const extension = fileName.substring(fileName.lastIndexOf('.') + 1).toLowerCase();\n  \n  // Get size from corresponding attachment if available\n  let fileSizeBytes = 0;\n  const attachmentKey = attachmentKeys[index] || attachmentKeys[0];\n  const attachment = binaryData?.[attachmentKey] || {};\n  if (attachment.fileSize) {\n    const sizeStr = attachment.fileSize;\n    const match = sizeStr.match(/^([\\d.]+)\\s*(KB|MB|GB)$/i);\n    if (match) {\n      const value = parseFloat(match[1]);\n      const unit = match[2].toUpperCase();\n      const multipliers = { KB: 1024, MB: 1024 * 1024, GB: 1024 * 1024 * 1024 };\n      fileSizeBytes = Math.round(value * multipliers[unit]);\n    }\n  }\n  \n  // Construct stagingPath\n  const clientName = clientData.clientNormalized || clientData.clientName || 'unknown';\n  const stagingPath = `${clientName}/_Staging/${fileName}`;\n  \n  // Find analysis result for this file\n  const analysisResults = clientData.analysisResults || [];\n  const fileAnalysis = analysisResults.find(a => a.fileId === driveFile.id) || analysisResults[index] || {};\n  const extractedText = fileAnalysis.identifier || clientData.clientName || '';\n  const extractionMethod = fileAnalysis.extractionMethod || 'claude_vision';\n  const textLength = extractedText.length || 0;\n  \n  return {\n    json: {\n      fileId: driveFile.id,\n      fileName: driveFile.name,\n      mimeType: driveFile.mimeType,\n      extension: extension,\n      size: fileSizeBytes,\n      emailId: emailData.id,\n      emailFrom: emailFrom,\n      emailSubject: emailData.subject,\n      emailDate: emailData.date,\n      stagingPath: stagingPath,\n      originalFileName: attachment.fileName || fileName,\n      extractedFromZip: false,\n      zipFileName: null,\n      client_name: clientData.clientName,\n      client_normalized: clientData.clientNormalized,\n      \n      // Pass Claude Vision extracted identifier to Chunk 2.5\n      extractedText: extractedText,\n      extractionMethod: extractionMethod,\n      extractionModel: 'claude-sonnet-4-20250514',\n      textLength: textLength,\n      skipDownload: textLength > 5,\n      \n      // Track file index\n      fileIndex: index,\n      totalFiles: items.length\n    }\n  };\n});"
          },
          "id": "prepare-chunk2-new-001",
          "name": "Prepare for Chunk 2.5 (NEW)",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            4144,
            392
          ],
          "notes": "Enriches Google Drive data with email metadata for Chunk 2"
        },
        {
          "parameters": {
            "workflowId": {
              "__rl": true,
              "value": "okg8wTqLtPUwjQ18",
              "mode": "list",
              "cachedResultName": "Chunk 2.5 - Client Document Tracking (Eugene Document Organizer)"
            },
            "workflowInputs": {
              "mappingMode": "defineBelow",
              "value": {}
            },
            "options": {}
          },
          "id": "execute-chunk2-new-001",
          "name": "Execute Chunk 2.5 (NEW)",
          "type": "n8n-nodes-base.executeWorkflow",
          "typeVersion": 1.3,
          "position": [
            4368,
            392
          ],
          "notes": "Executes Chunk 2 text extraction workflow"
        },
        {
          "parameters": {
            "operation": "markAsRead",
            "messageId": "={{ $('Gmail Trigger - Unread with Attachments').first().json.id }}"
          },
          "id": "mark-read-new-001",
          "name": "Mark Email as Read (NEW)",
          "type": "n8n-nodes-base.gmail",
          "typeVersion": 2.1,
          "position": [
            4592,
            392
          ],
          "webhookId": "aa32d8bd-c351-4f48-9356-212f242a6ea6",
          "credentials": {
            "gmailOAuth2": {
              "id": "aYzk7sZF8ZVyfOan",
              "name": "Gmail account"
            }
          },
          "notes": "Marks the processed email as read"
        },
        {
          "parameters": {},
          "id": "noop-new-complete-001",
          "name": "NoOp - NEW Complete",
          "type": "n8n-nodes-base.noOp",
          "typeVersion": 1,
          "position": [
            4816,
            392
          ]
        },
        {
          "parameters": {
            "documentId": {
              "__rl": true,
              "mode": "id",
              "value": "1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI"
            },
            "sheetName": {
              "__rl": true,
              "value": 762792134,
              "mode": "list",
              "cachedResultName": "Client_Registry",
              "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI/edit#gid=762792134"
            },
            "options": {}
          },
          "id": "lookup-staging-folder-001",
          "name": "Lookup Staging Folder",
          "type": "n8n-nodes-base.googleSheets",
          "typeVersion": 4.7,
          "position": [
            3248,
            504
          ],
          "credentials": {
            "googleSheetsOAuth2Api": {
              "id": "H7ewI1sOrDYabelt",
              "name": "Google Sheets account"
            }
          }
        },
        {
          "parameters": {
            "jsCode": "// V7: FIXED - Use clientNormalized instead of client_name\n// Extract staging_folder_id from Client Registry lookup AND file_id from upload\nconst clientNormalized = $('Batch Voting - Find Common Identifier').first().json.clientNormalized;\nconst sheetRows = $input.all();\nconst batchVotingData = $('Batch Voting - Find Common Identifier').first().json;\nconst analysisResults = batchVotingData.analysisResults || [];\n\n// Find matching row by normalizing Client_Name the same way as \"Batch Voting\" node\nconst matchingRow = sheetRows.find(row => {\n  const registryClientName = row.json.Client_Name || '';\n  \n  // Normalize Client_Name to match clientNormalized format\n  const normalizedName = registryClientName\n    .toLowerCase()\n    .trim()\n    .replace(/√§/g, 'ae')\n    .replace(/√∂/g, 'oe')\n    .replace(/√º/g, 'ue')\n    .replace(/√ü/g, 'ss')\n    .replace(/\\s*(gmbh|ag|kg|e\\.v\\.|mbh|co\\.|&\\s*co\\.?)\\s*/gi, '')\n    .replace(/[^a-z0-9]/g, '_')\n    .replace(/_+/g, '_')\n    .replace(/^_|_$/g, '');\n  \n  return normalizedName === clientNormalized;\n});\n\n// GRACEFUL HANDLING: Route to 38_Unknowns if no matching row\nif (!matchingRow) {\n  return analysisResults.map(file => ({\n    json: {\n      file_id: file.fileId,\n      filename: file.fileName,\n      email_id: batchVotingData.emailId,\n      clientNormalized: clientNormalized,\n      clientName: batchVotingData.clientName,\n      error: `No staging folder found for client: ${clientNormalized}`,\n      routeTo38Unknowns: true,\n      errorType: 'missing_client_in_registry',\n      skipChunk1: true,\n      analysisResults: analysisResults\n    }\n  }));\n}\n\nconst stagingFolderId = matchingRow.json.Staging_Folder_ID || matchingRow.json['01_Staging'];\n\n// GRACEFUL HANDLING: Route to 38_Unknowns if staging folder ID is empty\nif (!stagingFolderId) {\n  return analysisResults.map(file => ({\n    json: {\n      file_id: file.fileId,\n      filename: file.fileName,\n      email_id: batchVotingData.emailId,\n      clientNormalized: clientNormalized,\n      clientName: batchVotingData.clientName,\n      error: `Staging_Folder_ID is empty for client: ${clientNormalized}`,\n      routeTo38Unknowns: true,\n      errorType: 'missing_staging_folder',\n      skipChunk1: true,\n      analysisResults: analysisResults\n    }\n  }));\n}\n\n// SUCCESS PATH: Output one item per file\nreturn analysisResults.map(file => ({\n  json: {\n    clientNormalized: clientNormalized,\n    clientName: batchVotingData.clientName,\n    Staging_Folder_ID: stagingFolderId,\n    email_id: batchVotingData.emailId,\n    file_id: file.fileId,\n    filename: file.fileName,\n    routeTo38Unknowns: false,\n    analysisResults: analysisResults\n  }\n}));"
          },
          "id": "filter-staging-folder-001",
          "name": "Filter Staging Folder ID",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3472,
            504
          ]
        },
        {
          "parameters": {
            "conditions": {
              "options": {
                "caseSensitive": true,
                "leftValue": "",
                "typeValidation": "strict",
                "version": 1
              },
              "conditions": [
                {
                  "id": "route-unknowns-check",
                  "leftValue": "={{ $json.routeTo38Unknowns }}",
                  "rightValue": true,
                  "operator": {
                    "type": "boolean",
                    "operation": "true",
                    "singleValue": true
                  }
                }
              ],
              "combinator": "and"
            },
            "options": {}
          },
          "id": "check-routing-decision-001",
          "name": "Check Routing Decision",
          "type": "n8n-nodes-base.if",
          "typeVersion": 2,
          "position": [
            3696,
            624
          ]
        },
        {
          "parameters": {
            "operation": "move",
            "fileId": {
              "__rl": true,
              "value": "={{ $json.file_id }}",
              "mode": "id"
            },
            "driveId": {
              "__rl": true,
              "mode": "list",
              "value": "My Drive"
            },
            "folderId": {
              "__rl": true,
              "value": "={{ $json.Staging_Folder_ID }}",
              "mode": "id"
            }
          },
          "id": "90cc99fd-908d-4149-a2f7-35f42ab2e232",
          "name": "Move PDF to _Staging (EXISTING)",
          "type": "n8n-nodes-base.googleDrive",
          "typeVersion": 3,
          "position": [
            3920,
            584
          ],
          "alwaysOutputData": true,
          "retryOnFail": true,
          "maxTries": 3,
          "waitBetweenTries": 5000,
          "credentials": {
            "googleDriveOAuth2Api": {
              "id": "a4m50EefR3DJoU0R",
              "name": "Google Drive account"
            }
          }
        },
        {
          "parameters": {
            "amount": 3
          },
          "id": "wait-staging-existing-001",
          "name": "Wait After Staging (EXISTING)",
          "type": "n8n-nodes-base.wait",
          "typeVersion": 1.1,
          "position": [
            4144,
            584
          ],
          "alwaysOutputData": true,
          "executeOnce": false,
          "webhookId": "582865bf-87ef-485e-9074-f3538bf7e781"
        },
        {
          "parameters": {
            "jsCode": "// Prepare for Chunk 2.5 (EXISTING) - V10 Fixed node references\n// Get Google Drive upload result from previous node\nconst driveUpload = $input.first().json;\n\n// Retrieve email metadata from Gmail Trigger\nconst emailData = $('Gmail Trigger - Unread with Attachments').first().json;\n\n// Retrieve binary metadata from Gmail Trigger\nconst binaryData = $('Gmail Trigger - Unread with Attachments').first().binary;\n\n// Get first attachment key\nconst attachmentKeys = Object.keys(binaryData || {});\nconst attachmentKey = attachmentKeys[0] || 'attachment_0';\nconst attachment = binaryData?.[attachmentKey] || {};\n\n// Extract file extension from filename\nconst fileName = driveUpload.name || 'unknown.pdf';\nconst extension = fileName.substring(fileName.lastIndexOf('.') + 1).toLowerCase();\n\n// FIXED: Get client data from Batch Voting node (was incorrectly referencing 'Normalize Client Name')\nconst clientData = $('Batch Voting - Find Common Identifier').first().json;\nconst clientName = clientData.clientNormalized || clientData.clientName || 'unknown';\n\n// Construct stagingPath\nconst stagingPath = `${clientName}/_Staging/${fileName}`;\n\n// Parse file size\nlet fileSizeBytes = 0;\nif (attachment.fileSize) {\n  const sizeStr = attachment.fileSize;\n  const match = sizeStr.match(/^([\\d.]+)\\s*(KB|MB|GB)$/i);\n  if (match) {\n    const value = parseFloat(match[1]);\n    const unit = match[2].toUpperCase();\n    const multipliers = { KB: 1024, MB: 1024 * 1024, GB: 1024 * 1024 * 1024 };\n    fileSizeBytes = Math.round(value * multipliers[unit]);\n  }\n}\n\n// Extract email sender\nlet emailFrom = '';\nif (emailData.from && emailData.from.value && emailData.from.value[0]) {\n  emailFrom = emailData.from.value[0].address;\n}\n\n// Get extracted identifier from Batch Voting (which has analysisResults from Claude)\nconst analysisResults = clientData.analysisResults || [];\nconst firstAnalysis = analysisResults[0] || {};\nconst extractedText = firstAnalysis.identifier || clientData.clientName || '';\nconst extractionMethod = firstAnalysis.extractionMethod || 'claude_vision';\nconst textLength = extractedText.length || 0;\n\n// Build complete Chunk 2.5 input\nreturn [{\n  json: {\n    fileId: driveUpload.id,\n    fileName: driveUpload.name,\n    mimeType: driveUpload.mimeType,\n    extension: extension,\n    size: fileSizeBytes,\n    emailId: emailData.id,\n    emailFrom: emailFrom,\n    emailSubject: emailData.subject,\n    emailDate: emailData.date,\n    stagingPath: stagingPath,\n    originalFileName: attachment.fileName || fileName,\n    extractedFromZip: false,\n    zipFileName: null,\n    client_name: clientData.clientName,\n    client_normalized: clientData.clientNormalized,\n\n    // Pass Claude Vision extracted identifier to Chunk 2.5\n    extractedText: extractedText,\n    extractionMethod: extractionMethod,\n    extractionModel: 'claude-sonnet-4-20250514',\n    textLength: textLength,\n    skipDownload: textLength > 5\n  }\n}];"
          },
          "id": "prepare-chunk2-existing-001",
          "name": "Prepare for Chunk 2.5 (EXISTING)",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            4368,
            584
          ],
          "notes": "Enriches Google Drive data with email metadata for Chunk 2"
        },
        {
          "parameters": {
            "workflowId": {
              "__rl": true,
              "value": "okg8wTqLtPUwjQ18",
              "mode": "list",
              "cachedResultName": "Chunk 2.5 - Client Document Tracking (Eugene Document Organizer)"
            },
            "workflowInputs": {
              "mappingMode": "defineBelow",
              "value": {}
            },
            "options": {}
          },
          "id": "execute-chunk2-existing-001",
          "name": "Execute Chunk 2.5 (EXISTING)",
          "type": "n8n-nodes-base.executeWorkflow",
          "typeVersion": 1.3,
          "position": [
            4592,
            584
          ],
          "notes": "Executes Chunk 2 text extraction workflow"
        },
        {
          "parameters": {
            "operation": "markAsRead",
            "messageId": "={{ $('Gmail Trigger - Unread with Attachments').first().json.id }}"
          },
          "id": "mark-read-existing-001",
          "name": "Mark Email as Read (EXISTING)",
          "type": "n8n-nodes-base.gmail",
          "typeVersion": 2.1,
          "position": [
            4816,
            584
          ],
          "webhookId": "2542dae1-6ffe-419e-9bff-6be0b9b8b5be",
          "credentials": {
            "gmailOAuth2": {
              "id": "aYzk7sZF8ZVyfOan",
              "name": "Gmail account"
            }
          },
          "notes": "Marks the processed email as read"
        },
        {
          "parameters": {},
          "id": "noop-existing-complete-001",
          "name": "NoOp - EXISTING Complete",
          "type": "n8n-nodes-base.noOp",
          "typeVersion": 1,
          "position": [
            5040,
            584
          ]
        },
        {
          "parameters": {
            "jsCode": "// V2: Multi-file handling - Prepare data for routing to 38_Unknowns when staging folder is missing\nconst items = $input.all();\n\n// Output one error item per file\nreturn items.map(item => ({\n  json: {\n    client_name: 'unknown_client',\n    parent_folder_id: '1ikw3k-EgpVg_h2ySDdqdUFB7-FQyYDFm',\n    client_status: 'UNKNOWN',\n    is_unknown_client: true,\n    error_reason: item.json.error || 'Missing staging folder',\n    error_type: item.json.errorType || 'missing_staging_folder',\n    file_id: item.json.file_id,\n    filename: item.json.filename,\n    email_id: item.json.email_id,\n    unknown_timestamp: new Date().toISOString(),\n    analysisResults: item.json.analysisResults\n  }\n}));"
          },
          "id": "prepare-missing-folder-error-001",
          "name": "Prepare Missing Folder Error",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3920,
            776
          ]
        },
        {
          "parameters": {
            "jsCode": "// Format error email data for registry corruption\nconst inputData = $input.all();\n\nconst output = inputData.map(item => {\n  const clientName = item.json.client_name || 'Unknown Client';\n  const fileName = item.json.file_name || 'Unknown File';\n  const emailSubject = item.json.email_subject || 'N/A';\n  const emailFrom = item.json.email_from || 'N/A';\n  const emailDate = item.json.email_date || 'N/A';\n  \n  return {\n    json: {\n      ...item.json,\n      email_to: 'swayclarkeii@gmail.com',\n      email_subject: `[URGENT] Registry Error: ${clientName} - Missing Staging Folder`,\n      email_message: `CRITICAL REGISTRY ERROR DETECTED\n\nClient: ${clientName}\nError Type: Client marked EXISTING but staging_folder_id is MISSING in Client Registry\n\n--- ACTION TAKEN ---\nFile moved to 38_Unknowns folder for manual review\n\n--- ORIGINAL EMAIL DETAILS ---\nSubject: ${emailSubject}\nFrom: ${emailFrom}\nDate: ${emailDate}\nAttachment: ${fileName}\n\n--- NEXT STEPS ---\nPlease:\n1. Open the Client Registry spreadsheet\n2. Find the row for \"${clientName}\"\n3. Add the missing staging_folder_id to column E\n4. Manually move the file from 38_Unknowns to the correct staging folder\n\nThis is a data integrity issue that needs immediate attention.\n\n---\nWorkflow: AMA Pre-Chunk 0\nNode: Registry Error Handler`\n    }\n  };\n});\n\nreturn output;"
          },
          "id": "prepare-registry-error-email-001",
          "name": "Prepare Registry Error Email Data",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            4144,
            776
          ]
        },
        {
          "parameters": {
            "sendTo": "={{ $json.email_to }}",
            "subject": "={{ $json.email_subject }}",
            "message": "={{ $json.email_message }}",
            "options": {}
          },
          "id": "send-registry-error-email-001",
          "name": "Send Registry Error Email",
          "type": "n8n-nodes-base.gmail",
          "typeVersion": 2.1,
          "position": [
            4368,
            776
          ],
          "webhookId": "95afad2f-dd9b-48e1-ab8f-1054d2466b08",
          "credentials": {
            "gmailOAuth2": {
              "id": "aYzk7sZF8ZVyfOan",
              "name": "Gmail account"
            }
          }
        },
        {
          "parameters": {
            "operation": "move",
            "fileId": {
              "__rl": true,
              "mode": "id",
              "value": "={{ $json.file_id }}"
            },
            "driveId": {
              "__rl": true,
              "mode": "list",
              "value": "My Drive"
            },
            "folderId": {
              "__rl": true,
              "mode": "list",
              "value": "1qdUu-dIkQR0oDaZKAL_8OhI0jST89_Vu"
            }
          },
          "id": "move-to-unknowns-registry-001",
          "name": "Move to 38_Unknowns (Registry Error)",
          "type": "n8n-nodes-base.googleDrive",
          "typeVersion": 3,
          "position": [
            4592,
            776
          ],
          "retryOnFail": true,
          "maxTries": 3,
          "waitBetweenTries": 5000,
          "credentials": {
            "googleDriveOAuth2Api": {
              "id": "a4m50EefR3DJoU0R",
              "name": "Google Drive account"
            }
          }
        },
        {
          "parameters": {
            "operation": "addLabels",
            "messageId": "={{ $json.email_id }}",
            "labelIds": [
              "INBOX"
            ]
          },
          "id": "mark-read-registry-error-001",
          "name": "Mark Email as Read (Registry Error)",
          "type": "n8n-nodes-base.gmail",
          "typeVersion": 2.1,
          "position": [
            4816,
            776
          ],
          "webhookId": "dbf7cd2a-877f-4ff9-85a5-a04f5f4fa02a",
          "credentials": {
            "gmailOAuth2": {
              "id": "aYzk7sZF8ZVyfOan",
              "name": "Gmail account"
            }
          }
        },
        {
          "parameters": {},
          "id": "noop-registry-complete-001",
          "name": "NoOp - Registry Error Complete",
          "type": "n8n-nodes-base.noOp",
          "typeVersion": 1,
          "position": [
            5040,
            776
          ]
        },
        {
          "parameters": {
            "operation": "pdf",
            "options": {
              "joinPages": true,
              "keepSource": "json"
            }
          },
          "id": "extract-text-001",
          "name": "Extract Text from PDF",
          "type": "n8n-nodes-base.extractFromFile",
          "typeVersion": 1.1,
          "position": [
            784,
            1016
          ],
          "disabled": true,
          "notes": "‚ö†Ô∏è OLD METHOD - Disabled. Use 'Prepare Document AI Request' path instead for proper OCR."
        },
        {
          "parameters": {
            "jsCode": "// V4: Evaluate extraction quality for each PDF\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  // FIX: Check both extractedText (from OCR) and text (from digital extraction)\n  const extractedText = item.json.extractedText || item.json.text || '';\n  const wordCount = extractedText.trim().split(/\\s+/).length;\n\n  results.push({\n    json: {\n      ...item.json,\n      wordCount: wordCount,\n      needsOCR: wordCount < 10,\n      extractionQuality: wordCount < 10 ? 'poor' : 'good',\n      \n      // Keep extracted text for downstream use\n      extractedText: extractedText,\n      textLength: extractedText.trim().length,\n      extractionMethod: 'digital_pre_chunk'\n    },\n    binary: item.binary\n  });\n}\n\nreturn results;"
          },
          "id": "evaluate-extraction-001",
          "name": "Evaluate Extraction Quality",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            1008,
            872
          ],
          "disabled": true
        },
        {
          "parameters": {
            "resource": "chat",
            "chatModel": "gpt-4.1-mini",
            "prompt": {
              "messages": [
                {
                  "role": "system",
                  "content": "Extract the PROJECT or PROPERTY IDENTIFIER from this German real estate document.\n\nValid identifiers (in order of priority):\n\n1. STREET ADDRESS + CITY (MOST COMMON IN THESE DOCUMENTS):\n   - \"Schlo√übergstra√üe 13, T√ºbingen\" ‚Üí \"Schlossberg 13\"\n   - \"Schlo√übergstr. 13\" ‚Üí \"Schlossberg 13\"\n   - Normalize: Remove \"stra√üe/str.\", keep number\n\n2. PROJECT CODES/ABBREVIATIONS:\n   - \"BV Propos\" ‚Üí \"Propos\"\n   - \"Projekt Schlo√überg\" ‚Üí \"Schlossberg\"\n\n3. PROPERTY/VILLA NAMES\n\n4. COMPANY NAMES (if property-related)\n\n5. PERSON/RECIPIENT NAMES (last resort)\n\nEXTRACTION RULES:\n- Look for street addresses FIRST\n- \"Schlo√überg\" and \"Schlossberg\" are the same (normalize to \"Schlossberg\")\n- Combine street name + number: \"Schlo√übergstra√üe 13\" ‚Üí \"Schlossberg 13\"\n\nReturn ONLY the normalized identifier, nothing else.\nIf no identifiable project/property exists, return exactly: UNKNOWN"
                },
                {
                  "content": "={{ $json.extractedText }}"
                }
              ]
            },
            "options": {},
            "requestOptions": {}
          },
          "id": "ai-extract-client-001",
          "name": "AI Extract Client Name",
          "type": "n8n-nodes-base.openAi",
          "typeVersion": 1.1,
          "position": [
            1232,
            872
          ],
          "credentials": {
            "openAiApi": {
              "id": "xmJ7t6kaKgMwA1ce",
              "name": "OpenAi account"
            }
          },
          "disabled": true
        },
        {
          "parameters": {
            "jsCode": "const crypto = require('crypto');\n\n// Google Service Account credentials\nconst serviceAccount = {\n  projectId: 'n8n-integrations-482020',\n  clientEmail: 'n8n-document-ai@n8n-integrations-482020.iam.gserviceaccount.com',\n  privateKey: `-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCwWo8CBWPs5tvS\nP01jLTf6Rc54JrOCEU1KIOpkZryrT082kD/eXx73unpLGUCb9t5u9kjCjiU8BPMp\nqnPQSCVzeuMNWLYcyQfGIUFRfCSi/7bg5q1mwv+DkLsgNWx0mRAk5pfPCv9qW9qk\n+XyNYtqk3FlgWBRtynwd49cCN1FoaRgTQTv6KsRtqV7nc6MyE+VyyhMY64uoQfCN\nd+PrXkE20yDaNg/yZU/re3/2kqeWVt3F5nxZFbuM2wBof0wLQcqkZ/ggN9/C/zdp\nBpTnZlTadNzjPePKGBaMHyDP01/E4xUU9d9TJMM4OWc5ReFIMlSdYnzjhuir1+5A\no2JmvpmRAgMBAAECggEADZAkGC4H8wwHnfzmW8P6M9Jd6xm24UBUEb5u/c0fojaV\noLGpZ9XS+48o9qZONMXgx5HuI0sWtq3+xuvoFP280PaDiImTv/+qDGU5sSWmFQSB\nBn0B8GRQ4x0kzHkEtVb29I+TigXjgkTm5PHserHpSkKe0Re/wniPNnvzvk+OKu8W\nvnSleUP8NamyIxoMRZNWYdUI/yJvU6o2nuxZKe6aVvaF2T3eQ/3pYucvfgsV7L1i\nkle6T//NjEmrpeFtZEAgrnAAWLso7R+pbN08zc3Jbxb5Q1E6WABlTi6gbI9tmwuu\n53pe1GY4AGNpfGUiIO/UX/R+9/DSYCMrQMhqTdD8fQKBgQDptBqfAmcDgC9hFkSA\nopIxslCCsQ56eXTyZ0BL+qQiFyhQFmV3Do4vVLatJvZiUIWonNYxZYfxEMP06dW+\nk/Bu4NAoSc46wlvY1Bj9xOn7s/afNlY4J0YKrSpIuqQZHyhjERvK7Nn1UHDZ92qJ\nFXvaNJ0uUUYry5xuYrbwrfECKwKBgQDBLcNJsXKVYmaMh/xkucAKeeOWy/ME2kZz\noyEFcmgQhKU0Sr7C0OdLE3JnlL+9oz0ashBPb06Y0vsqDzl+0iwU81oc1RD/wBZz\nBgV2NB0jYvsIHFkI4BY5p4fePF5Q97UCaGttBf3JL1fFFeif/r1Rq2FbAnnpXsqF\npHrOFKsBMwKBgQC6CmjiyhvNWp7c78gKiuBMdYHH+EDpWISzb2Rs15MPnFW4I4wU\nUd74aLyfbJPYwfcUuf19BzFHwyvrbLZ95vEQoyCx4cctWYmaO4XFhpsphyK9rZjH\nTORiHWW6zfFSGk6hRn5UdWYw9h9QNLh3dkXI9/dkZsiwln7qFOVDBYUFTwKBgC7r\nnJlTnk8mXV4Y0XbtnvVscZj45IfzNFV189lM1nXcofu3g+nxr5wOlyUNfhzjfz3y\nrf99O4vnAtZOaFqjVc2o5eRG5CAaWdmKRt1U/xbPPcXUjNOZCgzq4hdadlYYNEDn\nd+A9Kk0pUJowHhZuWzFw/O6MBWxnd61KLAHOB1L9AoGARwyJIEwHeUeoAuCRlQyS\nxYzI8eMIDJ7HSiaFms+j8cuNy76O9U5E0KVBz6BEeTfq+aym0vyZ6iKJ3+q/IXQ4\no5jc6G6zgrMAgeuKzKFEwKNK/tm5j3FiDEzcUqLI00AfdG/f+QI/dTxbqnlB1tPn\nT0v0rf9bjMnUWoH9kXFM+XA=\n-----END PRIVATE KEY-----`\n};\n\n// Step 1: Create JWT token\nconst now = Math.floor(Date.now() / 1000);\nconst jwtHeader = {\n  alg: 'RS256',\n  typ: 'JWT'\n};\n\nconst jwtClaims = {\n  iss: serviceAccount.clientEmail,\n  scope: 'https://www.googleapis.com/auth/cloud-platform',\n  aud: 'https://oauth2.googleapis.com/token',\n  exp: now + 3600,\n  iat: now\n};\n\n// Encode header and claims\nconst base64UrlEncode = (str) => {\n  return Buffer.from(str)\n    .toString('base64')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '');\n};\n\nconst encodedHeader = base64UrlEncode(JSON.stringify(jwtHeader));\nconst encodedClaims = base64UrlEncode(JSON.stringify(jwtClaims));\nconst signatureInput = `${encodedHeader}.${encodedClaims}`;\n\n// Sign with private key using crypto module\nconst sign = crypto.createSign('RSA-SHA256');\nsign.update(signatureInput);\nconst signature = sign.sign(serviceAccount.privateKey, 'base64')\n  .replace(/\\+/g, '-')\n  .replace(/\\//g, '_')\n  .replace(/=/g, '');\n\nconst jwt = `${signatureInput}.${signature}`;\n\n// Step 2: Exchange JWT for access token\nconst tokenResponse = await this.helpers.httpRequest({\n  method: 'POST',\n  url: 'https://oauth2.googleapis.com/token',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded'\n  },\n  body: `grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer&assertion=${jwt}`\n});\n\nconst accessToken = tokenResponse.access_token;\n\n// Step 3: Get PDF binary and convert to base64\nconst item = $input.first();\nconst binaryKey = Object.keys(item.binary)[0];\nconst buffer = await this.helpers.getBinaryDataBuffer(0, binaryKey);\nconst base64Content = buffer.toString('base64');\n\n// Step 4: Prepare Document AI request body\nconst documentAiRequest = {\n  rawDocument: {\n    content: base64Content,\n    mimeType: 'application/pdf'\n  }\n};\n\n// Return access token, request body, and original data\nreturn {\n  json: {\n    ...item.json,\n    accessToken: accessToken,\n    documentAiRequest: documentAiRequest\n  },\n  binary: item.binary\n};"
          },
          "id": "prepare-docai-request-001",
          "name": "Prepare Document AI Request",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            336,
            824
          ],
          "disabled": true
        },
        {
          "parameters": {
            "method": "POST",
            "url": "https://eu-documentai.googleapis.com/v1/projects/504943079120/locations/eu/processors/954baa10f2e87364:process",
            "sendHeaders": true,
            "headerParameters": {
              "parameters": [
                {
                  "name": "Authorization",
                  "value": "=Bearer {{ $json.accessToken }}"
                },
                {
                  "name": "Content-Type",
                  "value": "application/json"
                }
              ]
            },
            "sendBody": true,
            "specifyBody": "json",
            "jsonBody": "={{ JSON.stringify($json.documentAiRequest) }}",
            "options": {}
          },
          "id": "call-docai-ocr-001",
          "name": "Call Document AI OCR",
          "type": "n8n-nodes-base.httpRequest",
          "typeVersion": 4.3,
          "position": [
            560,
            824
          ],
          "disabled": true,
          "notes": "Google Document AI OCR\n\nProcessor: 954baa10f2e87364\nRegion: eu\nProject: n8n-integrations-482020"
        },
        {
          "parameters": {
            "jsCode": "// Parse Google Document AI response\nconst item = $input.first();\nconst docAiResponse = item.json;\n\nlet extractedText = '';\nlet pageCount = 0;\n\n// Extract text from Document AI response\nif (docAiResponse.document && docAiResponse.document.text) {\n  extractedText = docAiResponse.document.text;\n  pageCount = docAiResponse.document.pages ? docAiResponse.document.pages.length : 0;\n}\n\n// Get original data from upstream node (Download PDF from Drive)\nconst originalData = $('Download PDF from Drive').first().json;\n\nreturn {\n  json: {\n    ...originalData,\n    extractedText: extractedText.trim(),\n    ocrSuccess: extractedText.length > 0,\n    ocrEngine: 'Google Document AI',\n    pageCount: pageCount\n  },\n  binary: item.binary\n};"
          },
          "id": "parse-docai-response-001",
          "name": "Parse Document AI Response",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            784,
            824
          ],
          "disabled": true
        },
        {
          "parameters": {
            "conditions": {
              "options": {
                "caseSensitive": true,
                "leftValue": "",
                "typeValidation": "strict",
                "version": 1
              },
              "conditions": [
                {
                  "id": "size-check",
                  "leftValue": "={{ $json.isLargeFile }}",
                  "rightValue": true,
                  "operator": {
                    "type": "boolean",
                    "operation": "equals"
                  }
                }
              ],
              "combinator": "and"
            },
            "options": {}
          },
          "id": "check-size-route-001",
          "name": "Check Size Route",
          "type": "n8n-nodes-base.if",
          "typeVersion": 2,
          "position": [
            1904,
            -168
          ]
        },
        {
          "parameters": {
            "url": "=https://www.googleapis.com/drive/v3/files/{{ $json.file_id }}?fields=thumbnailLink",
            "authentication": "predefinedCredentialType",
            "nodeCredentialType": "googleDriveOAuth2Api",
            "options": {}
          },
          "id": "get-thumbnail-001",
          "name": "Get Thumbnail URL",
          "type": "n8n-nodes-base.httpRequest",
          "typeVersion": 4.2,
          "position": [
            2128,
            -240
          ],
          "credentials": {
            "googleDriveOAuth2Api": {
              "id": "a4m50EefR3DJoU0R",
              "name": "Google Drive account"
            }
          }
        },
        {
          "parameters": {
            "url": "={{ $json.thumbnailLink.replace('=s220', '=s1600') }}",
            "options": {
              "response": {
                "response": {
                  "responseFormat": "file"
                }
              }
            }
          },
          "id": "fetch-thumbnail-001",
          "name": "Fetch Thumbnail Image",
          "type": "n8n-nodes-base.httpRequest",
          "typeVersion": 4.2,
          "position": [
            2352,
            -240
          ]
        },
        {
          "parameters": {
            "jsCode": "// Convert thumbnail to Base64 for Claude\nconst item = $input.first();\nconst prevData = $('Check Size Route').first().json;\n\nconst binaryKey = Object.keys(item.binary)[0];\nconst buffer = await this.helpers.getBinaryDataBuffer(0, binaryKey);\nconst base64Content = buffer.toString('base64');\n\nreturn {\n  json: {\n    ...prevData,\n    usedThumbnail: true,\n    imageData: {\n      type: 'base64',\n      media_type: 'image/png',\n      data: base64Content\n    }\n  }\n};"
          },
          "id": "convert-thumbnail-001",
          "name": "Convert Thumbnail to Base64",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            2576,
            -240
          ]
        },
        {
          "parameters": {
            "jsCode": "// Pass through each moved file with enriched metadata\n// This node receives N items (one per file moved to staging)\n// It preserves them as N items for Chunk 2.5 to process each\n\nconst items = $input.all();\n\n// Get shared data from upstream nodes\nconst clientData = $('Batch Voting - Find Common Identifier').first().json;\nconst chunk0Output = $('Execute Chunk 0 - Create Folders (NEW)').first().json;\n\nreturn items.map((item, index) => {\n  // item.json has Google Drive move result: {kind, id, name, mimeType}\n  const driveResult = item.json;\n  \n  return {\n    json: {\n      // Google Drive file info (what Prepare for Chunk 2.5 expects)\n      id: driveResult.id,\n      name: driveResult.name,\n      mimeType: driveResult.mimeType,\n      kind: driveResult.kind,\n      \n      // Client/folder metadata\n      clientName: clientData.clientName,\n      clientNormalized: clientData.clientNormalized,\n      Staging_Folder_ID: chunk0Output.Staging_Folder_ID,\n      Root_Folder_ID: chunk0Output.Root_Folder_ID,\n      \n      // Analysis results for this file\n      analysisResults: clientData.analysisResults,\n      \n      // Track which file this is\n      fileIndex: index,\n      totalFiles: items.length\n    }\n  };\n});"
          },
          "id": "aggregate-staging-files-001",
          "name": "Aggregate Staged Files",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3920,
            392
          ]
        }
      ],
      "connections": {
        "Gmail Trigger - Unread with Attachments": {
          "main": [
            [
              {
                "node": "Extract Email Metadata",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Extract Email Metadata": {
          "main": [
            [
              {
                "node": "Filter PDF/ZIP Attachments",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Filter PDF/ZIP Attachments": {
          "main": [
            [
              {
                "node": "Split Into Batches - Process Each PDF",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Split Into Batches - Process Each PDF": {
          "main": [
            [
              {
                "node": "Aggregate All PDF Results",
                "type": "main",
                "index": 0
              }
            ],
            [
              {
                "node": "Upload PDF to Temp Folder",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Upload PDF to Temp Folder": {
          "main": [
            [
              {
                "node": "Extract File ID & Metadata",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Extract File ID & Metadata": {
          "main": [
            [
              {
                "node": "Download PDF from Drive",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Download PDF from Drive": {
          "main": [
            [
              {
                "node": "Convert PDF to Base64",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Claude Tesxt Extration": {
          "main": [
            [
              {
                "node": "Parse Claude Response",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Parse Claude Response": {
          "main": [
            [
              {
                "node": "Wait Between Vision Calls",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Wait Between Vision Calls": {
          "main": [
            [
              {
                "node": "Store Analysis Result",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Store Analysis Result": {
          "main": [
            [
              {
                "node": "Split Into Batches - Process Each PDF",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Aggregate All PDF Results": {
          "main": [
            [
              {
                "node": "Parse Email Body for Mentions",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Parse Email Body for Mentions": {
          "main": [
            [
              {
                "node": "Batch Voting - Find Common Identifier",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Batch Voting - Find Common Identifier": {
          "main": [
            [
              {
                "node": "Lookup Client Registry",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Lookup Client Registry": {
          "main": [
            [
              {
                "node": "Check Client Exists",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Check Client Exists": {
          "main": [
            [
              {
                "node": "Check Flag Conditions",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Check Flag Conditions": {
          "main": [
            [
              {
                "node": "Should Send Review Email?",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Should Send Review Email?": {
          "main": [
            [
              {
                "node": "Prepare Review Email",
                "type": "main",
                "index": 0
              }
            ],
            [
              {
                "node": "Decision Gate",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Prepare Review Email": {
          "main": [
            [
              {
                "node": "Send Review Email",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Send Review Email": {
          "main": [
            [
              {
                "node": "Decision Gate",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Decision Gate": {
          "main": [
            [
              {
                "node": "Handle Unidentified Client",
                "type": "main",
                "index": 0
              }
            ],
            [
              {
                "node": "Execute Chunk 0 - Create Folders (NEW)",
                "type": "main",
                "index": 0
              }
            ],
            [
              {
                "node": "Lookup Staging Folder",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Handle Unidentified Client": {
          "main": [
            [
              {
                "node": "Prepare UNKNOWN Client Data",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Prepare UNKNOWN Client Data": {
          "main": [
            [
              {
                "node": "Execute Chunk 0 - Create Folders (UNKNOWN)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Execute Chunk 0 - Create Folders (UNKNOWN)": {
          "main": [
            [
              {
                "node": "Extract 38_Unknowns Folder ID",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Extract 38_Unknowns Folder ID": {
          "main": [
            [
              {
                "node": "Validate Folder IDs",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Validate Folder IDs": {
          "main": [
            [
              {
                "node": "Move PDF to 38_Unknowns",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Move PDF to 38_Unknowns": {
          "main": [
            [
              {
                "node": "Prepare Email Notification Data",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Prepare Email Notification Data": {
          "main": [
            [
              {
                "node": "Build Email HTML Body",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Build Email HTML Body": {
          "main": [
            [
              {
                "node": "Send Email Notification",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Execute Chunk 0 - Create Folders (NEW)": {
          "main": [
            [
              {
                "node": "Merge Chunk 0 Output (NEW)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Merge Chunk 0 Output (NEW)": {
          "main": [
            [
              {
                "node": "Move PDF to _Staging (NEW)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Move PDF to _Staging (NEW)": {
          "main": [
            [
              {
                "node": "Aggregate Staged Files",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Prepare for Chunk 2.5 (NEW)": {
          "main": [
            [
              {
                "node": "Execute Chunk 2.5 (NEW)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Execute Chunk 2.5 (NEW)": {
          "main": [
            [
              {
                "node": "Mark Email as Read (NEW)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Mark Email as Read (NEW)": {
          "main": [
            [
              {
                "node": "NoOp - NEW Complete",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Lookup Staging Folder": {
          "main": [
            [
              {
                "node": "Filter Staging Folder ID",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Filter Staging Folder ID": {
          "main": [
            [
              {
                "node": "Check Routing Decision",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Move PDF to _Staging (EXISTING)": {
          "main": [
            [
              {
                "node": "Wait After Staging (EXISTING)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Wait After Staging (EXISTING)": {
          "main": [
            [
              {
                "node": "Prepare for Chunk 2.5 (EXISTING)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Prepare for Chunk 2.5 (EXISTING)": {
          "main": [
            [
              {
                "node": "Execute Chunk 2.5 (EXISTING)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Execute Chunk 2.5 (EXISTING)": {
          "main": [
            [
              {
                "node": "Mark Email as Read (EXISTING)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Mark Email as Read (EXISTING)": {
          "main": [
            [
              {
                "node": "NoOp - EXISTING Complete",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Prepare Missing Folder Error": {
          "main": [
            [
              {
                "node": "Prepare Registry Error Email Data",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Prepare Registry Error Email Data": {
          "main": [
            [
              {
                "node": "Send Registry Error Email",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Send Registry Error Email": {
          "main": [
            [
              {
                "node": "Move to 38_Unknowns (Registry Error)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Move to 38_Unknowns (Registry Error)": {
          "main": [
            [
              {
                "node": "Mark Email as Read (Registry Error)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Mark Email as Read (Registry Error)": {
          "main": [
            [
              {
                "node": "NoOp - Registry Error Complete",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Extract Text from PDF": {
          "main": [
            [
              {
                "node": "Evaluate Extraction Quality",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Evaluate Extraction Quality": {
          "main": [
            [
              {
                "node": "AI Extract Client Name",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "AI Extract Client Name": {
          "main": [
            [
              {
                "node": "Batch Voting - Find Common Identifier",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Prepare Document AI Request": {
          "main": [
            [
              {
                "node": "Call Document AI OCR",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Call Document AI OCR": {
          "main": [
            [
              {
                "node": "Parse Document AI Response",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Parse Document AI Response": {
          "main": [
            [
              {
                "node": "Evaluate Extraction Quality",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Build Claude API Request": {
          "main": [
            [
              {
                "node": "Claude Tesxt Extration",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Convert PDF to Base64": {
          "main": [
            [
              {
                "node": "Check Size Route",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Check Size Route": {
          "1": [
            [
              {
                "node": "Build Claude API Request",
                "type": "1",
                "index": 0
              }
            ]
          ],
          "main": [
            [
              {
                "node": "Get Thumbnail URL",
                "type": "main",
                "index": 0
              }
            ],
            [
              {
                "node": "Build Claude API Request",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Get Thumbnail URL": {
          "main": [
            [
              {
                "node": "Fetch Thumbnail Image",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Fetch Thumbnail Image": {
          "main": [
            [
              {
                "node": "Convert Thumbnail to Base64",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Convert Thumbnail to Base64": {
          "main": [
            [
              {
                "node": "Build Claude API Request",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Aggregate Staged Files": {
          "main": [
            [
              {
                "node": "Prepare for Chunk 2.5 (NEW)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Check Routing Decision": {
          "main": [
            [
              {
                "node": "Prepare Missing Folder Error",
                "type": "main",
                "index": 0
              }
            ],
            [
              {
                "node": "Move PDF to _Staging (EXISTING)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        }
      },
      "authors": "Sway Clarke",
      "name": "Version 659937fd",
      "description": "",
      "autosaved": false,
      "workflowPublishHistory": [
        {
          "createdAt": "2026-01-21T23:13:06.219Z",
          "id": 1086,
          "workflowId": "p0X9PrpCShIgxxMP",
          "versionId": "659937fd-18fe-4ad8-ab36-ce661b1f17bf",
          "event": "activated",
          "userId": "e9bd9112-c2e3-4f67-873a-e1001baeafd8"
        }
      ]
    }
  }
}
