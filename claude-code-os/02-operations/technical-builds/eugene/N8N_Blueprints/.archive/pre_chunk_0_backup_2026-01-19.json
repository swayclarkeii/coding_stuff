{
  "success": true,
  "data": {
    "updatedAt": "2026-01-18T23:26:12.370Z",
    "createdAt": "2026-01-07T09:49:33.855Z",
    "id": "YGXWjWcBIk66ArvT",
    "name": "AMA Pre-Chunk 0 - REBUILT v1",
    "description": null,
    "active": true,
    "isArchived": false,
    "nodes": [
      {
        "parameters": {
          "pollTimes": {
            "item": [
              {
                "mode": "everyMinute"
              }
            ]
          },
          "simple": false,
          "filters": {
            "labelIds": [
              "INBOX",
              "UNREAD",
              "Label_8011160688574026773"
            ],
            "q": "has:attachment"
          },
          "options": {
            "dataPropertyAttachmentsPrefixName": "attachment_",
            "downloadAttachments": true
          }
        },
        "id": "gmail-trigger-001",
        "name": "Gmail Trigger - Unread with Attachments",
        "type": "n8n-nodes-base.gmailTrigger",
        "typeVersion": 1.3,
        "position": [
          112,
          208
        ],
        "credentials": {
          "gmailOAuth2": {
            "id": "aYzk7sZF8ZVyfOan",
            "name": "Gmail account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Filter PDF and ZIP attachments only\nconst items = $input.all();\nconst filtered = [];\n\nfor (const item of items) {\n  // Gmail trigger stores attachments in item.binary, not item.json.attachments\n  if (!item.binary) continue;\n  \n  // Iterate over binary keys (attachment_0, attachment_1, etc.)\n  for (const [key, attachment] of Object.entries(item.binary)) {\n    const filename = attachment.fileName;\n    if (!filename) continue;\n    \n    const ext = filename.toLowerCase().split('.').pop();\n    \n    if (['pdf', 'zip'].includes(ext)) {\n      filtered.push({\n        json: {\n          emailId: item.json.id,\n          emailSubject: item.json.Subject || item.json.subject,\n          emailFrom: item.json.From || item.json.from,\n          emailDate: item.json.date,\n          attachmentKey: key,\n          filename: filename,\n          mimeType: attachment.mimeType,\n          size: attachment.fileSize\n        },\n        binary: {\n          data: attachment\n        }\n      });\n    }\n  }\n}\n\nreturn filtered;"
        },
        "id": "filter-attachments-001",
        "name": "Filter PDF/ZIP Attachments",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          336,
          208
        ]
      },
      {
        "parameters": {
          "driveId": {
            "__rl": true,
            "mode": "list",
            "value": "My Drive"
          },
          "folderId": {
            "__rl": true,
            "mode": "list",
            "value": "root",
            "cachedResultName": "/ (Root folder)"
          },
          "options": {}
        },
        "id": "upload-pdf-gdrive-001",
        "name": "Upload PDF to Temp Folder",
        "type": "n8n-nodes-base.googleDrive",
        "typeVersion": 3,
        "position": [
          560,
          208
        ],
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "a4m50EefR3DJoU0R",
            "name": "Google Drive account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Extract Google Drive file ID from upload response and preserve email metadata\nconst uploadResult = $input.first().json;\nconst emailData = $('Filter PDF/ZIP Attachments').first().json;\n\nreturn [{\n  json: {\n    file_id: uploadResult.id,\n    filename: uploadResult.name,\n    emailId: emailData.emailId,\n    emailSubject: emailData.emailSubject,\n    emailFrom: emailData.emailFrom,\n    emailDate: emailData.emailDate\n  }\n}];"
        },
        "id": "extract-file-id-001",
        "name": "Extract File ID & Metadata",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          784,
          208
        ]
      },
      {
        "parameters": {
          "operation": "download",
          "fileId": {
            "__rl": true,
            "mode": "id",
            "value": "={{ $json.file_id }}"
          },
          "options": {}
        },
        "id": "download-pdf-from-gdrive-001",
        "name": "Download PDF from Drive",
        "type": "n8n-nodes-base.googleDrive",
        "typeVersion": 3,
        "position": [
          1008,
          208
        ],
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "a4m50EefR3DJoU0R",
            "name": "Google Drive account"
          }
        }
      },
      {
        "parameters": {
          "operation": "pdf",
          "options": {
            "joinPages": true,
            "keepSource": "json"
          }
        },
        "id": "extract-text-001",
        "name": "Extract Text from PDF",
        "type": "n8n-nodes-base.extractFromFile",
        "typeVersion": 1.1,
        "position": [
          1456,
          592
        ],
        "disabled": true,
        "notes": "‚ö†Ô∏è OLD METHOD - Disabled. Use 'Prepare Document AI Request' path instead for proper OCR."
      },
      {
        "parameters": {
          "jsCode": "// V4: Evaluate extraction quality for each PDF\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  // FIX: Check both extractedText (from OCR) and text (from digital extraction)\n  const extractedText = item.json.extractedText || item.json.text || '';\n  const wordCount = extractedText.trim().split(/\\s+/).length;\n\n  results.push({\n    json: {\n      ...item.json,\n      wordCount: wordCount,\n      needsOCR: wordCount < 10,\n      extractionQuality: wordCount < 10 ? 'poor' : 'good',\n      \n      // Keep extracted text for downstream use\n      extractedText: extractedText,\n      textLength: extractedText.trim().length,\n      extractionMethod: 'digital_pre_chunk'\n    },\n    binary: item.binary\n  });\n}\n\nreturn results;"
        },
        "id": "evaluate-extraction-001",
        "name": "Evaluate Extraction Quality",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1680,
          400
        ],
        "disabled": true
      },
      {
        "parameters": {
          "resource": "chat",
          "chatModel": "gpt-4.1-mini",
          "prompt": {
            "messages": [
              {
                "role": "system",
                "content": "Extract the PROJECT or PROPERTY IDENTIFIER from this German real estate document.\n\nValid identifiers (in order of priority):\n\n1. STREET ADDRESS + CITY (MOST COMMON IN THESE DOCUMENTS):\n   - \"Schlo√übergstra√üe 13, T√ºbingen\" ‚Üí \"Schlossberg 13\"\n   - \"Schlo√übergstr. 13\" ‚Üí \"Schlossberg 13\"\n   - Normalize: Remove \"stra√üe/str.\", keep number\n\n2. PROJECT CODES/ABBREVIATIONS:\n   - \"BV Propos\" ‚Üí \"Propos\"\n   - \"Projekt Schlo√überg\" ‚Üí \"Schlossberg\"\n\n3. PROPERTY/VILLA NAMES\n\n4. COMPANY NAMES (if property-related)\n\n5. PERSON/RECIPIENT NAMES (last resort)\n\nEXTRACTION RULES:\n- Look for street addresses FIRST\n- \"Schlo√überg\" and \"Schlossberg\" are the same (normalize to \"Schlossberg\")\n- Combine street name + number: \"Schlo√übergstra√üe 13\" ‚Üí \"Schlossberg 13\"\n\nReturn ONLY the normalized identifier, nothing else.\nIf no identifiable project/property exists, return exactly: UNKNOWN"
              },
              {
                "content": "={{ $json.extractedText }}"
              }
            ]
          },
          "options": {},
          "requestOptions": {}
        },
        "id": "ai-extract-client-001",
        "name": "AI Extract Client Name",
        "type": "n8n-nodes-base.openAi",
        "typeVersion": 1.1,
        "position": [
          1904,
          400
        ],
        "credentials": {
          "openAiApi": {
            "id": "xmJ7t6kaKgMwA1ce",
            "name": "OpenAi account"
          }
        },
        "disabled": true
      },
      {
        "parameters": {
          "jsCode": "// Get all input items\nconst items = $input.all();\nconst results = [];\n\n// Process each item\nfor (const item of items) {\n  let clientNameRaw = '';\n  \n  // Extract client name from input\n  // Priority 1: client_name_raw field (from Parse Claude Response - Claude Vision)\n  if (item.json && item.json.client_name_raw) {\n    clientNameRaw = String(item.json.client_name_raw);\n  }\n  // Priority 2: OpenAI Chat API (unsimplified): choices[0].message.content\n  else if (item.json && item.json.choices && item.json.choices[0] && item.json.choices[0].message) {\n    clientNameRaw = String(item.json.choices[0].message.content);\n  }\n  // Priority 3: OpenAI Chat API (simplified): message.content\n  else if (item.json && item.json.message && item.json.message.content) {\n    clientNameRaw = String(item.json.message.content);\n  }\n  // Priority 4: Text API (simplified): text\n  else if (item.json && item.json.text) {\n    clientNameRaw = String(item.json.text);\n  }\n  \n  clientNameRaw = clientNameRaw.trim();\n  \n  // CRITICAL FIX: Remove duplicate responses from Chat API\n  // Chat API sometimes returns \"Villa Martens\\n\\nVilla Martens\"\n  // Split by double newline and take first occurrence\n  if (clientNameRaw.includes('\\n\\n')) {\n    const parts = clientNameRaw.split('\\n\\n');\n    // Check if it's a duplicate (same text repeated)\n    if (parts.length === 2 && parts[0].trim() === parts[1].trim()) {\n      clientNameRaw = parts[0].trim();\n    }\n  }\n  \n  // Normalize German client name for folder creation\n  let clientName = '';\n  if (clientNameRaw) {\n    clientName = clientNameRaw\n      .toLowerCase()\n      .trim()\n      .replace(/√§/g, 'ae')\n      .replace(/√∂/g, 'oe')\n      .replace(/√º/g, 'ue')\n      .replace(/√ü/g, 'ss')\n      .replace(/\\s*(gmbh|ag|kg|e\\.v\\.|mbh|co\\.|&\\s*co\\.?)\\s*/gi, '')\n      .replace(/[^a-z0-9]/g, '_')\n      .replace(/_+/g, '_')\n      .replace(/^_|_$/g, '');\n  }\n  \n  results.push({\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: '1ikw3k-EgpVg_h2ySDdqdUFB7-FQyYDFm'\n    }\n  });\n}\n\nreturn results;"
        },
        "id": "normalize-name-001",
        "name": "Normalize Client Name",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2128,
          304
        ]
      },
      {
        "parameters": {
          "documentId": {
            "__rl": true,
            "mode": "id",
            "value": "1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI"
          },
          "sheetName": {
            "__rl": true,
            "mode": "list",
            "value": 762792134,
            "cachedResultName": "Client_Registry",
            "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI/edit#gid=762792134"
          },
          "options": {}
        },
        "id": "lookup-registry-001",
        "name": "Lookup Client Registry",
        "type": "n8n-nodes-base.googleSheets",
        "typeVersion": 4.7,
        "position": [
          2352,
          304
        ],
        "alwaysOutputData": true,
        "credentials": {
          "googleSheetsOAuth2Api": {
            "id": "H7ewI1sOrDYabelt",
            "name": "Google Sheets account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// V7: Check if client exists in Client_Registry\n// CRITICAL FIX V3: Detect literal \"UNKNOWN\" response from AI\n\n// Get normalized client name from Normalize Client Name node (not from $input!)\nconst normalizeOutput = $('Normalize Client Name').first().json;\nconst clientName = normalizeOutput.client_name || '';\nconst clientNameRaw = normalizeOutput.client_name_raw || '';\nconst parentFolderId = normalizeOutput.parent_folder_id || '';\n\n// Get registry rows from $input (Lookup Client Registry output)\nconst registryRows = $input.all();\n\n// ‚úÖ FIRST: Check if AI literally returned \"UNKNOWN\"\nif (clientNameRaw.toUpperCase().trim() === 'UNKNOWN') {\n  return [{\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: parentFolderId,\n      client_status: 'UNKNOWN',\n      root_folder_id: null,\n      staging_folder_id: null,\n      extraction_failure: true,\n      extraction_error_message: 'AI returned UNKNOWN'\n    }\n  }];\n}\n\n// ‚úÖ SECOND: Detect AI extraction failures (technical + polite refusals)\nconst extractionFailurePatterns = [\n  // Technical error messages\n  'unable_to_extract',\n  'error_extracting',\n  'could_not_identify',\n  'could_not_extract',\n  'no_client_name',\n  'extraction_failed',\n  'cannot_identify',\n  // Polite AI refusals\n  'i_m_sorry',\n  'sorry_but',\n  'doesn_t_seem',\n  'does_not_appear',\n  'no_company_name',\n  'cannot_find',\n  'not_able_to'\n];\n\nconst isExtractionFailure = extractionFailurePatterns.some(pattern => \n  clientName.toLowerCase().includes(pattern)\n);\n\nif (isExtractionFailure) {\n  // AI failed to extract client name ‚Üí Route to UNKNOWN path\n  return [{\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: parentFolderId,\n      client_status: 'UNKNOWN',\n      root_folder_id: null,\n      staging_folder_id: null,\n      extraction_failure: true,\n      extraction_error_message: clientNameRaw\n    }\n  }];\n}\n\n// If registry is empty, client is NEW\nif (registryRows.length === 0) {\n  return [{\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: parentFolderId,\n      client_status: 'NEW',\n      root_folder_id: null,\n      staging_folder_id: null\n    }\n  }];\n}\n\n// Search registry for matching client (with same normalization)\nconst clientRow = registryRows.find(row => {\n  const registryClientName = row.json.Client_Name || '';\n  const normalizedRegistryName = registryClientName\n    .toLowerCase()\n    .trim()\n    .replace(/√§/g, 'ae')\n    .replace(/√∂/g, 'oe')\n    .replace(/√º/g, 'ue')\n    .replace(/√ü/g, 'ss')\n    .replace(/\\s*(gmbh|ag|kg|e\\.v\\.|mbh|co\\.|&\\s*co\\.?)\\s*/gi, '')\n    .replace(/[^a-z0-9]/g, '_')\n    .replace(/_+/g, '_')\n    .replace(/^_|_$/g, '');\n  \n  return normalizedRegistryName === clientName;\n});\n\nif (clientRow) {\n  // Client exists ‚Üí EXISTING path\n  return [{\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: parentFolderId,\n      client_status: 'EXISTING',\n      root_folder_id: clientRow.json.Root_Folder_ID,\n      staging_folder_id: clientRow.json.Staging_Folder_ID\n    }\n  }];\n} else {\n  // Client not in registry ‚Üí NEW path\n  return [{\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: parentFolderId,\n      client_status: 'NEW',\n      root_folder_id: null,\n      staging_folder_id: null\n    }\n  }];\n}"
        },
        "id": "check-exists-001",
        "name": "Check Client Exists",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2576,
          304
        ]
      },
      {
        "parameters": {
          "rules": {
            "values": [
              {
                "conditions": {
                  "options": {
                    "caseSensitive": true,
                    "leftValue": "",
                    "typeValidation": "strict",
                    "version": 3
                  },
                  "conditions": [
                    {
                      "leftValue": "={{ $json.client_normalized }}",
                      "rightValue": "",
                      "operator": {
                        "type": "string",
                        "operation": "isEmpty"
                      },
                      "id": "fcfa78d7-b736-4c5c-8123-d82d2456ad6d"
                    },
                    {
                      "leftValue": "={{ $json.client_status }}",
                      "rightValue": "UNKNOWN",
                      "operator": {
                        "type": "string",
                        "operation": "equals"
                      },
                      "id": "0d66b8d3-e3c7-4314-9d28-b4d60c45bef2"
                    }
                  ],
                  "combinator": "or"
                },
                "renameOutput": true,
                "outputKey": "unknown_client"
              },
              {
                "conditions": {
                  "options": {
                    "caseSensitive": true,
                    "leftValue": "",
                    "typeValidation": "strict",
                    "version": 3
                  },
                  "conditions": [
                    {
                      "leftValue": "={{ $json.client_status }}",
                      "rightValue": "NEW",
                      "operator": {
                        "type": "string",
                        "operation": "equals"
                      },
                      "id": "ed430b2e-0251-4783-9c3f-a0d015a07a18"
                    }
                  ],
                  "combinator": "and"
                },
                "renameOutput": true,
                "outputKey": "new_client"
              },
              {
                "conditions": {
                  "options": {
                    "caseSensitive": true,
                    "leftValue": "",
                    "typeValidation": "strict",
                    "version": 3
                  },
                  "conditions": [
                    {
                      "leftValue": "={{ $json.client_status }}",
                      "rightValue": "EXISTING",
                      "operator": {
                        "type": "string",
                        "operation": "equals"
                      },
                      "id": "3db6573d-2127-4c22-855f-afca26e1b811"
                    }
                  ],
                  "combinator": "and"
                },
                "renameOutput": true,
                "outputKey": "existing_client"
              }
            ]
          },
          "options": {}
        },
        "id": "decision-gate-001",
        "name": "Decision Gate",
        "type": "n8n-nodes-base.switch",
        "typeVersion": 3.4,
        "position": [
          2800,
          288
        ]
      },
      {
        "parameters": {
          "jsCode": "// Prepare UNKNOWN client data with simple static naming\n// V3: Use simple UNKNOWN_CLIENT naming instead of timestamp\nconst inputData = $input.first().json;\n\nconst clientName = \"unknown_client\";\n\nreturn [{\n  json: {\n    client_name: clientName,\n    parent_folder_id: inputData.parent_folder_id,\n    client_name_raw: inputData.client_name_raw,\n    client_status: inputData.client_status,\n    root_folder_id: inputData.root_folder_id,\n    staging_folder_id: inputData.staging_folder_id,\n    extraction_failure: inputData.extraction_failure,\n    extraction_error_message: inputData.extraction_error_message,\n    is_unknown_client: true,\n    unknown_timestamp: new Date().toISOString()\n  },\n  binary: $input.first().binary\n}];"
        },
        "id": "prepare-unknown-data-001",
        "name": "Prepare UNKNOWN Client Data",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3248,
          112
        ]
      },
      {
        "parameters": {
          "jsCode": "// Handle unidentified client - send to manual queue\n  const items = $input.all();\n  const results = [];\n\n  for (const item of items) {\n    results.push({\n      json: {\n        status: 'FAILED',\n        reason: 'Client name could not be identified',\n        email_id: item.json.emailId,\n        email_subject: item.json.emailSubject,\n        timestamp: new Date().toISOString()\n      }\n    });\n  }\n\n  return results;"
        },
        "id": "handle-unknown-001",
        "name": "Handle Unidentified Client",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3024,
          112
        ]
      },
      {
        "parameters": {
          "documentId": {
            "__rl": true,
            "mode": "id",
            "value": "1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI"
          },
          "sheetName": {
            "__rl": true,
            "value": 762792134,
            "mode": "list",
            "cachedResultName": "Client_Registry",
            "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI/edit#gid=762792134"
          },
          "options": {}
        },
        "id": "lookup-staging-folder-001",
        "name": "Lookup Staging Folder",
        "type": "n8n-nodes-base.googleSheets",
        "typeVersion": 4.7,
        "position": [
          3024,
          592
        ],
        "credentials": {
          "googleSheetsOAuth2Api": {
            "id": "H7ewI1sOrDYabelt",
            "name": "Google Sheets account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// V6: GRACEFUL ERROR HANDLING - No errors thrown, route to 38_Unknowns if missing\n// Extract staging_folder_id from Client Registry lookup AND file_id from upload\nconst clientName = $('Check Client Exists').first().json.client_name;\nconst sheetRows = $input.all();\nconst fileData = $('Extract File ID & Metadata').first().json;\n\n// Find matching row by normalizing Client_Name the same way as \"Normalize Client Name\" node\nconst matchingRow = sheetRows.find(row => {\n  const registryClientName = row.json.Client_Name || '';\n  \n  // Normalize Client_Name to match client_name format\n  const normalizedName = registryClientName\n    .toLowerCase()\n    .trim()\n    .replace(/√§/g, 'ae')\n    .replace(/√∂/g, 'oe')\n    .replace(/√º/g, 'ue')\n    .replace(/√ü/g, 'ss')\n    .replace(/\\s*(gmbh|ag|kg|e\\.v\\.|mbh|co\\.|&\\s*co\\.?)\\s*/gi, '')\n    .replace(/[^a-z0-9]/g, '_')\n    .replace(/_+/g, '_')\n    .replace(/^_|_$/g, '');\n  \n  return normalizedName === clientName;\n});\n\n// GRACEFUL HANDLING: Route to 38_Unknowns if no matching row\nif (!matchingRow) {\n  return [{\n    json: {\n      ...fileData,\n      client_name: clientName,\n      error: `No staging folder found for client: ${clientName}`,\n      routeTo38Unknowns: true,\n      errorType: 'missing_client_in_registry',\n      skipChunk1: true\n    }\n  }];\n}\n\nconst stagingFolderId = matchingRow.json.Staging_Folder_ID || matchingRow.json['01_Staging'];\n\n// GRACEFUL HANDLING: Route to 38_Unknowns if staging folder ID is empty\nif (!stagingFolderId) {\n  return [{\n    json: {\n      ...fileData,\n      client_name: clientName,\n      error: `Staging_Folder_ID is empty for client: ${clientName}`,\n      routeTo38Unknowns: true,\n      errorType: 'missing_staging_folder',\n      skipChunk1: true\n    }\n  }];\n}\n\n// SUCCESS PATH: Continue with staging folder ID\nreturn [{\n  json: {\n    client_name: clientName,\n    staging_folder_id: stagingFolderId,\n    email_id: fileData.emailId,\n    file_id: fileData.file_id,\n    filename: fileData.filename,\n    routeTo38Unknowns: false\n  }\n}];"
        },
        "id": "filter-staging-folder-001",
        "name": "Filter Staging Folder ID",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3248,
          592
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "strict",
              "version": 2
            },
            "conditions": [
              {
                "id": "route-unknowns-check",
                "leftValue": "={{ $json.routeTo38Unknowns }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "true",
                  "singleValue": true
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "check-routing-decision-001",
        "name": "Check Routing Decision",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          3472,
          592
        ]
      },
      {
        "parameters": {
          "jsCode": "// Prepare data for routing to 38_Unknowns when staging folder is missing\nconst item = $input.first().json;\n\n// Create UNKNOWN_CLIENT structure to match existing unknowns path\nreturn [{\n  json: {\n    client_name: 'unknown_client',\n    parent_folder_id: '1ikw3k-EgpVg_h2ySDdqdUFB7-FQyYDFm',\n    client_status: 'UNKNOWN',\n    is_unknown_client: true,\n    error_reason: item.error || 'Missing staging folder',\n    error_type: item.errorType || 'missing_staging_folder',\n    file_id: item.file_id,\n    filename: item.filename,\n    email_id: item.email_id,\n    unknown_timestamp: new Date().toISOString()\n  }\n}];"
        },
        "id": "prepare-missing-folder-error-001",
        "name": "Prepare Missing Folder Error",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3696,
          688
        ]
      },
      {
        "parameters": {
          "jsCode": "// Extract 38_Unknowns folder ID from Chunk 0 response\n// ALSO get file_id from earlier in workflow\n\nconst chunk0Response = $input.first().json;\nconst folderData = chunk0Response.folderIDs || [];\n\nconst unknownsFolder = folderData.find(item =>\n  item.Variable_Name === 'FOLDER_38_UNKNOWNS'\n);\n\nif (!unknownsFolder || !unknownsFolder.Folder_ID) {\n  throw new Error('FOLDER_38_UNKNOWNS not found in Chunk 0 response');\n}\n\n// Get file_id from Extract File ID & Metadata node\nconst fileMetadata = $('Extract File ID & Metadata').first().json;\nconst fileId = fileMetadata.file_id;\n\nif (!fileId) {\n  throw new Error('file_id not found from Extract File ID & Metadata node');\n}\n\nreturn {\n  json: {\n    unknowns_folder_id: unknownsFolder.Folder_ID,\n    temp_pdf_file_id: fileId,\n    root_folder_id: chunk0Response.Root_Folder_ID,\n    client_name: chunk0Response.Client_Name,\n    ...chunk0Response\n  },\n  binary: $input.first().binary\n};\n"
        },
        "id": "extract-unknowns-folder-001",
        "name": "Extract 38_Unknowns Folder ID",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3696,
          112
        ]
      },
      {
        "parameters": {
          "jsCode": "const folderId = $json.unknowns_folder_id;\nconst fileId = $json.temp_pdf_file_id;\n\nif (!folderId || folderId === '') {\n  throw new Error('Missing unknowns_folder_id - cannot move file');\n}\n\nif (!fileId || fileId === '') {\n  throw new Error('Missing temp_pdf_file_id - no file to move');\n}\n\nreturn {\n  json: {\n    unknowns_folder_id: folderId,\n    temp_pdf_file_id: fileId,\n    ...$json\n  },\n  binary: $input.first().binary\n};"
        },
        "id": "validate-folder-ids-001",
        "name": "Validate Folder IDs",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3920,
          112
        ]
      },
      {
        "parameters": {
          "operation": "move",
          "fileId": "={{ $json.temp_pdf_file_id }}",
          "driveId": {
            "__rl": true,
            "mode": "list",
            "value": "My Drive"
          },
          "folderId": {
            "__rl": true,
            "value": "={{ $('Execute Chunk 0 - Create Folders (UNKNOWN)').item.json.folderIDs[43].Folder_ID }}",
            "mode": ""
          }
        },
        "id": "move-pdf-unknowns-001",
        "name": "Move PDF to 38_Unknowns",
        "type": "n8n-nodes-base.googleDrive",
        "typeVersion": 3,
        "position": [
          4144,
          112
        ],
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "a4m50EefR3DJoU0R",
            "name": "Google Drive account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Get data from correct sources\n// CRITICAL FIX: Get root_folder_id from Validate Folder IDs (before Move PDF wiped data)\nconst folderData = $('Validate Folder IDs').first().json;\nconst emailData = $('Gmail Trigger - Unread with Attachments').first().json;\nconst moveResult = $input.first().json;\n\nconst rootFolderId = folderData.Root_Folder_ID || folderData.root_folder_id;\nconst rootFolderName = folderData.Client_Name || folderData.client_name || 'UNKNOWN';\nconst unknownsFolderId = folderData.unknowns_folder_id;\nconst pdfFileId = moveResult.id || folderData.temp_pdf_file_id;\n\nconst pdfLink = `https://drive.google.com/file/d/${pdfFileId}/view`;\nconst rootFolderLink = `https://drive.google.com/drive/folders/${rootFolderId}`;\n\nconst emailFrom = emailData.from || 'Unknown Sender';\nconst emailSubject = emailData.subject || 'No Subject';\nconst pdfFilename = folderData.pdf_filename || 'unknown.pdf';\n\nconst timestamp = new Date().toLocaleString('en-US', {\n  timeZone: 'Europe/Berlin',\n  year: 'numeric',\n  month: '2-digit',\n  day: '2-digit',\n  hour: '2-digit',\n  minute: '2-digit',\n  hour12: false\n});\n\nreturn [{\n  json: {\n    to: 'swayclarkeii@gmail.com',\n    pdf_filename: pdfFilename,\n    email_from: emailFrom,\n    email_subject: emailSubject,\n    root_folder_name: rootFolderName,\n    pdf_link: pdfLink,\n    root_folder_link: rootFolderLink,\n    timestamp: timestamp\n  },\n  binary: $input.first().binary\n}];"
        },
        "id": "prepare-email-data-001",
        "name": "Prepare Email Notification Data",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          4368,
          112
        ]
      },
      {
        "parameters": {
          "jsCode": "// Build HTML email body for UNKNOWN client notification\nconst data = $input.first().json;\n\n// Extract just the email address (not the display name)\nconst emailAddress = data.email_from?.value?.[0]?.address || 'Unknown Sender';\n\nconst htmlBody = `<!DOCTYPE html>\n<html>\n<body style=\"font-family: Arial, sans-serif; line-height: 1.6; color: #333;\">\n  <div style=\"max-width: 600px; margin: 0 auto; padding: 20px;\">\n    <h2 style=\"color: #d32f2f;\">‚ö†Ô∏è Unknown Client Document Received</h2>\n    \n    <p>A document was received but the client could not be identified. Manual review is required.</p>\n    \n    <div style=\"background: #f5f5f5; padding: 15px; border-left: 4px solid #1976d2; margin: 20px 0;\">\n      <h3 style=\"margin-top: 0;\">Document Details</h3>\n      <ul style=\"list-style: none; padding: 0;\">\n        <li><strong>Filename:</strong> ${data.pdf_filename}</li>\n        <li><strong>From:</strong> ${emailAddress}</li>\n        <li><strong>Subject:</strong> ${data.email_subject}</li>\n      </ul>\n    </div>\n    \n    <div style=\"background: #fff3e0; padding: 15px; border-left: 4px solid #f57c00; margin: 20px 0;\">\n      <h3 style=\"margin-top: 0;\">üìÇ Created Folder Structure</h3>\n      <p>A temporary folder structure has been created:</p>\n      <ul style=\"list-style: none; padding: 0;\">\n        <li><strong>Root Folder:</strong> ${data.root_folder_name}</li>\n        <li><strong>Document Location:</strong> SONSTIGES/38_Unknowns/</li>\n      </ul>\n    </div>\n    \n    <div style=\"margin: 30px 0;\">\n      <h3>üîó Quick Actions</h3>\n      <div style=\"margin: 10px 0;\">\n        <a href=\"${data.pdf_link}\" \n           style=\"display: inline-block; padding: 12px 24px; background: #1976d2; color: white; text-decoration: none; border-radius: 4px; margin-right: 10px;\">\n          üìÑ View PDF\n        </a>\n        <a href=\"${data.root_folder_link}\" \n           style=\"display: inline-block; padding: 12px 24px; background: #43a047; color: white; text-decoration: none; border-radius: 4px;\">\n          üìÅ Open Folder Structure\n        </a>\n      </div>\n    </div>\n    \n    <div style=\"background: #e3f2fd; padding: 15px; border-left: 4px solid #1976d2; margin: 20px 0;\">\n      <h3 style=\"margin-top: 0;\">‚úÖ Next Steps</h3>\n      <ol>\n        <li>Review the PDF to identify the client</li>\n        <li>Rename the root folder to the correct client name</li>\n        <li>Update the Client_Registry sheet with the correct client name</li>\n        <li>Move the PDF from 38_Unknowns to the appropriate subfolder</li>\n      </ol>\n    </div>\n    \n    <hr style=\"border: none; border-top: 1px solid #ddd; margin: 30px 0;\">\n    \n    <p style=\"font-size: 12px; color: #666;\">\n      <strong>System:</strong> Eugene AMA Document Organizer V4<br>\n      <strong>Timestamp:</strong> ${data.timestamp}\n    </p>\n  </div>\n</body>\n</html>`;\n\nreturn [{\n  json: {\n    ...data,\n    html_body: htmlBody\n  },\n  binary: $input.first().binary\n}];"
        },
        "id": "build-email-html-001",
        "name": "Build Email HTML Body",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          4592,
          112
        ]
      },
      {
        "parameters": {
          "sendTo": "swayclarkeii@gmail.com",
          "subject": "={{ $json.emailSubject || '[ACTION REQUIRED] Unknown Client Document' }}",
          "message": "={{ $json.html_body }}",
          "options": {}
        },
        "id": "send-email-notification-001",
        "name": "Send Email Notification",
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2,
        "position": [
          4816,
          112
        ],
        "webhookId": "e028968d-b3d1-4dd6-bb18-20d1b6594069",
        "credentials": {
          "gmailOAuth2": {
            "id": "aYzk7sZF8ZVyfOan",
            "name": "Gmail account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Format error email data for registry corruption\nconst inputData = $input.all();\n\nconst output = inputData.map(item => {\n  const clientName = item.json.client_name || 'Unknown Client';\n  const fileName = item.json.file_name || 'Unknown File';\n  const emailSubject = item.json.email_subject || 'N/A';\n  const emailFrom = item.json.email_from || 'N/A';\n  const emailDate = item.json.email_date || 'N/A';\n  \n  return {\n    json: {\n      ...item.json,\n      email_to: 'swayclarkeii@gmail.com',\n      email_subject: `[URGENT] Registry Error: ${clientName} - Missing Staging Folder`,\n      email_message: `CRITICAL REGISTRY ERROR DETECTED\n\nClient: ${clientName}\nError Type: Client marked EXISTING but staging_folder_id is MISSING in Client Registry\n\n--- ACTION TAKEN ---\nFile moved to 38_Unknowns folder for manual review\n\n--- ORIGINAL EMAIL DETAILS ---\nSubject: ${emailSubject}\nFrom: ${emailFrom}\nDate: ${emailDate}\nAttachment: ${fileName}\n\n--- NEXT STEPS ---\nPlease:\n1. Open the Client Registry spreadsheet\n2. Find the row for \"${clientName}\"\n3. Add the missing staging_folder_id to column E\n4. Manually move the file from 38_Unknowns to the correct staging folder\n\nThis is a data integrity issue that needs immediate attention.\n\n---\nWorkflow: AMA Pre-Chunk 0\nNode: Registry Error Handler`\n    }\n  };\n});\n\nreturn output;"
        },
        "id": "prepare-registry-error-email-001",
        "name": "Prepare Registry Error Email Data",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3920,
          688
        ]
      },
      {
        "parameters": {
          "sendTo": "={{ $json.email_to }}",
          "subject": "={{ $json.email_subject }}",
          "message": "={{ $json.email_message }}",
          "options": {}
        },
        "id": "send-registry-error-email-001",
        "name": "Send Registry Error Email",
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          4144,
          688
        ],
        "webhookId": "6b7c8ac4-c32d-40d5-b4d0-44a55bc16b79",
        "credentials": {
          "gmailOAuth2": {
            "id": "aYzk7sZF8ZVyfOan",
            "name": "Gmail account"
          }
        }
      },
      {
        "parameters": {
          "operation": "move",
          "fileId": {
            "__rl": true,
            "mode": "id",
            "value": "={{ $json.file_id }}"
          },
          "driveId": {
            "__rl": true,
            "mode": "list",
            "value": "My Drive"
          },
          "folderId": {
            "__rl": true,
            "mode": "list",
            "value": "1qdUu-dIkQR0oDaZKAL_8OhI0jST89_Vu"
          }
        },
        "id": "move-to-unknowns-registry-001",
        "name": "Move to 38_Unknowns (Registry Error)",
        "type": "n8n-nodes-base.googleDrive",
        "typeVersion": 3,
        "position": [
          4368,
          688
        ],
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "a4m50EefR3DJoU0R",
            "name": "Google Drive account"
          }
        }
      },
      {
        "parameters": {
          "operation": "addLabels",
          "messageId": "={{ $json.email_id }}",
          "labelIds": [
            "INBOX"
          ]
        },
        "id": "mark-read-registry-error-001",
        "name": "Mark Email as Read (Registry Error)",
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          4592,
          688
        ],
        "webhookId": "f229ca84-1e69-43a0-90a0-f6ac4544b40f",
        "credentials": {
          "gmailOAuth2": {
            "id": "aYzk7sZF8ZVyfOan",
            "name": "Gmail account"
          }
        }
      },
      {
        "parameters": {},
        "id": "noop-registry-complete-001",
        "name": "NoOp - Registry Error Complete",
        "type": "n8n-nodes-base.noOp",
        "typeVersion": 1,
        "position": [
          4816,
          688
        ]
      },
      {
        "parameters": {
          "jsCode": "// Merge Chunk 0 output with original file data for NEW client path\nconst chunk0Output = $input.first().json;\n\n// Get file_id from Extract File ID & Metadata node (far upstream)\nconst fileMetadata = $('Extract File ID & Metadata').first().json;\n\nreturn [{\n  json: {\n    ...chunk0Output,\n    file_id: fileMetadata.file_id,\n    email_id: fileMetadata.emailId,\n    filename: fileMetadata.filename\n  }\n}];"
        },
        "id": "0180f051-407b-453b-89fc-faaf3439c20d",
        "name": "Merge Chunk 0 Output (NEW)",
        "type": "n8n-nodes-base.code",
        "typeVersion": 1,
        "position": [
          3248,
          304
        ]
      },
      {
        "parameters": {
          "jsCode": "// Get Google Drive upload result from previous node\nconst driveUpload = $input.first().json;\n\n// Retrieve email metadata from Gmail Trigger\nconst emailData = $('Gmail Trigger - Unread with Attachments').first().json;\n\n// Retrieve binary metadata from Gmail Trigger\nconst binaryData = $('Gmail Trigger - Unread with Attachments').first().binary;\n\n// Get first attachment key\nconst attachmentKeys = Object.keys(binaryData);\nconst attachmentKey = attachmentKeys[0];\nconst attachment = binaryData[attachmentKey];\n\n// Extract file extension from filename\nconst fileName = driveUpload.name;\nconst extension = fileName.substring(fileName.lastIndexOf('.') + 1).toLowerCase();\n\n// Get client data from Normalize Client Name node\nconst clientData = $('Normalize Client Name').first().json;\nconst clientName = clientData.client_name || 'unknown';\n\n// Construct stagingPath\nconst stagingPath = `${clientName}/_Staging/${fileName}`;\n\n// Parse file size\nlet fileSizeBytes = 0;\nif (attachment.fileSize) {\n  const sizeStr = attachment.fileSize;\n  const match = sizeStr.match(/^([\\d.]+)\\s*(KB|MB|GB)$/i);\n  if (match) {\n    const value = parseFloat(match[1]);\n    const unit = match[2].toUpperCase();\n    const multipliers = { KB: 1024, MB: 1024 * 1024, GB: 1024 * 1024 * 1024 };\n    fileSizeBytes = Math.round(value * multipliers[unit]);\n  }\n}\n\n// Extract email sender\nlet emailFrom = '';\nif (emailData.from && emailData.from.value && emailData.from.value[0]) {\n  emailFrom = emailData.from.value[0].address;\n}\n\n// ‚úÖ UPDATED v9: Get extracted identifier from Parse Claude Response node (Claude Vision)\nconst extractionData = $('Parse Claude Response').first().json;\nconst extractedText = extractionData.client_name_raw || '';\nconst extractionMethod = extractionData.extractionMethod || 'claude_vision';\nconst extractionModel = extractionData.extractionModel || 'claude-sonnet-4-20250514';\nconst textLength = extractedText.length || 0;\n\n// Build complete Chunk 2 input\nreturn [{\n  json: {\n    fileId: driveUpload.id,\n    fileName: driveUpload.name,\n    mimeType: driveUpload.mimeType,\n    extension: extension,\n    size: fileSizeBytes,\n    emailId: emailData.id,\n    emailFrom: emailFrom,\n    emailSubject: emailData.subject,\n    emailDate: emailData.date,\n    stagingPath: stagingPath,\n    originalFileName: attachment.fileName,\n    extractedFromZip: false,\n    zipFileName: null,\n    client_name: clientData.client_name_raw,\n    client_normalized: clientData.client_name,\n\n    // ‚úÖ UPDATED v9: Pass Claude Vision extracted identifier to Chunk 2\n    extractedText: extractedText,\n    extractionMethod: extractionMethod,\n    extractionModel: extractionModel,\n    textLength: textLength,\n    skipDownload: textLength > 5\n  }\n}];\n"
        },
        "id": "prepare-chunk2-new-001",
        "name": "Prepare for Chunk 2.5 (NEW)",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3696,
          304
        ],
        "notes": "Enriches Google Drive data with email metadata for Chunk 2"
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "value": "okg8wTqLtPUwjQ18",
            "mode": "list",
            "cachedResultName": "Chunk 2.5 - Client Document Tracking (Eugene Document Organizer)"
          },
          "options": {}
        },
        "id": "execute-chunk2-new-001",
        "name": "Execute Chunk 2.5 (NEW)",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.3,
        "position": [
          3920,
          304
        ],
        "notes": "Executes Chunk 2 text extraction workflow"
      },
      {
        "parameters": {
          "operation": "markAsRead",
          "messageId": "={{ $('Gmail Trigger - Unread with Attachments').first().json.id }}"
        },
        "id": "mark-read-new-001",
        "name": "Mark Email as Read (NEW)",
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          4144,
          304
        ],
        "webhookId": "9967ebd9-7776-4d6d-a993-a3c7353a8c26",
        "credentials": {
          "gmailOAuth2": {
            "id": "aYzk7sZF8ZVyfOan",
            "name": "Gmail account"
          }
        },
        "notes": "Marks the processed email as read"
      },
      {
        "parameters": {},
        "id": "noop-new-complete-001",
        "name": "NoOp - NEW Complete",
        "type": "n8n-nodes-base.noOp",
        "typeVersion": 1,
        "position": [
          4368,
          304
        ]
      },
      {
        "parameters": {
          "jsCode": "// Get Google Drive upload result from previous node\nconst driveUpload = $input.first().json;\n\n// Retrieve email metadata from Gmail Trigger\nconst emailData = $('Gmail Trigger - Unread with Attachments').first().json;\n\n// Retrieve binary metadata from Gmail Trigger\nconst binaryData = $('Gmail Trigger - Unread with Attachments').first().binary;\n\n// Get first attachment key\nconst attachmentKeys = Object.keys(binaryData);\nconst attachmentKey = attachmentKeys[0];\nconst attachment = binaryData[attachmentKey];\n\n// Extract file extension from filename\nconst fileName = driveUpload.name;\nconst extension = fileName.substring(fileName.lastIndexOf('.') + 1).toLowerCase();\n\n// Get client data from Normalize Client Name node\nconst clientData = $('Normalize Client Name').first().json;\nconst clientName = clientData.client_name || 'unknown';\n\n// Construct stagingPath\nconst stagingPath = `${clientName}/_Staging/${fileName}`;\n\n// Parse file size\nlet fileSizeBytes = 0;\nif (attachment.fileSize) {\n  const sizeStr = attachment.fileSize;\n  const match = sizeStr.match(/^([\\d.]+)\\s*(KB|MB|GB)$/i);\n  if (match) {\n    const value = parseFloat(match[1]);\n    const unit = match[2].toUpperCase();\n    const multipliers = { KB: 1024, MB: 1024 * 1024, GB: 1024 * 1024 * 1024 };\n    fileSizeBytes = Math.round(value * multipliers[unit]);\n  }\n}\n\n// Extract email sender\nlet emailFrom = '';\nif (emailData.from && emailData.from.value && emailData.from.value[0]) {\n  emailFrom = emailData.from.value[0].address;\n}\n\n// ‚úÖ UPDATED v9: Get extracted identifier from Parse Claude Response node (Claude Vision)\nconst extractionData = $('Parse Claude Response').first().json;\nconst extractedText = extractionData.client_name_raw || '';\nconst extractionMethod = extractionData.extractionMethod || 'claude_vision';\nconst extractionModel = extractionData.extractionModel || 'claude-sonnet-4-20250514';\nconst textLength = extractedText.length || 0;\n\n// Build complete Chunk 2 input\nreturn [{\n  json: {\n    fileId: driveUpload.id,\n    fileName: driveUpload.name,\n    mimeType: driveUpload.mimeType,\n    extension: extension,\n    size: fileSizeBytes,\n    emailId: emailData.id,\n    emailFrom: emailFrom,\n    emailSubject: emailData.subject,\n    emailDate: emailData.date,\n    stagingPath: stagingPath,\n    originalFileName: attachment.fileName,\n    extractedFromZip: false,\n    zipFileName: null,\n    client_name: clientData.client_name_raw,\n    client_normalized: clientData.client_name,\n\n    // ‚úÖ UPDATED v9: Pass Claude Vision extracted identifier to Chunk 2\n    extractedText: extractedText,\n    extractionMethod: extractionMethod,\n    extractionModel: extractionModel,\n    textLength: textLength,\n    skipDownload: textLength > 5\n  }\n}];\n"
        },
        "id": "prepare-chunk2-existing-001",
        "name": "Prepare for Chunk 2.5 (EXISTING)",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          4144,
          496
        ],
        "notes": "Enriches Google Drive data with email metadata for Chunk 2"
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "value": "okg8wTqLtPUwjQ18",
            "mode": "list",
            "cachedResultName": "Chunk 2.5 - Client Document Tracking (Eugene Document Organizer)"
          },
          "options": {}
        },
        "id": "execute-chunk2-existing-001",
        "name": "Execute Chunk 2.5 (EXISTING)",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.3,
        "position": [
          4368,
          496
        ],
        "notes": "Executes Chunk 2 text extraction workflow"
      },
      {
        "parameters": {
          "operation": "markAsRead",
          "messageId": "={{ $('Gmail Trigger - Unread with Attachments').first().json.id }}"
        },
        "id": "mark-read-existing-001",
        "name": "Mark Email as Read (EXISTING)",
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          4592,
          496
        ],
        "webhookId": "64c1fe12-1ad8-47a2-b59a-502812a88c50",
        "credentials": {
          "gmailOAuth2": {
            "id": "aYzk7sZF8ZVyfOan",
            "name": "Gmail account"
          }
        },
        "notes": "Marks the processed email as read"
      },
      {
        "parameters": {},
        "id": "noop-existing-complete-001",
        "name": "NoOp - EXISTING Complete",
        "type": "n8n-nodes-base.noOp",
        "typeVersion": 1,
        "position": [
          4816,
          496
        ]
      },
      {
        "parameters": {
          "operation": "move",
          "fileId": {
            "__rl": true,
            "value": "={{ $json.file_id }}",
            "mode": "id"
          },
          "driveId": {
            "__rl": true,
            "mode": "list",
            "value": "My Drive"
          },
          "folderId": {
            "__rl": true,
            "value": "={{ $json.Staging_Folder_ID }}",
            "mode": "id"
          }
        },
        "id": "b767c01a-345c-4a94-ba35-35f8dda0fb2c",
        "name": "Move PDF to _Staging (NEW)",
        "type": "n8n-nodes-base.googleDrive",
        "typeVersion": 3,
        "position": [
          3472,
          304
        ],
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "a4m50EefR3DJoU0R",
            "name": "Google Drive account"
          }
        }
      },
      {
        "parameters": {
          "operation": "move",
          "fileId": {
            "__rl": true,
            "value": "={{ $json.file_id }}",
            "mode": "id"
          },
          "driveId": {
            "__rl": true,
            "mode": "list",
            "value": "My Drive"
          },
          "folderId": {
            "__rl": true,
            "value": "={{ $json.Staging_Folder_ID }}",
            "mode": "id"
          }
        },
        "id": "90cc99fd-908d-4149-a2f7-35f42ab2e232",
        "name": "Move PDF to _Staging (EXISTING)",
        "type": "n8n-nodes-base.googleDrive",
        "typeVersion": 3,
        "position": [
          3696,
          496
        ],
        "alwaysOutputData": true,
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "a4m50EefR3DJoU0R",
            "name": "Google Drive account"
          }
        }
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "value": "zbxHkXOoD1qaz6OS",
            "mode": "list",
            "cachedResultUrl": "/workflow/zbxHkXOoD1qaz6OS",
            "cachedResultName": "AMA Chunk 0: Folder Initialization (V4 - Parameterized)"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "client_name": "={{ $json.client_name_raw }}",
              "client_normalized": "={{ $json.client_name }}",
              "parent_folder_id": "={{ $('Check Client Exists').item.json.parent_folder_id }}"
            },
            "matchingColumns": [],
            "schema": [
              {
                "id": "client_name",
                "displayName": "client_name",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "client_normalized",
                "displayName": "client_normalized",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "parent_folder_id",
                "displayName": "parent_folder_id",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              }
            ],
            "attemptToConvertTypes": false,
            "convertFieldsToString": true
          },
          "options": {}
        },
        "id": "bc9b052a-1fdf-412c-990a-7c3e58178304",
        "name": "Execute Chunk 0 - Create Folders (UNKNOWN)",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.3,
        "position": [
          3472,
          112
        ]
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "value": "zbxHkXOoD1qaz6OS",
            "mode": "list",
            "cachedResultUrl": "/workflow/zbxHkXOoD1qaz6OS",
            "cachedResultName": "AMA Chunk 0: Folder Initialization (V4 - Parameterized)"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "client_name": "={{ $json.client_name_raw }}",
              "client_normalized": "={{ $json.client_name }}",
              "parent_folder_id": "={{ $('Check Client Exists').item.json.parent_folder_id }}"
            },
            "matchingColumns": [],
            "schema": [
              {
                "id": "client_name",
                "displayName": "client_name",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "client_normalized",
                "displayName": "client_normalized",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "parent_folder_id",
                "displayName": "parent_folder_id",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              }
            ],
            "attemptToConvertTypes": false,
            "convertFieldsToString": true
          },
          "options": {}
        },
        "id": "execute-chunk0-001",
        "name": "Execute Chunk 0 - Create Folders (NEW)",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.3,
        "position": [
          3024,
          304
        ]
      },
      {
        "parameters": {
          "amount": 3
        },
        "id": "wait-staging-existing-001",
        "name": "Wait After Staging (EXISTING)",
        "type": "n8n-nodes-base.wait",
        "typeVersion": 1.1,
        "position": [
          3920,
          496
        ],
        "executeOnce": false,
        "alwaysOutputData": true,
        "webhookId": "6d74a0e2-74ef-411a-83f9-c98a972b25df"
      },
      {
        "parameters": {
          "jsCode": "const crypto = require('crypto');\n\n// Google Service Account credentials\nconst serviceAccount = {\n  projectId: 'n8n-integrations-482020',\n  clientEmail: 'n8n-document-ai@n8n-integrations-482020.iam.gserviceaccount.com',\n  privateKey: `-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCwWo8CBWPs5tvS\nP01jLTf6Rc54JrOCEU1KIOpkZryrT082kD/eXx73unpLGUCb9t5u9kjCjiU8BPMp\nqnPQSCVzeuMNWLYcyQfGIUFRfCSi/7bg5q1mwv+DkLsgNWx0mRAk5pfPCv9qW9qk\n+XyNYtqk3FlgWBRtynwd49cCN1FoaRgTQTv6KsRtqV7nc6MyE+VyyhMY64uoQfCN\nd+PrXkE20yDaNg/yZU/re3/2kqeWVt3F5nxZFbuM2wBof0wLQcqkZ/ggN9/C/zdp\nBpTnZlTadNzjPePKGBaMHyDP01/E4xUU9d9TJMM4OWc5ReFIMlSdYnzjhuir1+5A\no2JmvpmRAgMBAAECggEADZAkGC4H8wwHnfzmW8P6M9Jd6xm24UBUEb5u/c0fojaV\noLGpZ9XS+48o9qZONMXgx5HuI0sWtq3+xuvoFP280PaDiImTv/+qDGU5sSWmFQSB\nBn0B8GRQ4x0kzHkEtVb29I+TigXjgkTm5PHserHpSkKe0Re/wniPNnvzvk+OKu8W\nvnSleUP8NamyIxoMRZNWYdUI/yJvU6o2nuxZKe6aVvaF2T3eQ/3pYucvfgsV7L1i\nkle6T//NjEmrpeFtZEAgrnAAWLso7R+pbN08zc3Jbxb5Q1E6WABlTi6gbI9tmwuu\n53pe1GY4AGNpfGUiIO/UX/R+9/DSYCMrQMhqTdD8fQKBgQDptBqfAmcDgC9hFkSA\nopIxslCCsQ56eXTyZ0BL+qQiFyhQFmV3Do4vVLatJvZiUIWonNYxZYfxEMP06dW+\nk/Bu4NAoSc46wlvY1Bj9xOn7s/afNlY4J0YKrSpIuqQZHyhjERvK7Nn1UHDZ92qJ\nFXvaNJ0uUUYry5xuYrbwrfECKwKBgQDBLcNJsXKVYmaMh/xkucAKeeOWy/ME2kZz\noyEFcmgQhKU0Sr7C0OdLE3JnlL+9oz0ashBPb06Y0vsqDzl+0iwU81oc1RD/wBZz\nBgV2NB0jYvsIHFkI4BY5p4fePF5Q97UCaGttBf3JL1fFFeif/r1Rq2FbAnnpXsqF\npHrOFKsBMwKBgQC6CmjiyhvNWp7c78gKiuBMdYHH+EDpWISzb2Rs15MPnFW4I4wU\nUd74aLyfbJPYwfcUuf19BzFHwyvrbLZ95vEQoyCx4cctWYmaO4XFhpsphyK9rZjH\nTORiHWW6zfFSGk6hRn5UdWYw9h9QNLh3dkXI9/dkZsiwln7qFOVDBYUFTwKBgC7r\nnJlTnk8mXV4Y0XbtnvVscZj45IfzNFV189lM1nXcofu3g+nxr5wOlyUNfhzjfz3y\nrf99O4vnAtZOaFqjVc2o5eRG5CAaWdmKRt1U/xbPPcXUjNOZCgzq4hdadlYYNEDn\nd+A9Kk0pUJowHhZuWzFw/O6MBWxnd61KLAHOB1L9AoGARwyJIEwHeUeoAuCRlQyS\nxYzI8eMIDJ7HSiaFms+j8cuNy76O9U5E0KVBz6BEeTfq+aym0vyZ6iKJ3+q/IXQ4\no5jc6G6zgrMAgeuKzKFEwKNK/tm5j3FiDEzcUqLI00AfdG/f+QI/dTxbqnlB1tPn\nT0v0rf9bjMnUWoH9kXFM+XA=\n-----END PRIVATE KEY-----`\n};\n\n// Step 1: Create JWT token\nconst now = Math.floor(Date.now() / 1000);\nconst jwtHeader = {\n  alg: 'RS256',\n  typ: 'JWT'\n};\n\nconst jwtClaims = {\n  iss: serviceAccount.clientEmail,\n  scope: 'https://www.googleapis.com/auth/cloud-platform',\n  aud: 'https://oauth2.googleapis.com/token',\n  exp: now + 3600,\n  iat: now\n};\n\n// Encode header and claims\nconst base64UrlEncode = (str) => {\n  return Buffer.from(str)\n    .toString('base64')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '');\n};\n\nconst encodedHeader = base64UrlEncode(JSON.stringify(jwtHeader));\nconst encodedClaims = base64UrlEncode(JSON.stringify(jwtClaims));\nconst signatureInput = `${encodedHeader}.${encodedClaims}`;\n\n// Sign with private key using crypto module\nconst sign = crypto.createSign('RSA-SHA256');\nsign.update(signatureInput);\nconst signature = sign.sign(serviceAccount.privateKey, 'base64')\n  .replace(/\\+/g, '-')\n  .replace(/\\//g, '_')\n  .replace(/=/g, '');\n\nconst jwt = `${signatureInput}.${signature}`;\n\n// Step 2: Exchange JWT for access token\nconst tokenResponse = await this.helpers.httpRequest({\n  method: 'POST',\n  url: 'https://oauth2.googleapis.com/token',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded'\n  },\n  body: `grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer&assertion=${jwt}`\n});\n\nconst accessToken = tokenResponse.access_token;\n\n// Step 3: Get PDF binary and convert to base64\nconst item = $input.first();\nconst binaryKey = Object.keys(item.binary)[0];\nconst buffer = await this.helpers.getBinaryDataBuffer(0, binaryKey);\nconst base64Content = buffer.toString('base64');\n\n// Step 4: Prepare Document AI request body\nconst documentAiRequest = {\n  rawDocument: {\n    content: base64Content,\n    mimeType: 'application/pdf'\n  }\n};\n\n// Return access token, request body, and original data\nreturn {\n  json: {\n    ...item.json,\n    accessToken: accessToken,\n    documentAiRequest: documentAiRequest\n  },\n  binary: item.binary\n};"
        },
        "id": "prepare-docai-request-001",
        "name": "Prepare Document AI Request",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1008,
          400
        ],
        "disabled": true
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://eu-documentai.googleapis.com/v1/projects/504943079120/locations/eu/processors/954baa10f2e87364:process",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Authorization",
                "value": "=Bearer {{ $json.accessToken }}"
              },
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify($json.documentAiRequest) }}",
          "options": {}
        },
        "id": "call-docai-ocr-001",
        "name": "Call Document AI OCR",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.3,
        "position": [
          1232,
          400
        ],
        "disabled": true,
        "notes": "Google Document AI OCR\n\nProcessor: 954baa10f2e87364\nRegion: eu\nProject: n8n-integrations-482020"
      },
      {
        "parameters": {
          "jsCode": "// Parse Google Document AI response\nconst item = $input.first();\nconst docAiResponse = item.json;\n\nlet extractedText = '';\nlet pageCount = 0;\n\n// Extract text from Document AI response\nif (docAiResponse.document && docAiResponse.document.text) {\n  extractedText = docAiResponse.document.text;\n  pageCount = docAiResponse.document.pages ? docAiResponse.document.pages.length : 0;\n}\n\n// Get original data from upstream node (Download PDF from Drive)\nconst originalData = $('Download PDF from Drive').first().json;\n\nreturn {\n  json: {\n    ...originalData,\n    extractedText: extractedText.trim(),\n    ocrSuccess: extractedText.length > 0,\n    ocrEngine: 'Google Document AI',\n    pageCount: pageCount\n  },\n  binary: item.binary\n};"
        },
        "id": "parse-docai-response-001",
        "name": "Parse Document AI Response",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1456,
          400
        ],
        "disabled": true
      },
      {
        "parameters": {
          "jsCode": "const item = $input.first();\nconst binaryKey = Object.keys(item.binary)[0];\nconst buffer = await this.helpers.getBinaryDataBuffer(0, binaryKey);\nconst base64Content = buffer.toString('base64');\nconst mimeType = item.json.mimeType || 'application/pdf';\n\nreturn {\n  json: {\n    ...item.json,\n    imageData: {\n      type: 'base64',\n      media_type: mimeType,\n      data: base64Content\n    }\n  },\n  binary: item.binary\n};"
        },
        "id": "convert-pdf-base64-001",
        "name": "Convert PDF to Base64",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1232,
          208
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://api.anthropic.com/v1/messages",
          "authentication": "predefinedCredentialType",
          "nodeCredentialType": "anthropicApi",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "x-api-key",
                "value": "={{ $credentials.anthropicApi.apiKey }}"
              },
              {
                "name": "anthropic-version",
                "value": "2023-06-01"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ $json.claudeApiBody }}",
          "options": {}
        },
        "id": "claude-vision-extract-001",
        "name": "Claude Vision Extract Identifier",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          1680,
          208
        ],
        "credentials": {
          "httpHeaderAuth": {
            "id": "vfoYopBRX35Znmq6",
            "name": "Anthropic API key"
          },
          "anthropicApi": {
            "id": "MRSNO4UW3OEIA3tQ",
            "name": "Anthropic account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "const item = $input.first();\nconst response = item.json;\n\n// Get Claude's response text\nlet rawResponse = response.content[0].text.trim();\n\n// Extract just the identifier from verbose responses\nlet identifier = rawResponse;\n\n// Pattern 1: Look for \"‚Üí identifier\" format (Claude's normalization output)\nconst arrowMatch = rawResponse.match(/‚Üí\\s*([^\\n*]+)/);\nif (arrowMatch) {\n  identifier = arrowMatch[1].trim();\n}\n// Pattern 2: Look for quoted identifier\nelse if (rawResponse.includes('\"')) {\n  const quoteMatch = rawResponse.match(/\"([^\"]+)\"/);\n  if (quoteMatch) {\n    identifier = quoteMatch[1].trim();\n  }\n}\n// Pattern 3: If response has multiple lines, take the last non-empty line\nelse if (rawResponse.includes('\\n')) {\n  const lines = rawResponse.split('\\n').filter(line => line.trim().length > 0);\n  identifier = lines[lines.length - 1].trim();\n  \n  // Remove common prefixes\n  identifier = identifier.replace(/^[-*‚Ä¢]\\s*/, ''); // Remove bullet points\n  identifier = identifier.replace(/^\\d+\\.\\s*/, ''); // Remove numbering\n  identifier = identifier.replace(/^[*_]+$/, ''); // Remove markdown formatting\n}\n\n// Clean up any remaining markdown or formatting\nidentifier = identifier.replace(/\\*\\*/g, ''); // Remove bold\nidentifier = identifier.replace(/\\*/g, ''); // Remove italics\nidentifier = identifier.replace(/^[:\\-]\\s*/, ''); // Remove leading colons/dashes\n\n// Final validation\nif (!identifier || identifier.length < 2 || identifier.length > 100) {\n  identifier = 'UNKNOWN';\n}\n\n// Get original data from upstream (Download PDF node)\nconst originalData = $('Download PDF from Drive').first().json;\n\nreturn {\n  json: {\n    ...originalData,\n    client_name_raw: identifier,\n    extractionMethod: 'claude_vision',\n    extractionModel: 'claude-sonnet-4-20250514',\n    rawClaudeResponse: rawResponse.substring(0, 500) // Keep first 500 chars for debugging\n  }\n};\n"
        },
        "id": "parse-claude-response-001",
        "name": "Parse Claude Response",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1904,
          208
        ]
      },
      {
        "parameters": {
          "jsCode": "// Get the input data\nconst item = $input.first();\n\n// Full BPS-structured prompt (no escaping needed in JS template literal)\nconst prompt = `# Role\n\nYou are an expert German real estate document analyst specializing in project identification and entity normalization. Your expertise combines deep knowledge of German property development nomenclature, legal entity structures, and addressing conventions. You operate with precision and consistency, extracting identifiers that align with project-based organizational hierarchies.\n\n---\n\n# Task\n\nExtract the single most appropriate identifier from the provided German real estate document by following this sequence:\n\n1. **Scan** - Review the document for all potential identifiers (project names, company names, addresses)\n2. **Prioritize** - Apply the priority hierarchy to select the primary identifier\n3. **Normalize** - Transform the raw identifier using German character and suffix rules\n4. **Validate** - Ensure output contains ONLY the normalized identifier\n5. **Return** - Output the final identifier text with no additional formatting\n\n---\n\n# Specifics\n\n**Priority Hierarchy (return FIRST match found):**\n\n1. **Project code or name** (e.g., 'BV Propos' ‚Üí 'Propos', 'Villa Martens', 'Projekt Schlossberg')\n2. **Company or client name** (e.g., 'VAH Immobilien' ‚Üí 'VAH', 'Propos GmbH' ‚Üí 'Propos')\n3. **Street address ONLY as last resort** (e.g., 'Adolf-Martens-Stra√üe 10' ‚Üí 'Adolf-Martens 10')\n\n**Normalization Rules:**\n\n- German character conversion: √ü ‚Üí ss, √§ ‚Üí ae, √∂ ‚Üí oe, √º ‚Üí ue\n- Suffix removal: Strip 'GmbH', 'AG', 'KG', 'stra√üe', 'str.'\n- Extract core name only\n\n**Output Format:**\n\n- Return ONLY the normalized identifier\n- NO explanations, NO formatting, NO bullet points, NO prefixes\n- Plain text identifier only\n- If no identifier found, return exactly: UNKNOWN\n\n**Forbidden Output Patterns:**\n\n- Explanatory text (e.g., \"The project is...\")\n- Numbered lists (e.g., \"1. Project: ...\")\n- Parenthetical notes (e.g., \"Propos (from BV Propos GmbH)\")\n- Metadata or confidence scores\n\n---\n\n# Context\n\nThis extraction powers Eugene's project-based document routing system for AMA Capital. The identifier you extract determines which folder structure receives the document in Google Drive.\n\n**Why this matters:**\n\n- **Project-centric organization**: Eugene organizes deals by project (e.g., \"BV Propos\"), not by property address. One project can span multiple properties.\n- **Document grouping**: All documents for the same project must route to a single folder, even if they mention different addresses.\n- **Business logic alignment**: Prioritizing projects over addresses prevents document scatter (e.g., 3 addresses = 3 folders vs 1 project = 1 folder).\n\n**Impact of correct extraction:**\n\n- Enables automated folder creation and document routing\n- Reduces manual filing and searching\n- Maintains project integrity across multi-property deals\n\n---\n\n# Examples\n\n### Example 1: Project Name Found\n\n**Document content:** \"Bauvorhaben Propos - Schlo√übergstra√üe 13, 79189 Bad Krozingen\"\n\n**Identifiers detected:**\n- Project: \"BV Propos\", \"Bauvorhaben Propos\"\n- Address: \"Schlo√übergstra√üe 13\"\n\n**Priority applied:** Project code/name (Priority #1)\n\n**Normalized output:** \\`Propos\\`\n\n---\n\n### Example 2: Company Name Only\n\n**Document content:** \"VAH Immobilien GmbH - Objektverwaltung\"\n\n**Identifiers detected:**\n- Company: \"VAH Immobilien GmbH\"\n- No project code found\n\n**Priority applied:** Company/client name (Priority #2)\n\n**Normalized output:** \\`VAH\\`\n\n---\n\n### Example 3: Address as Fallback\n\n**Document content:** \"Energiebedarfsausweis f√ºr Adolf-Martens-Stra√üe 10\"\n\n**Identifiers detected:**\n- Address: \"Adolf-Martens-Stra√üe 10\"\n- No project or company found\n\n**Priority applied:** Street address (Priority #3 - last resort)\n\n**Normalized output:** \\`Adolf-Martens 10\\`\n\n---\n\n### Example 4: No Identifier Found\n\n**Document content:** \"Allgemeine Gesch√§ftsbedingungen\"\n\n**Identifiers detected:** None\n\n**Normalized output:** \\`UNKNOWN\\`\n\n---\n\n### Example 5: CORRECT vs INCORRECT Outputs\n\n‚úÖ **CORRECT responses:**\n- \\`Propos\\`\n- \\`Villa Martens\\`\n- \\`VAH\\`\n- \\`Adolf-Martens 10\\`\n- \\`UNKNOWN\\`\n\n‚ùå **INCORRECT responses (violate output format):**\n- \\`\"The project is Propos\"\\` ‚Üê has explanation\n- \\`\"1. Project: Propos\"\\` ‚Üê has numbering\n- \\`\"Propos (from BV Propos GmbH)\"\\` ‚Üê has parenthetical\n\n---\n\n# Notes\n\n**Critical Enforcement:**\n\n- Return ONLY the normalized identifier as plain text - no exceptions\n- Apply priority hierarchy strictly: Project ‚Üí Company ‚Üí Address\n- Never skip normalization rules (German characters, suffix removal)\n- Never add explanations, formatting, or metadata to output\n\n**Guardrails:**\n\n- If multiple identifiers at same priority level exist, choose the most prominent/repeated one\n- Addresses are LAST RESORT - only use when no project or company name exists\n- \"UNKNOWN\" is a valid response - use it when truly no identifier can be extracted\n- Never hallucinate or invent identifiers not present in the document\n\n**Edge Case Handling:**\n\n- Mixed languages: Prioritize German identifiers over English ones\n- Abbreviations: Keep common abbreviations (e.g., \"BV\" for Bauvorhaben)\n- Multiple projects mentioned: Choose the primary/first-mentioned project\n- Scanned/low-quality text: Extract best-effort identifier or return UNKNOWN\n\n**Remember:** This identifier directly controls document routing. Precision and consistency are paramount. When in doubt between two identifiers at the same priority level, choose the one that appears most frequently or prominently in the document.`;\n\n// Build the API request body\nconst apiBody = {\n  model: \"claude-sonnet-4-20250514\",\n  max_tokens: 50,\n  messages: [\n    {\n      role: \"user\",\n      content: [\n        {\n          type: \"document\",\n          source: {\n            type: \"base64\",\n            media_type: item.json.imageData.media_type,\n            data: item.json.imageData.data\n          }\n        },\n        {\n          type: \"text\",\n          text: prompt\n        }\n      ]\n    }\n  ]\n};\n\nreturn {\n  json: {\n    ...item.json,\n    claudeApiBody: apiBody\n  }\n};"
        },
        "id": "build-claude-request-001",
        "name": "Build Claude API Request",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1456,
          208
        ]
      }
    ],
    "connections": {
      "Gmail Trigger - Unread with Attachments": {
        "main": [
          [
            {
              "node": "Filter PDF/ZIP Attachments",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Filter PDF/ZIP Attachments": {
        "main": [
          [
            {
              "node": "Upload PDF to Temp Folder",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Upload PDF to Temp Folder": {
        "main": [
          [
            {
              "node": "Extract File ID & Metadata",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract File ID & Metadata": {
        "main": [
          [
            {
              "node": "Download PDF from Drive",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Download PDF from Drive": {
        "main": [
          [
            {
              "node": "Convert PDF to Base64",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract Text from PDF": {
        "main": [
          [
            {
              "node": "Evaluate Extraction Quality",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Evaluate Extraction Quality": {
        "main": [
          [
            {
              "node": "AI Extract Client Name",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "AI Extract Client Name": {
        "main": [
          [
            {
              "node": "Normalize Client Name",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Normalize Client Name": {
        "main": [
          [
            {
              "node": "Lookup Client Registry",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Lookup Client Registry": {
        "main": [
          [
            {
              "node": "Check Client Exists",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check Client Exists": {
        "main": [
          [
            {
              "node": "Decision Gate",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Decision Gate": {
        "main": [
          [
            {
              "node": "Handle Unidentified Client",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Execute Chunk 0 - Create Folders (NEW)",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Lookup Staging Folder",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare UNKNOWN Client Data": {
        "main": [
          [
            {
              "node": "Execute Chunk 0 - Create Folders (UNKNOWN)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Lookup Staging Folder": {
        "main": [
          [
            {
              "node": "Filter Staging Folder ID",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Filter Staging Folder ID": {
        "main": [
          [
            {
              "node": "Check Routing Decision",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract 38_Unknowns Folder ID": {
        "main": [
          [
            {
              "node": "Validate Folder IDs",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Validate Folder IDs": {
        "main": [
          [
            {
              "node": "Move PDF to 38_Unknowns",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Move PDF to 38_Unknowns": {
        "main": [
          [
            {
              "node": "Prepare Email Notification Data",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Email Notification Data": {
        "main": [
          [
            {
              "node": "Build Email HTML Body",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Email HTML Body": {
        "main": [
          [
            {
              "node": "Send Email Notification",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Handle Unidentified Client": {
        "main": [
          [
            {
              "node": "Prepare UNKNOWN Client Data",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check Routing Decision": {
        "main": [
          [
            {
              "node": "Prepare Missing Folder Error",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Move PDF to _Staging (EXISTING)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Missing Folder Error": {
        "main": [
          [
            {
              "node": "Prepare Registry Error Email Data",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Registry Error Email Data": {
        "main": [
          [
            {
              "node": "Send Registry Error Email",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Send Registry Error Email": {
        "main": [
          [
            {
              "node": "Move to 38_Unknowns (Registry Error)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Move to 38_Unknowns (Registry Error)": {
        "main": [
          [
            {
              "node": "Mark Email as Read (Registry Error)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Mark Email as Read (Registry Error)": {
        "main": [
          [
            {
              "node": "NoOp - Registry Error Complete",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Merge Chunk 0 Output (NEW)": {
        "main": [
          [
            {
              "node": "Move PDF to _Staging (NEW)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare for Chunk 2.5 (NEW)": {
        "main": [
          [
            {
              "node": "Execute Chunk 2.5 (NEW)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Execute Chunk 2.5 (NEW)": {
        "main": [
          [
            {
              "node": "Mark Email as Read (NEW)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Mark Email as Read (NEW)": {
        "main": [
          [
            {
              "node": "NoOp - NEW Complete",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare for Chunk 2.5 (EXISTING)": {
        "main": [
          [
            {
              "node": "Execute Chunk 2.5 (EXISTING)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Execute Chunk 2.5 (EXISTING)": {
        "main": [
          [
            {
              "node": "Mark Email as Read (EXISTING)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Mark Email as Read (EXISTING)": {
        "main": [
          [
            {
              "node": "NoOp - EXISTING Complete",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Move PDF to _Staging (NEW)": {
        "main": [
          [
            {
              "node": "Prepare for Chunk 2.5 (NEW)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Execute Chunk 0 - Create Folders (UNKNOWN)": {
        "main": [
          [
            {
              "node": "Extract 38_Unknowns Folder ID",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Execute Chunk 0 - Create Folders (NEW)": {
        "main": [
          [
            {
              "node": "Merge Chunk 0 Output (NEW)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Move PDF to _Staging (EXISTING)": {
        "main": [
          [
            {
              "node": "Wait After Staging (EXISTING)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Wait After Staging (EXISTING)": {
        "main": [
          [
            {
              "node": "Prepare for Chunk 2.5 (EXISTING)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Document AI Request": {
        "main": [
          [
            {
              "node": "Call Document AI OCR",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Call Document AI OCR": {
        "main": [
          [
            {
              "node": "Parse Document AI Response",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Document AI Response": {
        "main": [
          [
            {
              "node": "Evaluate Extraction Quality",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Claude Vision Extract Identifier": {
        "main": [
          [
            {
              "node": "Parse Claude Response",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Claude Response": {
        "main": [
          [
            {
              "node": "Normalize Client Name",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Convert PDF to Base64": {
        "main": [
          [
            {
              "node": "Build Claude API Request",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Claude API Request": {
        "main": [
          [
            {
              "node": "Claude Vision Extract Identifier",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "settings": {
      "executionOrder": "v1",
      "callerPolicy": "workflowsFromSameOwner",
      "availableInMCP": false
    },
    "staticData": {
      "node:Gmail Trigger - Unread with Attachments": {
        "Gmail Trigger - Unread with Attachments": {
          "lastTimeChecked": 1768780048,
          "possibleDuplicates": [
            "19bd381b325164a8"
          ]
        }
      }
    },
    "meta": {
      "templateCredsSetupCompleted": true
    },
    "pinData": {},
    "versionId": "874db1e3-121a-4b49-98ce-96765cd5fb0b",
    "activeVersionId": "874db1e3-121a-4b49-98ce-96765cd5fb0b",
    "versionCounter": 652,
    "triggerCount": 1,
    "shared": [
      {
        "updatedAt": "2026-01-07T09:49:33.855Z",
        "createdAt": "2026-01-07T09:49:33.855Z",
        "role": "workflow:owner",
        "workflowId": "YGXWjWcBIk66ArvT",
        "projectId": "Rs8mhw052fnrzWZM",
        "project": {
          "updatedAt": "2025-12-31T15:54:29.115Z",
          "createdAt": "2025-12-31T15:27:33.865Z",
          "id": "Rs8mhw052fnrzWZM",
          "name": "Sway Clarke <sway@oloxa.ai>",
          "type": "personal",
          "icon": null,
          "description": null,
          "creatorId": "e9bd9112-c2e3-4f67-873a-e1001baeafd8",
          "projectRelations": [
            {
              "updatedAt": "2025-12-31T15:27:33.865Z",
              "createdAt": "2025-12-31T15:27:33.865Z",
              "userId": "e9bd9112-c2e3-4f67-873a-e1001baeafd8",
              "projectId": "Rs8mhw052fnrzWZM",
              "user": {
                "updatedAt": "2026-01-18T23:09:34.051Z",
                "createdAt": "2025-12-31T15:27:33.119Z",
                "id": "e9bd9112-c2e3-4f67-873a-e1001baeafd8",
                "email": "sway@oloxa.ai",
                "firstName": "Sway",
                "lastName": "Clarke",
                "personalizationAnswers": {
                  "version": "v4",
                  "personalization_survey_submitted_at": "2025-12-31T15:54:37.562Z",
                  "personalization_survey_n8n_version": "2.1.4"
                },
                "settings": {
                  "userActivated": true,
                  "easyAIWorkflowOnboarded": true,
                  "firstSuccessfulWorkflowId": "zbxHkXOoD1qaz6OS",
                  "userActivatedAt": 1767398053308,
                  "npsSurvey": {
                    "responded": true,
                    "lastShownAt": 1767684846804
                  }
                },
                "disabled": false,
                "mfaEnabled": false,
                "lastActiveAt": "2026-01-18",
                "isPending": false
              }
            }
          ]
        }
      }
    ],
    "tags": [],
    "activeVersion": {
      "updatedAt": "2026-01-18T23:35:28.266Z",
      "createdAt": "2026-01-18T23:26:12.372Z",
      "versionId": "874db1e3-121a-4b49-98ce-96765cd5fb0b",
      "workflowId": "YGXWjWcBIk66ArvT",
      "nodes": [
        {
          "parameters": {
            "pollTimes": {
              "item": [
                {
                  "mode": "everyMinute"
                }
              ]
            },
            "simple": false,
            "filters": {
              "labelIds": [
                "INBOX",
                "UNREAD",
                "Label_8011160688574026773"
              ],
              "q": "has:attachment"
            },
            "options": {
              "dataPropertyAttachmentsPrefixName": "attachment_",
              "downloadAttachments": true
            }
          },
          "id": "gmail-trigger-001",
          "name": "Gmail Trigger - Unread with Attachments",
          "type": "n8n-nodes-base.gmailTrigger",
          "typeVersion": 1.3,
          "position": [
            112,
            208
          ],
          "credentials": {
            "gmailOAuth2": {
              "id": "aYzk7sZF8ZVyfOan",
              "name": "Gmail account"
            }
          }
        },
        {
          "parameters": {
            "jsCode": "// Filter PDF and ZIP attachments only\nconst items = $input.all();\nconst filtered = [];\n\nfor (const item of items) {\n  // Gmail trigger stores attachments in item.binary, not item.json.attachments\n  if (!item.binary) continue;\n  \n  // Iterate over binary keys (attachment_0, attachment_1, etc.)\n  for (const [key, attachment] of Object.entries(item.binary)) {\n    const filename = attachment.fileName;\n    if (!filename) continue;\n    \n    const ext = filename.toLowerCase().split('.').pop();\n    \n    if (['pdf', 'zip'].includes(ext)) {\n      filtered.push({\n        json: {\n          emailId: item.json.id,\n          emailSubject: item.json.Subject || item.json.subject,\n          emailFrom: item.json.From || item.json.from,\n          emailDate: item.json.date,\n          attachmentKey: key,\n          filename: filename,\n          mimeType: attachment.mimeType,\n          size: attachment.fileSize\n        },\n        binary: {\n          data: attachment\n        }\n      });\n    }\n  }\n}\n\nreturn filtered;"
          },
          "id": "filter-attachments-001",
          "name": "Filter PDF/ZIP Attachments",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            336,
            208
          ]
        },
        {
          "parameters": {
            "driveId": {
              "__rl": true,
              "mode": "list",
              "value": "My Drive"
            },
            "folderId": {
              "__rl": true,
              "mode": "list",
              "value": "root",
              "cachedResultName": "/ (Root folder)"
            },
            "options": {}
          },
          "id": "upload-pdf-gdrive-001",
          "name": "Upload PDF to Temp Folder",
          "type": "n8n-nodes-base.googleDrive",
          "typeVersion": 3,
          "position": [
            560,
            208
          ],
          "credentials": {
            "googleDriveOAuth2Api": {
              "id": "a4m50EefR3DJoU0R",
              "name": "Google Drive account"
            }
          }
        },
        {
          "parameters": {
            "jsCode": "// Extract Google Drive file ID from upload response and preserve email metadata\nconst uploadResult = $input.first().json;\nconst emailData = $('Filter PDF/ZIP Attachments').first().json;\n\nreturn [{\n  json: {\n    file_id: uploadResult.id,\n    filename: uploadResult.name,\n    emailId: emailData.emailId,\n    emailSubject: emailData.emailSubject,\n    emailFrom: emailData.emailFrom,\n    emailDate: emailData.emailDate\n  }\n}];"
          },
          "id": "extract-file-id-001",
          "name": "Extract File ID & Metadata",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            784,
            208
          ]
        },
        {
          "parameters": {
            "operation": "download",
            "fileId": {
              "__rl": true,
              "mode": "id",
              "value": "={{ $json.file_id }}"
            },
            "options": {}
          },
          "id": "download-pdf-from-gdrive-001",
          "name": "Download PDF from Drive",
          "type": "n8n-nodes-base.googleDrive",
          "typeVersion": 3,
          "position": [
            1008,
            208
          ],
          "credentials": {
            "googleDriveOAuth2Api": {
              "id": "a4m50EefR3DJoU0R",
              "name": "Google Drive account"
            }
          }
        },
        {
          "parameters": {
            "operation": "pdf",
            "options": {
              "joinPages": true,
              "keepSource": "json"
            }
          },
          "id": "extract-text-001",
          "name": "Extract Text from PDF",
          "type": "n8n-nodes-base.extractFromFile",
          "typeVersion": 1.1,
          "position": [
            1456,
            592
          ],
          "disabled": true,
          "notes": "‚ö†Ô∏è OLD METHOD - Disabled. Use 'Prepare Document AI Request' path instead for proper OCR."
        },
        {
          "parameters": {
            "jsCode": "// V4: Evaluate extraction quality for each PDF\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  // FIX: Check both extractedText (from OCR) and text (from digital extraction)\n  const extractedText = item.json.extractedText || item.json.text || '';\n  const wordCount = extractedText.trim().split(/\\s+/).length;\n\n  results.push({\n    json: {\n      ...item.json,\n      wordCount: wordCount,\n      needsOCR: wordCount < 10,\n      extractionQuality: wordCount < 10 ? 'poor' : 'good',\n      \n      // Keep extracted text for downstream use\n      extractedText: extractedText,\n      textLength: extractedText.trim().length,\n      extractionMethod: 'digital_pre_chunk'\n    },\n    binary: item.binary\n  });\n}\n\nreturn results;"
          },
          "id": "evaluate-extraction-001",
          "name": "Evaluate Extraction Quality",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            1680,
            400
          ],
          "disabled": true
        },
        {
          "parameters": {
            "resource": "chat",
            "chatModel": "gpt-4.1-mini",
            "prompt": {
              "messages": [
                {
                  "role": "system",
                  "content": "Extract the PROJECT or PROPERTY IDENTIFIER from this German real estate document.\n\nValid identifiers (in order of priority):\n\n1. STREET ADDRESS + CITY (MOST COMMON IN THESE DOCUMENTS):\n   - \"Schlo√übergstra√üe 13, T√ºbingen\" ‚Üí \"Schlossberg 13\"\n   - \"Schlo√übergstr. 13\" ‚Üí \"Schlossberg 13\"\n   - Normalize: Remove \"stra√üe/str.\", keep number\n\n2. PROJECT CODES/ABBREVIATIONS:\n   - \"BV Propos\" ‚Üí \"Propos\"\n   - \"Projekt Schlo√überg\" ‚Üí \"Schlossberg\"\n\n3. PROPERTY/VILLA NAMES\n\n4. COMPANY NAMES (if property-related)\n\n5. PERSON/RECIPIENT NAMES (last resort)\n\nEXTRACTION RULES:\n- Look for street addresses FIRST\n- \"Schlo√überg\" and \"Schlossberg\" are the same (normalize to \"Schlossberg\")\n- Combine street name + number: \"Schlo√übergstra√üe 13\" ‚Üí \"Schlossberg 13\"\n\nReturn ONLY the normalized identifier, nothing else.\nIf no identifiable project/property exists, return exactly: UNKNOWN"
                },
                {
                  "content": "={{ $json.extractedText }}"
                }
              ]
            },
            "options": {},
            "requestOptions": {}
          },
          "id": "ai-extract-client-001",
          "name": "AI Extract Client Name",
          "type": "n8n-nodes-base.openAi",
          "typeVersion": 1.1,
          "position": [
            1904,
            400
          ],
          "credentials": {
            "openAiApi": {
              "id": "xmJ7t6kaKgMwA1ce",
              "name": "OpenAi account"
            }
          },
          "disabled": true
        },
        {
          "parameters": {
            "jsCode": "// Get all input items\nconst items = $input.all();\nconst results = [];\n\n// Process each item\nfor (const item of items) {\n  let clientNameRaw = '';\n  \n  // Extract client name from input\n  // Priority 1: client_name_raw field (from Parse Claude Response - Claude Vision)\n  if (item.json && item.json.client_name_raw) {\n    clientNameRaw = String(item.json.client_name_raw);\n  }\n  // Priority 2: OpenAI Chat API (unsimplified): choices[0].message.content\n  else if (item.json && item.json.choices && item.json.choices[0] && item.json.choices[0].message) {\n    clientNameRaw = String(item.json.choices[0].message.content);\n  }\n  // Priority 3: OpenAI Chat API (simplified): message.content\n  else if (item.json && item.json.message && item.json.message.content) {\n    clientNameRaw = String(item.json.message.content);\n  }\n  // Priority 4: Text API (simplified): text\n  else if (item.json && item.json.text) {\n    clientNameRaw = String(item.json.text);\n  }\n  \n  clientNameRaw = clientNameRaw.trim();\n  \n  // CRITICAL FIX: Remove duplicate responses from Chat API\n  // Chat API sometimes returns \"Villa Martens\\n\\nVilla Martens\"\n  // Split by double newline and take first occurrence\n  if (clientNameRaw.includes('\\n\\n')) {\n    const parts = clientNameRaw.split('\\n\\n');\n    // Check if it's a duplicate (same text repeated)\n    if (parts.length === 2 && parts[0].trim() === parts[1].trim()) {\n      clientNameRaw = parts[0].trim();\n    }\n  }\n  \n  // Normalize German client name for folder creation\n  let clientName = '';\n  if (clientNameRaw) {\n    clientName = clientNameRaw\n      .toLowerCase()\n      .trim()\n      .replace(/√§/g, 'ae')\n      .replace(/√∂/g, 'oe')\n      .replace(/√º/g, 'ue')\n      .replace(/√ü/g, 'ss')\n      .replace(/\\s*(gmbh|ag|kg|e\\.v\\.|mbh|co\\.|&\\s*co\\.?)\\s*/gi, '')\n      .replace(/[^a-z0-9]/g, '_')\n      .replace(/_+/g, '_')\n      .replace(/^_|_$/g, '');\n  }\n  \n  results.push({\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: '1ikw3k-EgpVg_h2ySDdqdUFB7-FQyYDFm'\n    }\n  });\n}\n\nreturn results;"
          },
          "id": "normalize-name-001",
          "name": "Normalize Client Name",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            2128,
            304
          ]
        },
        {
          "parameters": {
            "documentId": {
              "__rl": true,
              "mode": "id",
              "value": "1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI"
            },
            "sheetName": {
              "__rl": true,
              "mode": "list",
              "value": 762792134,
              "cachedResultName": "Client_Registry",
              "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI/edit#gid=762792134"
            },
            "options": {}
          },
          "id": "lookup-registry-001",
          "name": "Lookup Client Registry",
          "type": "n8n-nodes-base.googleSheets",
          "typeVersion": 4.7,
          "position": [
            2352,
            304
          ],
          "alwaysOutputData": true,
          "credentials": {
            "googleSheetsOAuth2Api": {
              "id": "H7ewI1sOrDYabelt",
              "name": "Google Sheets account"
            }
          }
        },
        {
          "parameters": {
            "jsCode": "// V7: Check if client exists in Client_Registry\n// CRITICAL FIX V3: Detect literal \"UNKNOWN\" response from AI\n\n// Get normalized client name from Normalize Client Name node (not from $input!)\nconst normalizeOutput = $('Normalize Client Name').first().json;\nconst clientName = normalizeOutput.client_name || '';\nconst clientNameRaw = normalizeOutput.client_name_raw || '';\nconst parentFolderId = normalizeOutput.parent_folder_id || '';\n\n// Get registry rows from $input (Lookup Client Registry output)\nconst registryRows = $input.all();\n\n// ‚úÖ FIRST: Check if AI literally returned \"UNKNOWN\"\nif (clientNameRaw.toUpperCase().trim() === 'UNKNOWN') {\n  return [{\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: parentFolderId,\n      client_status: 'UNKNOWN',\n      root_folder_id: null,\n      staging_folder_id: null,\n      extraction_failure: true,\n      extraction_error_message: 'AI returned UNKNOWN'\n    }\n  }];\n}\n\n// ‚úÖ SECOND: Detect AI extraction failures (technical + polite refusals)\nconst extractionFailurePatterns = [\n  // Technical error messages\n  'unable_to_extract',\n  'error_extracting',\n  'could_not_identify',\n  'could_not_extract',\n  'no_client_name',\n  'extraction_failed',\n  'cannot_identify',\n  // Polite AI refusals\n  'i_m_sorry',\n  'sorry_but',\n  'doesn_t_seem',\n  'does_not_appear',\n  'no_company_name',\n  'cannot_find',\n  'not_able_to'\n];\n\nconst isExtractionFailure = extractionFailurePatterns.some(pattern => \n  clientName.toLowerCase().includes(pattern)\n);\n\nif (isExtractionFailure) {\n  // AI failed to extract client name ‚Üí Route to UNKNOWN path\n  return [{\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: parentFolderId,\n      client_status: 'UNKNOWN',\n      root_folder_id: null,\n      staging_folder_id: null,\n      extraction_failure: true,\n      extraction_error_message: clientNameRaw\n    }\n  }];\n}\n\n// If registry is empty, client is NEW\nif (registryRows.length === 0) {\n  return [{\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: parentFolderId,\n      client_status: 'NEW',\n      root_folder_id: null,\n      staging_folder_id: null\n    }\n  }];\n}\n\n// Search registry for matching client (with same normalization)\nconst clientRow = registryRows.find(row => {\n  const registryClientName = row.json.Client_Name || '';\n  const normalizedRegistryName = registryClientName\n    .toLowerCase()\n    .trim()\n    .replace(/√§/g, 'ae')\n    .replace(/√∂/g, 'oe')\n    .replace(/√º/g, 'ue')\n    .replace(/√ü/g, 'ss')\n    .replace(/\\s*(gmbh|ag|kg|e\\.v\\.|mbh|co\\.|&\\s*co\\.?)\\s*/gi, '')\n    .replace(/[^a-z0-9]/g, '_')\n    .replace(/_+/g, '_')\n    .replace(/^_|_$/g, '');\n  \n  return normalizedRegistryName === clientName;\n});\n\nif (clientRow) {\n  // Client exists ‚Üí EXISTING path\n  return [{\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: parentFolderId,\n      client_status: 'EXISTING',\n      root_folder_id: clientRow.json.Root_Folder_ID,\n      staging_folder_id: clientRow.json.Staging_Folder_ID\n    }\n  }];\n} else {\n  // Client not in registry ‚Üí NEW path\n  return [{\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: parentFolderId,\n      client_status: 'NEW',\n      root_folder_id: null,\n      staging_folder_id: null\n    }\n  }];\n}"
          },
          "id": "check-exists-001",
          "name": "Check Client Exists",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            2576,
            304
          ]
        },
        {
          "parameters": {
            "rules": {
              "values": [
                {
                  "conditions": {
                    "options": {
                      "caseSensitive": true,
                      "leftValue": "",
                      "typeValidation": "strict",
                      "version": 3
                    },
                    "conditions": [
                      {
                        "leftValue": "={{ $json.client_normalized }}",
                        "rightValue": "",
                        "operator": {
                          "type": "string",
                          "operation": "isEmpty"
                        },
                        "id": "fcfa78d7-b736-4c5c-8123-d82d2456ad6d"
                      },
                      {
                        "leftValue": "={{ $json.client_status }}",
                        "rightValue": "UNKNOWN",
                        "operator": {
                          "type": "string",
                          "operation": "equals"
                        },
                        "id": "0d66b8d3-e3c7-4314-9d28-b4d60c45bef2"
                      }
                    ],
                    "combinator": "or"
                  },
                  "renameOutput": true,
                  "outputKey": "unknown_client"
                },
                {
                  "conditions": {
                    "options": {
                      "caseSensitive": true,
                      "leftValue": "",
                      "typeValidation": "strict",
                      "version": 3
                    },
                    "conditions": [
                      {
                        "leftValue": "={{ $json.client_status }}",
                        "rightValue": "NEW",
                        "operator": {
                          "type": "string",
                          "operation": "equals"
                        },
                        "id": "ed430b2e-0251-4783-9c3f-a0d015a07a18"
                      }
                    ],
                    "combinator": "and"
                  },
                  "renameOutput": true,
                  "outputKey": "new_client"
                },
                {
                  "conditions": {
                    "options": {
                      "caseSensitive": true,
                      "leftValue": "",
                      "typeValidation": "strict",
                      "version": 3
                    },
                    "conditions": [
                      {
                        "leftValue": "={{ $json.client_status }}",
                        "rightValue": "EXISTING",
                        "operator": {
                          "type": "string",
                          "operation": "equals"
                        },
                        "id": "3db6573d-2127-4c22-855f-afca26e1b811"
                      }
                    ],
                    "combinator": "and"
                  },
                  "renameOutput": true,
                  "outputKey": "existing_client"
                }
              ]
            },
            "options": {}
          },
          "id": "decision-gate-001",
          "name": "Decision Gate",
          "type": "n8n-nodes-base.switch",
          "typeVersion": 3.4,
          "position": [
            2800,
            288
          ]
        },
        {
          "parameters": {
            "jsCode": "// Prepare UNKNOWN client data with simple static naming\n// V3: Use simple UNKNOWN_CLIENT naming instead of timestamp\nconst inputData = $input.first().json;\n\nconst clientName = \"unknown_client\";\n\nreturn [{\n  json: {\n    client_name: clientName,\n    parent_folder_id: inputData.parent_folder_id,\n    client_name_raw: inputData.client_name_raw,\n    client_status: inputData.client_status,\n    root_folder_id: inputData.root_folder_id,\n    staging_folder_id: inputData.staging_folder_id,\n    extraction_failure: inputData.extraction_failure,\n    extraction_error_message: inputData.extraction_error_message,\n    is_unknown_client: true,\n    unknown_timestamp: new Date().toISOString()\n  },\n  binary: $input.first().binary\n}];"
          },
          "id": "prepare-unknown-data-001",
          "name": "Prepare UNKNOWN Client Data",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3248,
            112
          ]
        },
        {
          "parameters": {
            "jsCode": "// Handle unidentified client - send to manual queue\n  const items = $input.all();\n  const results = [];\n\n  for (const item of items) {\n    results.push({\n      json: {\n        status: 'FAILED',\n        reason: 'Client name could not be identified',\n        email_id: item.json.emailId,\n        email_subject: item.json.emailSubject,\n        timestamp: new Date().toISOString()\n      }\n    });\n  }\n\n  return results;"
          },
          "id": "handle-unknown-001",
          "name": "Handle Unidentified Client",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3024,
            112
          ]
        },
        {
          "parameters": {
            "documentId": {
              "__rl": true,
              "mode": "id",
              "value": "1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI"
            },
            "sheetName": {
              "__rl": true,
              "value": 762792134,
              "mode": "list",
              "cachedResultName": "Client_Registry",
              "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI/edit#gid=762792134"
            },
            "options": {}
          },
          "id": "lookup-staging-folder-001",
          "name": "Lookup Staging Folder",
          "type": "n8n-nodes-base.googleSheets",
          "typeVersion": 4.7,
          "position": [
            3024,
            592
          ],
          "credentials": {
            "googleSheetsOAuth2Api": {
              "id": "H7ewI1sOrDYabelt",
              "name": "Google Sheets account"
            }
          }
        },
        {
          "parameters": {
            "jsCode": "// V6: GRACEFUL ERROR HANDLING - No errors thrown, route to 38_Unknowns if missing\n// Extract staging_folder_id from Client Registry lookup AND file_id from upload\nconst clientName = $('Check Client Exists').first().json.client_name;\nconst sheetRows = $input.all();\nconst fileData = $('Extract File ID & Metadata').first().json;\n\n// Find matching row by normalizing Client_Name the same way as \"Normalize Client Name\" node\nconst matchingRow = sheetRows.find(row => {\n  const registryClientName = row.json.Client_Name || '';\n  \n  // Normalize Client_Name to match client_name format\n  const normalizedName = registryClientName\n    .toLowerCase()\n    .trim()\n    .replace(/√§/g, 'ae')\n    .replace(/√∂/g, 'oe')\n    .replace(/√º/g, 'ue')\n    .replace(/√ü/g, 'ss')\n    .replace(/\\s*(gmbh|ag|kg|e\\.v\\.|mbh|co\\.|&\\s*co\\.?)\\s*/gi, '')\n    .replace(/[^a-z0-9]/g, '_')\n    .replace(/_+/g, '_')\n    .replace(/^_|_$/g, '');\n  \n  return normalizedName === clientName;\n});\n\n// GRACEFUL HANDLING: Route to 38_Unknowns if no matching row\nif (!matchingRow) {\n  return [{\n    json: {\n      ...fileData,\n      client_name: clientName,\n      error: `No staging folder found for client: ${clientName}`,\n      routeTo38Unknowns: true,\n      errorType: 'missing_client_in_registry',\n      skipChunk1: true\n    }\n  }];\n}\n\nconst stagingFolderId = matchingRow.json.Staging_Folder_ID || matchingRow.json['01_Staging'];\n\n// GRACEFUL HANDLING: Route to 38_Unknowns if staging folder ID is empty\nif (!stagingFolderId) {\n  return [{\n    json: {\n      ...fileData,\n      client_name: clientName,\n      error: `Staging_Folder_ID is empty for client: ${clientName}`,\n      routeTo38Unknowns: true,\n      errorType: 'missing_staging_folder',\n      skipChunk1: true\n    }\n  }];\n}\n\n// SUCCESS PATH: Continue with staging folder ID\nreturn [{\n  json: {\n    client_name: clientName,\n    staging_folder_id: stagingFolderId,\n    email_id: fileData.emailId,\n    file_id: fileData.file_id,\n    filename: fileData.filename,\n    routeTo38Unknowns: false\n  }\n}];"
          },
          "id": "filter-staging-folder-001",
          "name": "Filter Staging Folder ID",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3248,
            592
          ]
        },
        {
          "parameters": {
            "conditions": {
              "options": {
                "caseSensitive": true,
                "leftValue": "",
                "typeValidation": "strict",
                "version": 2
              },
              "conditions": [
                {
                  "id": "route-unknowns-check",
                  "leftValue": "={{ $json.routeTo38Unknowns }}",
                  "rightValue": true,
                  "operator": {
                    "type": "boolean",
                    "operation": "true",
                    "singleValue": true
                  }
                }
              ],
              "combinator": "and"
            },
            "options": {}
          },
          "id": "check-routing-decision-001",
          "name": "Check Routing Decision",
          "type": "n8n-nodes-base.if",
          "typeVersion": 2,
          "position": [
            3472,
            592
          ]
        },
        {
          "parameters": {
            "jsCode": "// Prepare data for routing to 38_Unknowns when staging folder is missing\nconst item = $input.first().json;\n\n// Create UNKNOWN_CLIENT structure to match existing unknowns path\nreturn [{\n  json: {\n    client_name: 'unknown_client',\n    parent_folder_id: '1ikw3k-EgpVg_h2ySDdqdUFB7-FQyYDFm',\n    client_status: 'UNKNOWN',\n    is_unknown_client: true,\n    error_reason: item.error || 'Missing staging folder',\n    error_type: item.errorType || 'missing_staging_folder',\n    file_id: item.file_id,\n    filename: item.filename,\n    email_id: item.email_id,\n    unknown_timestamp: new Date().toISOString()\n  }\n}];"
          },
          "id": "prepare-missing-folder-error-001",
          "name": "Prepare Missing Folder Error",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3696,
            688
          ]
        },
        {
          "parameters": {
            "jsCode": "// Extract 38_Unknowns folder ID from Chunk 0 response\n// ALSO get file_id from earlier in workflow\n\nconst chunk0Response = $input.first().json;\nconst folderData = chunk0Response.folderIDs || [];\n\nconst unknownsFolder = folderData.find(item =>\n  item.Variable_Name === 'FOLDER_38_UNKNOWNS'\n);\n\nif (!unknownsFolder || !unknownsFolder.Folder_ID) {\n  throw new Error('FOLDER_38_UNKNOWNS not found in Chunk 0 response');\n}\n\n// Get file_id from Extract File ID & Metadata node\nconst fileMetadata = $('Extract File ID & Metadata').first().json;\nconst fileId = fileMetadata.file_id;\n\nif (!fileId) {\n  throw new Error('file_id not found from Extract File ID & Metadata node');\n}\n\nreturn {\n  json: {\n    unknowns_folder_id: unknownsFolder.Folder_ID,\n    temp_pdf_file_id: fileId,\n    root_folder_id: chunk0Response.Root_Folder_ID,\n    client_name: chunk0Response.Client_Name,\n    ...chunk0Response\n  },\n  binary: $input.first().binary\n};\n"
          },
          "id": "extract-unknowns-folder-001",
          "name": "Extract 38_Unknowns Folder ID",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3696,
            112
          ]
        },
        {
          "parameters": {
            "jsCode": "const folderId = $json.unknowns_folder_id;\nconst fileId = $json.temp_pdf_file_id;\n\nif (!folderId || folderId === '') {\n  throw new Error('Missing unknowns_folder_id - cannot move file');\n}\n\nif (!fileId || fileId === '') {\n  throw new Error('Missing temp_pdf_file_id - no file to move');\n}\n\nreturn {\n  json: {\n    unknowns_folder_id: folderId,\n    temp_pdf_file_id: fileId,\n    ...$json\n  },\n  binary: $input.first().binary\n};"
          },
          "id": "validate-folder-ids-001",
          "name": "Validate Folder IDs",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3920,
            112
          ]
        },
        {
          "parameters": {
            "operation": "move",
            "fileId": "={{ $json.temp_pdf_file_id }}",
            "driveId": {
              "__rl": true,
              "mode": "list",
              "value": "My Drive"
            },
            "folderId": {
              "__rl": true,
              "value": "={{ $('Execute Chunk 0 - Create Folders (UNKNOWN)').item.json.folderIDs[43].Folder_ID }}",
              "mode": ""
            }
          },
          "id": "move-pdf-unknowns-001",
          "name": "Move PDF to 38_Unknowns",
          "type": "n8n-nodes-base.googleDrive",
          "typeVersion": 3,
          "position": [
            4144,
            112
          ],
          "credentials": {
            "googleDriveOAuth2Api": {
              "id": "a4m50EefR3DJoU0R",
              "name": "Google Drive account"
            }
          }
        },
        {
          "parameters": {
            "jsCode": "// Get data from correct sources\n// CRITICAL FIX: Get root_folder_id from Validate Folder IDs (before Move PDF wiped data)\nconst folderData = $('Validate Folder IDs').first().json;\nconst emailData = $('Gmail Trigger - Unread with Attachments').first().json;\nconst moveResult = $input.first().json;\n\nconst rootFolderId = folderData.Root_Folder_ID || folderData.root_folder_id;\nconst rootFolderName = folderData.Client_Name || folderData.client_name || 'UNKNOWN';\nconst unknownsFolderId = folderData.unknowns_folder_id;\nconst pdfFileId = moveResult.id || folderData.temp_pdf_file_id;\n\nconst pdfLink = `https://drive.google.com/file/d/${pdfFileId}/view`;\nconst rootFolderLink = `https://drive.google.com/drive/folders/${rootFolderId}`;\n\nconst emailFrom = emailData.from || 'Unknown Sender';\nconst emailSubject = emailData.subject || 'No Subject';\nconst pdfFilename = folderData.pdf_filename || 'unknown.pdf';\n\nconst timestamp = new Date().toLocaleString('en-US', {\n  timeZone: 'Europe/Berlin',\n  year: 'numeric',\n  month: '2-digit',\n  day: '2-digit',\n  hour: '2-digit',\n  minute: '2-digit',\n  hour12: false\n});\n\nreturn [{\n  json: {\n    to: 'swayclarkeii@gmail.com',\n    pdf_filename: pdfFilename,\n    email_from: emailFrom,\n    email_subject: emailSubject,\n    root_folder_name: rootFolderName,\n    pdf_link: pdfLink,\n    root_folder_link: rootFolderLink,\n    timestamp: timestamp\n  },\n  binary: $input.first().binary\n}];"
          },
          "id": "prepare-email-data-001",
          "name": "Prepare Email Notification Data",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            4368,
            112
          ]
        },
        {
          "parameters": {
            "jsCode": "// Build HTML email body for UNKNOWN client notification\nconst data = $input.first().json;\n\n// Extract just the email address (not the display name)\nconst emailAddress = data.email_from?.value?.[0]?.address || 'Unknown Sender';\n\nconst htmlBody = `<!DOCTYPE html>\n<html>\n<body style=\"font-family: Arial, sans-serif; line-height: 1.6; color: #333;\">\n  <div style=\"max-width: 600px; margin: 0 auto; padding: 20px;\">\n    <h2 style=\"color: #d32f2f;\">‚ö†Ô∏è Unknown Client Document Received</h2>\n    \n    <p>A document was received but the client could not be identified. Manual review is required.</p>\n    \n    <div style=\"background: #f5f5f5; padding: 15px; border-left: 4px solid #1976d2; margin: 20px 0;\">\n      <h3 style=\"margin-top: 0;\">Document Details</h3>\n      <ul style=\"list-style: none; padding: 0;\">\n        <li><strong>Filename:</strong> ${data.pdf_filename}</li>\n        <li><strong>From:</strong> ${emailAddress}</li>\n        <li><strong>Subject:</strong> ${data.email_subject}</li>\n      </ul>\n    </div>\n    \n    <div style=\"background: #fff3e0; padding: 15px; border-left: 4px solid #f57c00; margin: 20px 0;\">\n      <h3 style=\"margin-top: 0;\">üìÇ Created Folder Structure</h3>\n      <p>A temporary folder structure has been created:</p>\n      <ul style=\"list-style: none; padding: 0;\">\n        <li><strong>Root Folder:</strong> ${data.root_folder_name}</li>\n        <li><strong>Document Location:</strong> SONSTIGES/38_Unknowns/</li>\n      </ul>\n    </div>\n    \n    <div style=\"margin: 30px 0;\">\n      <h3>üîó Quick Actions</h3>\n      <div style=\"margin: 10px 0;\">\n        <a href=\"${data.pdf_link}\" \n           style=\"display: inline-block; padding: 12px 24px; background: #1976d2; color: white; text-decoration: none; border-radius: 4px; margin-right: 10px;\">\n          üìÑ View PDF\n        </a>\n        <a href=\"${data.root_folder_link}\" \n           style=\"display: inline-block; padding: 12px 24px; background: #43a047; color: white; text-decoration: none; border-radius: 4px;\">\n          üìÅ Open Folder Structure\n        </a>\n      </div>\n    </div>\n    \n    <div style=\"background: #e3f2fd; padding: 15px; border-left: 4px solid #1976d2; margin: 20px 0;\">\n      <h3 style=\"margin-top: 0;\">‚úÖ Next Steps</h3>\n      <ol>\n        <li>Review the PDF to identify the client</li>\n        <li>Rename the root folder to the correct client name</li>\n        <li>Update the Client_Registry sheet with the correct client name</li>\n        <li>Move the PDF from 38_Unknowns to the appropriate subfolder</li>\n      </ol>\n    </div>\n    \n    <hr style=\"border: none; border-top: 1px solid #ddd; margin: 30px 0;\">\n    \n    <p style=\"font-size: 12px; color: #666;\">\n      <strong>System:</strong> Eugene AMA Document Organizer V4<br>\n      <strong>Timestamp:</strong> ${data.timestamp}\n    </p>\n  </div>\n</body>\n</html>`;\n\nreturn [{\n  json: {\n    ...data,\n    html_body: htmlBody\n  },\n  binary: $input.first().binary\n}];"
          },
          "id": "build-email-html-001",
          "name": "Build Email HTML Body",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            4592,
            112
          ]
        },
        {
          "parameters": {
            "sendTo": "swayclarkeii@gmail.com",
            "subject": "={{ $json.emailSubject || '[ACTION REQUIRED] Unknown Client Document' }}",
            "message": "={{ $json.html_body }}",
            "options": {}
          },
          "id": "send-email-notification-001",
          "name": "Send Email Notification",
          "type": "n8n-nodes-base.gmail",
          "typeVersion": 2,
          "position": [
            4816,
            112
          ],
          "webhookId": "e028968d-b3d1-4dd6-bb18-20d1b6594069",
          "credentials": {
            "gmailOAuth2": {
              "id": "aYzk7sZF8ZVyfOan",
              "name": "Gmail account"
            }
          }
        },
        {
          "parameters": {
            "jsCode": "// Format error email data for registry corruption\nconst inputData = $input.all();\n\nconst output = inputData.map(item => {\n  const clientName = item.json.client_name || 'Unknown Client';\n  const fileName = item.json.file_name || 'Unknown File';\n  const emailSubject = item.json.email_subject || 'N/A';\n  const emailFrom = item.json.email_from || 'N/A';\n  const emailDate = item.json.email_date || 'N/A';\n  \n  return {\n    json: {\n      ...item.json,\n      email_to: 'swayclarkeii@gmail.com',\n      email_subject: `[URGENT] Registry Error: ${clientName} - Missing Staging Folder`,\n      email_message: `CRITICAL REGISTRY ERROR DETECTED\n\nClient: ${clientName}\nError Type: Client marked EXISTING but staging_folder_id is MISSING in Client Registry\n\n--- ACTION TAKEN ---\nFile moved to 38_Unknowns folder for manual review\n\n--- ORIGINAL EMAIL DETAILS ---\nSubject: ${emailSubject}\nFrom: ${emailFrom}\nDate: ${emailDate}\nAttachment: ${fileName}\n\n--- NEXT STEPS ---\nPlease:\n1. Open the Client Registry spreadsheet\n2. Find the row for \"${clientName}\"\n3. Add the missing staging_folder_id to column E\n4. Manually move the file from 38_Unknowns to the correct staging folder\n\nThis is a data integrity issue that needs immediate attention.\n\n---\nWorkflow: AMA Pre-Chunk 0\nNode: Registry Error Handler`\n    }\n  };\n});\n\nreturn output;"
          },
          "id": "prepare-registry-error-email-001",
          "name": "Prepare Registry Error Email Data",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3920,
            688
          ]
        },
        {
          "parameters": {
            "sendTo": "={{ $json.email_to }}",
            "subject": "={{ $json.email_subject }}",
            "message": "={{ $json.email_message }}",
            "options": {}
          },
          "id": "send-registry-error-email-001",
          "name": "Send Registry Error Email",
          "type": "n8n-nodes-base.gmail",
          "typeVersion": 2.1,
          "position": [
            4144,
            688
          ],
          "webhookId": "6b7c8ac4-c32d-40d5-b4d0-44a55bc16b79",
          "credentials": {
            "gmailOAuth2": {
              "id": "aYzk7sZF8ZVyfOan",
              "name": "Gmail account"
            }
          }
        },
        {
          "parameters": {
            "operation": "move",
            "fileId": {
              "__rl": true,
              "mode": "id",
              "value": "={{ $json.file_id }}"
            },
            "driveId": {
              "__rl": true,
              "mode": "list",
              "value": "My Drive"
            },
            "folderId": {
              "__rl": true,
              "mode": "list",
              "value": "1qdUu-dIkQR0oDaZKAL_8OhI0jST89_Vu"
            }
          },
          "id": "move-to-unknowns-registry-001",
          "name": "Move to 38_Unknowns (Registry Error)",
          "type": "n8n-nodes-base.googleDrive",
          "typeVersion": 3,
          "position": [
            4368,
            688
          ],
          "credentials": {
            "googleDriveOAuth2Api": {
              "id": "a4m50EefR3DJoU0R",
              "name": "Google Drive account"
            }
          }
        },
        {
          "parameters": {
            "operation": "addLabels",
            "messageId": "={{ $json.email_id }}",
            "labelIds": [
              "INBOX"
            ]
          },
          "id": "mark-read-registry-error-001",
          "name": "Mark Email as Read (Registry Error)",
          "type": "n8n-nodes-base.gmail",
          "typeVersion": 2.1,
          "position": [
            4592,
            688
          ],
          "webhookId": "f229ca84-1e69-43a0-90a0-f6ac4544b40f",
          "credentials": {
            "gmailOAuth2": {
              "id": "aYzk7sZF8ZVyfOan",
              "name": "Gmail account"
            }
          }
        },
        {
          "parameters": {},
          "id": "noop-registry-complete-001",
          "name": "NoOp - Registry Error Complete",
          "type": "n8n-nodes-base.noOp",
          "typeVersion": 1,
          "position": [
            4816,
            688
          ]
        },
        {
          "parameters": {
            "jsCode": "// Merge Chunk 0 output with original file data for NEW client path\nconst chunk0Output = $input.first().json;\n\n// Get file_id from Extract File ID & Metadata node (far upstream)\nconst fileMetadata = $('Extract File ID & Metadata').first().json;\n\nreturn [{\n  json: {\n    ...chunk0Output,\n    file_id: fileMetadata.file_id,\n    email_id: fileMetadata.emailId,\n    filename: fileMetadata.filename\n  }\n}];"
          },
          "id": "0180f051-407b-453b-89fc-faaf3439c20d",
          "name": "Merge Chunk 0 Output (NEW)",
          "type": "n8n-nodes-base.code",
          "typeVersion": 1,
          "position": [
            3248,
            304
          ]
        },
        {
          "parameters": {
            "jsCode": "// Get Google Drive upload result from previous node\nconst driveUpload = $input.first().json;\n\n// Retrieve email metadata from Gmail Trigger\nconst emailData = $('Gmail Trigger - Unread with Attachments').first().json;\n\n// Retrieve binary metadata from Gmail Trigger\nconst binaryData = $('Gmail Trigger - Unread with Attachments').first().binary;\n\n// Get first attachment key\nconst attachmentKeys = Object.keys(binaryData);\nconst attachmentKey = attachmentKeys[0];\nconst attachment = binaryData[attachmentKey];\n\n// Extract file extension from filename\nconst fileName = driveUpload.name;\nconst extension = fileName.substring(fileName.lastIndexOf('.') + 1).toLowerCase();\n\n// Get client data from Normalize Client Name node\nconst clientData = $('Normalize Client Name').first().json;\nconst clientName = clientData.client_name || 'unknown';\n\n// Construct stagingPath\nconst stagingPath = `${clientName}/_Staging/${fileName}`;\n\n// Parse file size\nlet fileSizeBytes = 0;\nif (attachment.fileSize) {\n  const sizeStr = attachment.fileSize;\n  const match = sizeStr.match(/^([\\d.]+)\\s*(KB|MB|GB)$/i);\n  if (match) {\n    const value = parseFloat(match[1]);\n    const unit = match[2].toUpperCase();\n    const multipliers = { KB: 1024, MB: 1024 * 1024, GB: 1024 * 1024 * 1024 };\n    fileSizeBytes = Math.round(value * multipliers[unit]);\n  }\n}\n\n// Extract email sender\nlet emailFrom = '';\nif (emailData.from && emailData.from.value && emailData.from.value[0]) {\n  emailFrom = emailData.from.value[0].address;\n}\n\n// ‚úÖ UPDATED v9: Get extracted identifier from Parse Claude Response node (Claude Vision)\nconst extractionData = $('Parse Claude Response').first().json;\nconst extractedText = extractionData.client_name_raw || '';\nconst extractionMethod = extractionData.extractionMethod || 'claude_vision';\nconst extractionModel = extractionData.extractionModel || 'claude-sonnet-4-20250514';\nconst textLength = extractedText.length || 0;\n\n// Build complete Chunk 2 input\nreturn [{\n  json: {\n    fileId: driveUpload.id,\n    fileName: driveUpload.name,\n    mimeType: driveUpload.mimeType,\n    extension: extension,\n    size: fileSizeBytes,\n    emailId: emailData.id,\n    emailFrom: emailFrom,\n    emailSubject: emailData.subject,\n    emailDate: emailData.date,\n    stagingPath: stagingPath,\n    originalFileName: attachment.fileName,\n    extractedFromZip: false,\n    zipFileName: null,\n    client_name: clientData.client_name_raw,\n    client_normalized: clientData.client_name,\n\n    // ‚úÖ UPDATED v9: Pass Claude Vision extracted identifier to Chunk 2\n    extractedText: extractedText,\n    extractionMethod: extractionMethod,\n    extractionModel: extractionModel,\n    textLength: textLength,\n    skipDownload: textLength > 5\n  }\n}];\n"
          },
          "id": "prepare-chunk2-new-001",
          "name": "Prepare for Chunk 2.5 (NEW)",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            3696,
            304
          ],
          "notes": "Enriches Google Drive data with email metadata for Chunk 2"
        },
        {
          "parameters": {
            "workflowId": {
              "__rl": true,
              "value": "okg8wTqLtPUwjQ18",
              "mode": "list",
              "cachedResultName": "Chunk 2.5 - Client Document Tracking (Eugene Document Organizer)"
            },
            "options": {}
          },
          "id": "execute-chunk2-new-001",
          "name": "Execute Chunk 2.5 (NEW)",
          "type": "n8n-nodes-base.executeWorkflow",
          "typeVersion": 1.3,
          "position": [
            3920,
            304
          ],
          "notes": "Executes Chunk 2 text extraction workflow"
        },
        {
          "parameters": {
            "operation": "markAsRead",
            "messageId": "={{ $('Gmail Trigger - Unread with Attachments').first().json.id }}"
          },
          "id": "mark-read-new-001",
          "name": "Mark Email as Read (NEW)",
          "type": "n8n-nodes-base.gmail",
          "typeVersion": 2.1,
          "position": [
            4144,
            304
          ],
          "webhookId": "9967ebd9-7776-4d6d-a993-a3c7353a8c26",
          "credentials": {
            "gmailOAuth2": {
              "id": "aYzk7sZF8ZVyfOan",
              "name": "Gmail account"
            }
          },
          "notes": "Marks the processed email as read"
        },
        {
          "parameters": {},
          "id": "noop-new-complete-001",
          "name": "NoOp - NEW Complete",
          "type": "n8n-nodes-base.noOp",
          "typeVersion": 1,
          "position": [
            4368,
            304
          ]
        },
        {
          "parameters": {
            "jsCode": "// Get Google Drive upload result from previous node\nconst driveUpload = $input.first().json;\n\n// Retrieve email metadata from Gmail Trigger\nconst emailData = $('Gmail Trigger - Unread with Attachments').first().json;\n\n// Retrieve binary metadata from Gmail Trigger\nconst binaryData = $('Gmail Trigger - Unread with Attachments').first().binary;\n\n// Get first attachment key\nconst attachmentKeys = Object.keys(binaryData);\nconst attachmentKey = attachmentKeys[0];\nconst attachment = binaryData[attachmentKey];\n\n// Extract file extension from filename\nconst fileName = driveUpload.name;\nconst extension = fileName.substring(fileName.lastIndexOf('.') + 1).toLowerCase();\n\n// Get client data from Normalize Client Name node\nconst clientData = $('Normalize Client Name').first().json;\nconst clientName = clientData.client_name || 'unknown';\n\n// Construct stagingPath\nconst stagingPath = `${clientName}/_Staging/${fileName}`;\n\n// Parse file size\nlet fileSizeBytes = 0;\nif (attachment.fileSize) {\n  const sizeStr = attachment.fileSize;\n  const match = sizeStr.match(/^([\\d.]+)\\s*(KB|MB|GB)$/i);\n  if (match) {\n    const value = parseFloat(match[1]);\n    const unit = match[2].toUpperCase();\n    const multipliers = { KB: 1024, MB: 1024 * 1024, GB: 1024 * 1024 * 1024 };\n    fileSizeBytes = Math.round(value * multipliers[unit]);\n  }\n}\n\n// Extract email sender\nlet emailFrom = '';\nif (emailData.from && emailData.from.value && emailData.from.value[0]) {\n  emailFrom = emailData.from.value[0].address;\n}\n\n// ‚úÖ UPDATED v9: Get extracted identifier from Parse Claude Response node (Claude Vision)\nconst extractionData = $('Parse Claude Response').first().json;\nconst extractedText = extractionData.client_name_raw || '';\nconst extractionMethod = extractionData.extractionMethod || 'claude_vision';\nconst extractionModel = extractionData.extractionModel || 'claude-sonnet-4-20250514';\nconst textLength = extractedText.length || 0;\n\n// Build complete Chunk 2 input\nreturn [{\n  json: {\n    fileId: driveUpload.id,\n    fileName: driveUpload.name,\n    mimeType: driveUpload.mimeType,\n    extension: extension,\n    size: fileSizeBytes,\n    emailId: emailData.id,\n    emailFrom: emailFrom,\n    emailSubject: emailData.subject,\n    emailDate: emailData.date,\n    stagingPath: stagingPath,\n    originalFileName: attachment.fileName,\n    extractedFromZip: false,\n    zipFileName: null,\n    client_name: clientData.client_name_raw,\n    client_normalized: clientData.client_name,\n\n    // ‚úÖ UPDATED v9: Pass Claude Vision extracted identifier to Chunk 2\n    extractedText: extractedText,\n    extractionMethod: extractionMethod,\n    extractionModel: extractionModel,\n    textLength: textLength,\n    skipDownload: textLength > 5\n  }\n}];\n"
          },
          "id": "prepare-chunk2-existing-001",
          "name": "Prepare for Chunk 2.5 (EXISTING)",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            4144,
            496
          ],
          "notes": "Enriches Google Drive data with email metadata for Chunk 2"
        },
        {
          "parameters": {
            "workflowId": {
              "__rl": true,
              "value": "okg8wTqLtPUwjQ18",
              "mode": "list",
              "cachedResultName": "Chunk 2.5 - Client Document Tracking (Eugene Document Organizer)"
            },
            "options": {}
          },
          "id": "execute-chunk2-existing-001",
          "name": "Execute Chunk 2.5 (EXISTING)",
          "type": "n8n-nodes-base.executeWorkflow",
          "typeVersion": 1.3,
          "position": [
            4368,
            496
          ],
          "notes": "Executes Chunk 2 text extraction workflow"
        },
        {
          "parameters": {
            "operation": "markAsRead",
            "messageId": "={{ $('Gmail Trigger - Unread with Attachments').first().json.id }}"
          },
          "id": "mark-read-existing-001",
          "name": "Mark Email as Read (EXISTING)",
          "type": "n8n-nodes-base.gmail",
          "typeVersion": 2.1,
          "position": [
            4592,
            496
          ],
          "webhookId": "64c1fe12-1ad8-47a2-b59a-502812a88c50",
          "credentials": {
            "gmailOAuth2": {
              "id": "aYzk7sZF8ZVyfOan",
              "name": "Gmail account"
            }
          },
          "notes": "Marks the processed email as read"
        },
        {
          "parameters": {},
          "id": "noop-existing-complete-001",
          "name": "NoOp - EXISTING Complete",
          "type": "n8n-nodes-base.noOp",
          "typeVersion": 1,
          "position": [
            4816,
            496
          ]
        },
        {
          "parameters": {
            "operation": "move",
            "fileId": {
              "__rl": true,
              "value": "={{ $json.file_id }}",
              "mode": "id"
            },
            "driveId": {
              "__rl": true,
              "mode": "list",
              "value": "My Drive"
            },
            "folderId": {
              "__rl": true,
              "value": "={{ $json.Staging_Folder_ID }}",
              "mode": "id"
            }
          },
          "id": "b767c01a-345c-4a94-ba35-35f8dda0fb2c",
          "name": "Move PDF to _Staging (NEW)",
          "type": "n8n-nodes-base.googleDrive",
          "typeVersion": 3,
          "position": [
            3472,
            304
          ],
          "credentials": {
            "googleDriveOAuth2Api": {
              "id": "a4m50EefR3DJoU0R",
              "name": "Google Drive account"
            }
          }
        },
        {
          "parameters": {
            "operation": "move",
            "fileId": {
              "__rl": true,
              "value": "={{ $json.file_id }}",
              "mode": "id"
            },
            "driveId": {
              "__rl": true,
              "mode": "list",
              "value": "My Drive"
            },
            "folderId": {
              "__rl": true,
              "value": "={{ $json.Staging_Folder_ID }}",
              "mode": "id"
            }
          },
          "id": "90cc99fd-908d-4149-a2f7-35f42ab2e232",
          "name": "Move PDF to _Staging (EXISTING)",
          "type": "n8n-nodes-base.googleDrive",
          "typeVersion": 3,
          "position": [
            3696,
            496
          ],
          "alwaysOutputData": true,
          "credentials": {
            "googleDriveOAuth2Api": {
              "id": "a4m50EefR3DJoU0R",
              "name": "Google Drive account"
            }
          }
        },
        {
          "parameters": {
            "workflowId": {
              "__rl": true,
              "value": "zbxHkXOoD1qaz6OS",
              "mode": "list",
              "cachedResultUrl": "/workflow/zbxHkXOoD1qaz6OS",
              "cachedResultName": "AMA Chunk 0: Folder Initialization (V4 - Parameterized)"
            },
            "workflowInputs": {
              "mappingMode": "defineBelow",
              "value": {
                "client_name": "={{ $json.client_name_raw }}",
                "client_normalized": "={{ $json.client_name }}",
                "parent_folder_id": "={{ $('Check Client Exists').item.json.parent_folder_id }}"
              },
              "matchingColumns": [],
              "schema": [
                {
                  "id": "client_name",
                  "displayName": "client_name",
                  "required": false,
                  "defaultMatch": false,
                  "display": true,
                  "canBeUsedToMatch": true,
                  "type": "string"
                },
                {
                  "id": "client_normalized",
                  "displayName": "client_normalized",
                  "required": false,
                  "defaultMatch": false,
                  "display": true,
                  "canBeUsedToMatch": true,
                  "type": "string"
                },
                {
                  "id": "parent_folder_id",
                  "displayName": "parent_folder_id",
                  "required": false,
                  "defaultMatch": false,
                  "display": true,
                  "canBeUsedToMatch": true,
                  "type": "string"
                }
              ],
              "attemptToConvertTypes": false,
              "convertFieldsToString": true
            },
            "options": {}
          },
          "id": "bc9b052a-1fdf-412c-990a-7c3e58178304",
          "name": "Execute Chunk 0 - Create Folders (UNKNOWN)",
          "type": "n8n-nodes-base.executeWorkflow",
          "typeVersion": 1.3,
          "position": [
            3472,
            112
          ]
        },
        {
          "parameters": {
            "workflowId": {
              "__rl": true,
              "value": "zbxHkXOoD1qaz6OS",
              "mode": "list",
              "cachedResultUrl": "/workflow/zbxHkXOoD1qaz6OS",
              "cachedResultName": "AMA Chunk 0: Folder Initialization (V4 - Parameterized)"
            },
            "workflowInputs": {
              "mappingMode": "defineBelow",
              "value": {
                "client_name": "={{ $json.client_name_raw }}",
                "client_normalized": "={{ $json.client_name }}",
                "parent_folder_id": "={{ $('Check Client Exists').item.json.parent_folder_id }}"
              },
              "matchingColumns": [],
              "schema": [
                {
                  "id": "client_name",
                  "displayName": "client_name",
                  "required": false,
                  "defaultMatch": false,
                  "display": true,
                  "canBeUsedToMatch": true,
                  "type": "string"
                },
                {
                  "id": "client_normalized",
                  "displayName": "client_normalized",
                  "required": false,
                  "defaultMatch": false,
                  "display": true,
                  "canBeUsedToMatch": true,
                  "type": "string"
                },
                {
                  "id": "parent_folder_id",
                  "displayName": "parent_folder_id",
                  "required": false,
                  "defaultMatch": false,
                  "display": true,
                  "canBeUsedToMatch": true,
                  "type": "string"
                }
              ],
              "attemptToConvertTypes": false,
              "convertFieldsToString": true
            },
            "options": {}
          },
          "id": "execute-chunk0-001",
          "name": "Execute Chunk 0 - Create Folders (NEW)",
          "type": "n8n-nodes-base.executeWorkflow",
          "typeVersion": 1.3,
          "position": [
            3024,
            304
          ]
        },
        {
          "parameters": {
            "amount": 3
          },
          "id": "wait-staging-existing-001",
          "name": "Wait After Staging (EXISTING)",
          "type": "n8n-nodes-base.wait",
          "typeVersion": 1.1,
          "position": [
            3920,
            496
          ],
          "executeOnce": false,
          "alwaysOutputData": true,
          "webhookId": "6d74a0e2-74ef-411a-83f9-c98a972b25df"
        },
        {
          "parameters": {
            "jsCode": "const crypto = require('crypto');\n\n// Google Service Account credentials\nconst serviceAccount = {\n  projectId: 'n8n-integrations-482020',\n  clientEmail: 'n8n-document-ai@n8n-integrations-482020.iam.gserviceaccount.com',\n  privateKey: `-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCwWo8CBWPs5tvS\nP01jLTf6Rc54JrOCEU1KIOpkZryrT082kD/eXx73unpLGUCb9t5u9kjCjiU8BPMp\nqnPQSCVzeuMNWLYcyQfGIUFRfCSi/7bg5q1mwv+DkLsgNWx0mRAk5pfPCv9qW9qk\n+XyNYtqk3FlgWBRtynwd49cCN1FoaRgTQTv6KsRtqV7nc6MyE+VyyhMY64uoQfCN\nd+PrXkE20yDaNg/yZU/re3/2kqeWVt3F5nxZFbuM2wBof0wLQcqkZ/ggN9/C/zdp\nBpTnZlTadNzjPePKGBaMHyDP01/E4xUU9d9TJMM4OWc5ReFIMlSdYnzjhuir1+5A\no2JmvpmRAgMBAAECggEADZAkGC4H8wwHnfzmW8P6M9Jd6xm24UBUEb5u/c0fojaV\noLGpZ9XS+48o9qZONMXgx5HuI0sWtq3+xuvoFP280PaDiImTv/+qDGU5sSWmFQSB\nBn0B8GRQ4x0kzHkEtVb29I+TigXjgkTm5PHserHpSkKe0Re/wniPNnvzvk+OKu8W\nvnSleUP8NamyIxoMRZNWYdUI/yJvU6o2nuxZKe6aVvaF2T3eQ/3pYucvfgsV7L1i\nkle6T//NjEmrpeFtZEAgrnAAWLso7R+pbN08zc3Jbxb5Q1E6WABlTi6gbI9tmwuu\n53pe1GY4AGNpfGUiIO/UX/R+9/DSYCMrQMhqTdD8fQKBgQDptBqfAmcDgC9hFkSA\nopIxslCCsQ56eXTyZ0BL+qQiFyhQFmV3Do4vVLatJvZiUIWonNYxZYfxEMP06dW+\nk/Bu4NAoSc46wlvY1Bj9xOn7s/afNlY4J0YKrSpIuqQZHyhjERvK7Nn1UHDZ92qJ\nFXvaNJ0uUUYry5xuYrbwrfECKwKBgQDBLcNJsXKVYmaMh/xkucAKeeOWy/ME2kZz\noyEFcmgQhKU0Sr7C0OdLE3JnlL+9oz0ashBPb06Y0vsqDzl+0iwU81oc1RD/wBZz\nBgV2NB0jYvsIHFkI4BY5p4fePF5Q97UCaGttBf3JL1fFFeif/r1Rq2FbAnnpXsqF\npHrOFKsBMwKBgQC6CmjiyhvNWp7c78gKiuBMdYHH+EDpWISzb2Rs15MPnFW4I4wU\nUd74aLyfbJPYwfcUuf19BzFHwyvrbLZ95vEQoyCx4cctWYmaO4XFhpsphyK9rZjH\nTORiHWW6zfFSGk6hRn5UdWYw9h9QNLh3dkXI9/dkZsiwln7qFOVDBYUFTwKBgC7r\nnJlTnk8mXV4Y0XbtnvVscZj45IfzNFV189lM1nXcofu3g+nxr5wOlyUNfhzjfz3y\nrf99O4vnAtZOaFqjVc2o5eRG5CAaWdmKRt1U/xbPPcXUjNOZCgzq4hdadlYYNEDn\nd+A9Kk0pUJowHhZuWzFw/O6MBWxnd61KLAHOB1L9AoGARwyJIEwHeUeoAuCRlQyS\nxYzI8eMIDJ7HSiaFms+j8cuNy76O9U5E0KVBz6BEeTfq+aym0vyZ6iKJ3+q/IXQ4\no5jc6G6zgrMAgeuKzKFEwKNK/tm5j3FiDEzcUqLI00AfdG/f+QI/dTxbqnlB1tPn\nT0v0rf9bjMnUWoH9kXFM+XA=\n-----END PRIVATE KEY-----`\n};\n\n// Step 1: Create JWT token\nconst now = Math.floor(Date.now() / 1000);\nconst jwtHeader = {\n  alg: 'RS256',\n  typ: 'JWT'\n};\n\nconst jwtClaims = {\n  iss: serviceAccount.clientEmail,\n  scope: 'https://www.googleapis.com/auth/cloud-platform',\n  aud: 'https://oauth2.googleapis.com/token',\n  exp: now + 3600,\n  iat: now\n};\n\n// Encode header and claims\nconst base64UrlEncode = (str) => {\n  return Buffer.from(str)\n    .toString('base64')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '');\n};\n\nconst encodedHeader = base64UrlEncode(JSON.stringify(jwtHeader));\nconst encodedClaims = base64UrlEncode(JSON.stringify(jwtClaims));\nconst signatureInput = `${encodedHeader}.${encodedClaims}`;\n\n// Sign with private key using crypto module\nconst sign = crypto.createSign('RSA-SHA256');\nsign.update(signatureInput);\nconst signature = sign.sign(serviceAccount.privateKey, 'base64')\n  .replace(/\\+/g, '-')\n  .replace(/\\//g, '_')\n  .replace(/=/g, '');\n\nconst jwt = `${signatureInput}.${signature}`;\n\n// Step 2: Exchange JWT for access token\nconst tokenResponse = await this.helpers.httpRequest({\n  method: 'POST',\n  url: 'https://oauth2.googleapis.com/token',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded'\n  },\n  body: `grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer&assertion=${jwt}`\n});\n\nconst accessToken = tokenResponse.access_token;\n\n// Step 3: Get PDF binary and convert to base64\nconst item = $input.first();\nconst binaryKey = Object.keys(item.binary)[0];\nconst buffer = await this.helpers.getBinaryDataBuffer(0, binaryKey);\nconst base64Content = buffer.toString('base64');\n\n// Step 4: Prepare Document AI request body\nconst documentAiRequest = {\n  rawDocument: {\n    content: base64Content,\n    mimeType: 'application/pdf'\n  }\n};\n\n// Return access token, request body, and original data\nreturn {\n  json: {\n    ...item.json,\n    accessToken: accessToken,\n    documentAiRequest: documentAiRequest\n  },\n  binary: item.binary\n};"
          },
          "id": "prepare-docai-request-001",
          "name": "Prepare Document AI Request",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            1008,
            400
          ],
          "disabled": true
        },
        {
          "parameters": {
            "method": "POST",
            "url": "https://eu-documentai.googleapis.com/v1/projects/504943079120/locations/eu/processors/954baa10f2e87364:process",
            "sendHeaders": true,
            "headerParameters": {
              "parameters": [
                {
                  "name": "Authorization",
                  "value": "=Bearer {{ $json.accessToken }}"
                },
                {
                  "name": "Content-Type",
                  "value": "application/json"
                }
              ]
            },
            "sendBody": true,
            "specifyBody": "json",
            "jsonBody": "={{ JSON.stringify($json.documentAiRequest) }}",
            "options": {}
          },
          "id": "call-docai-ocr-001",
          "name": "Call Document AI OCR",
          "type": "n8n-nodes-base.httpRequest",
          "typeVersion": 4.3,
          "position": [
            1232,
            400
          ],
          "disabled": true,
          "notes": "Google Document AI OCR\n\nProcessor: 954baa10f2e87364\nRegion: eu\nProject: n8n-integrations-482020"
        },
        {
          "parameters": {
            "jsCode": "// Parse Google Document AI response\nconst item = $input.first();\nconst docAiResponse = item.json;\n\nlet extractedText = '';\nlet pageCount = 0;\n\n// Extract text from Document AI response\nif (docAiResponse.document && docAiResponse.document.text) {\n  extractedText = docAiResponse.document.text;\n  pageCount = docAiResponse.document.pages ? docAiResponse.document.pages.length : 0;\n}\n\n// Get original data from upstream node (Download PDF from Drive)\nconst originalData = $('Download PDF from Drive').first().json;\n\nreturn {\n  json: {\n    ...originalData,\n    extractedText: extractedText.trim(),\n    ocrSuccess: extractedText.length > 0,\n    ocrEngine: 'Google Document AI',\n    pageCount: pageCount\n  },\n  binary: item.binary\n};"
          },
          "id": "parse-docai-response-001",
          "name": "Parse Document AI Response",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            1456,
            400
          ],
          "disabled": true
        },
        {
          "parameters": {
            "jsCode": "const item = $input.first();\nconst binaryKey = Object.keys(item.binary)[0];\nconst buffer = await this.helpers.getBinaryDataBuffer(0, binaryKey);\nconst base64Content = buffer.toString('base64');\nconst mimeType = item.json.mimeType || 'application/pdf';\n\nreturn {\n  json: {\n    ...item.json,\n    imageData: {\n      type: 'base64',\n      media_type: mimeType,\n      data: base64Content\n    }\n  },\n  binary: item.binary\n};"
          },
          "id": "convert-pdf-base64-001",
          "name": "Convert PDF to Base64",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            1232,
            208
          ]
        },
        {
          "parameters": {
            "method": "POST",
            "url": "https://api.anthropic.com/v1/messages",
            "authentication": "predefinedCredentialType",
            "nodeCredentialType": "anthropicApi",
            "sendHeaders": true,
            "headerParameters": {
              "parameters": [
                {
                  "name": "x-api-key",
                  "value": "={{ $credentials.anthropicApi.apiKey }}"
                },
                {
                  "name": "anthropic-version",
                  "value": "2023-06-01"
                }
              ]
            },
            "sendBody": true,
            "specifyBody": "json",
            "jsonBody": "={{ $json.claudeApiBody }}",
            "options": {}
          },
          "id": "claude-vision-extract-001",
          "name": "Claude Vision Extract Identifier",
          "type": "n8n-nodes-base.httpRequest",
          "typeVersion": 4.2,
          "position": [
            1680,
            208
          ],
          "credentials": {
            "httpHeaderAuth": {
              "id": "vfoYopBRX35Znmq6",
              "name": "Anthropic API key"
            },
            "anthropicApi": {
              "id": "MRSNO4UW3OEIA3tQ",
              "name": "Anthropic account"
            }
          }
        },
        {
          "parameters": {
            "jsCode": "const item = $input.first();\nconst response = item.json;\n\n// Get Claude's response text\nlet rawResponse = response.content[0].text.trim();\n\n// Extract just the identifier from verbose responses\nlet identifier = rawResponse;\n\n// Pattern 1: Look for \"‚Üí identifier\" format (Claude's normalization output)\nconst arrowMatch = rawResponse.match(/‚Üí\\s*([^\\n*]+)/);\nif (arrowMatch) {\n  identifier = arrowMatch[1].trim();\n}\n// Pattern 2: Look for quoted identifier\nelse if (rawResponse.includes('\"')) {\n  const quoteMatch = rawResponse.match(/\"([^\"]+)\"/);\n  if (quoteMatch) {\n    identifier = quoteMatch[1].trim();\n  }\n}\n// Pattern 3: If response has multiple lines, take the last non-empty line\nelse if (rawResponse.includes('\\n')) {\n  const lines = rawResponse.split('\\n').filter(line => line.trim().length > 0);\n  identifier = lines[lines.length - 1].trim();\n  \n  // Remove common prefixes\n  identifier = identifier.replace(/^[-*‚Ä¢]\\s*/, ''); // Remove bullet points\n  identifier = identifier.replace(/^\\d+\\.\\s*/, ''); // Remove numbering\n  identifier = identifier.replace(/^[*_]+$/, ''); // Remove markdown formatting\n}\n\n// Clean up any remaining markdown or formatting\nidentifier = identifier.replace(/\\*\\*/g, ''); // Remove bold\nidentifier = identifier.replace(/\\*/g, ''); // Remove italics\nidentifier = identifier.replace(/^[:\\-]\\s*/, ''); // Remove leading colons/dashes\n\n// Final validation\nif (!identifier || identifier.length < 2 || identifier.length > 100) {\n  identifier = 'UNKNOWN';\n}\n\n// Get original data from upstream (Download PDF node)\nconst originalData = $('Download PDF from Drive').first().json;\n\nreturn {\n  json: {\n    ...originalData,\n    client_name_raw: identifier,\n    extractionMethod: 'claude_vision',\n    extractionModel: 'claude-sonnet-4-20250514',\n    rawClaudeResponse: rawResponse.substring(0, 500) // Keep first 500 chars for debugging\n  }\n};\n"
          },
          "id": "parse-claude-response-001",
          "name": "Parse Claude Response",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            1904,
            208
          ]
        },
        {
          "parameters": {
            "jsCode": "// Get the input data\nconst item = $input.first();\n\n// Full BPS-structured prompt (no escaping needed in JS template literal)\nconst prompt = `# Role\n\nYou are an expert German real estate document analyst specializing in project identification and entity normalization. Your expertise combines deep knowledge of German property development nomenclature, legal entity structures, and addressing conventions. You operate with precision and consistency, extracting identifiers that align with project-based organizational hierarchies.\n\n---\n\n# Task\n\nExtract the single most appropriate identifier from the provided German real estate document by following this sequence:\n\n1. **Scan** - Review the document for all potential identifiers (project names, company names, addresses)\n2. **Prioritize** - Apply the priority hierarchy to select the primary identifier\n3. **Normalize** - Transform the raw identifier using German character and suffix rules\n4. **Validate** - Ensure output contains ONLY the normalized identifier\n5. **Return** - Output the final identifier text with no additional formatting\n\n---\n\n# Specifics\n\n**Priority Hierarchy (return FIRST match found):**\n\n1. **Project code or name** (e.g., 'BV Propos' ‚Üí 'Propos', 'Villa Martens', 'Projekt Schlossberg')\n2. **Company or client name** (e.g., 'VAH Immobilien' ‚Üí 'VAH', 'Propos GmbH' ‚Üí 'Propos')\n3. **Street address ONLY as last resort** (e.g., 'Adolf-Martens-Stra√üe 10' ‚Üí 'Adolf-Martens 10')\n\n**Normalization Rules:**\n\n- German character conversion: √ü ‚Üí ss, √§ ‚Üí ae, √∂ ‚Üí oe, √º ‚Üí ue\n- Suffix removal: Strip 'GmbH', 'AG', 'KG', 'stra√üe', 'str.'\n- Extract core name only\n\n**Output Format:**\n\n- Return ONLY the normalized identifier\n- NO explanations, NO formatting, NO bullet points, NO prefixes\n- Plain text identifier only\n- If no identifier found, return exactly: UNKNOWN\n\n**Forbidden Output Patterns:**\n\n- Explanatory text (e.g., \"The project is...\")\n- Numbered lists (e.g., \"1. Project: ...\")\n- Parenthetical notes (e.g., \"Propos (from BV Propos GmbH)\")\n- Metadata or confidence scores\n\n---\n\n# Context\n\nThis extraction powers Eugene's project-based document routing system for AMA Capital. The identifier you extract determines which folder structure receives the document in Google Drive.\n\n**Why this matters:**\n\n- **Project-centric organization**: Eugene organizes deals by project (e.g., \"BV Propos\"), not by property address. One project can span multiple properties.\n- **Document grouping**: All documents for the same project must route to a single folder, even if they mention different addresses.\n- **Business logic alignment**: Prioritizing projects over addresses prevents document scatter (e.g., 3 addresses = 3 folders vs 1 project = 1 folder).\n\n**Impact of correct extraction:**\n\n- Enables automated folder creation and document routing\n- Reduces manual filing and searching\n- Maintains project integrity across multi-property deals\n\n---\n\n# Examples\n\n### Example 1: Project Name Found\n\n**Document content:** \"Bauvorhaben Propos - Schlo√übergstra√üe 13, 79189 Bad Krozingen\"\n\n**Identifiers detected:**\n- Project: \"BV Propos\", \"Bauvorhaben Propos\"\n- Address: \"Schlo√übergstra√üe 13\"\n\n**Priority applied:** Project code/name (Priority #1)\n\n**Normalized output:** \\`Propos\\`\n\n---\n\n### Example 2: Company Name Only\n\n**Document content:** \"VAH Immobilien GmbH - Objektverwaltung\"\n\n**Identifiers detected:**\n- Company: \"VAH Immobilien GmbH\"\n- No project code found\n\n**Priority applied:** Company/client name (Priority #2)\n\n**Normalized output:** \\`VAH\\`\n\n---\n\n### Example 3: Address as Fallback\n\n**Document content:** \"Energiebedarfsausweis f√ºr Adolf-Martens-Stra√üe 10\"\n\n**Identifiers detected:**\n- Address: \"Adolf-Martens-Stra√üe 10\"\n- No project or company found\n\n**Priority applied:** Street address (Priority #3 - last resort)\n\n**Normalized output:** \\`Adolf-Martens 10\\`\n\n---\n\n### Example 4: No Identifier Found\n\n**Document content:** \"Allgemeine Gesch√§ftsbedingungen\"\n\n**Identifiers detected:** None\n\n**Normalized output:** \\`UNKNOWN\\`\n\n---\n\n### Example 5: CORRECT vs INCORRECT Outputs\n\n‚úÖ **CORRECT responses:**\n- \\`Propos\\`\n- \\`Villa Martens\\`\n- \\`VAH\\`\n- \\`Adolf-Martens 10\\`\n- \\`UNKNOWN\\`\n\n‚ùå **INCORRECT responses (violate output format):**\n- \\`\"The project is Propos\"\\` ‚Üê has explanation\n- \\`\"1. Project: Propos\"\\` ‚Üê has numbering\n- \\`\"Propos (from BV Propos GmbH)\"\\` ‚Üê has parenthetical\n\n---\n\n# Notes\n\n**Critical Enforcement:**\n\n- Return ONLY the normalized identifier as plain text - no exceptions\n- Apply priority hierarchy strictly: Project ‚Üí Company ‚Üí Address\n- Never skip normalization rules (German characters, suffix removal)\n- Never add explanations, formatting, or metadata to output\n\n**Guardrails:**\n\n- If multiple identifiers at same priority level exist, choose the most prominent/repeated one\n- Addresses are LAST RESORT - only use when no project or company name exists\n- \"UNKNOWN\" is a valid response - use it when truly no identifier can be extracted\n- Never hallucinate or invent identifiers not present in the document\n\n**Edge Case Handling:**\n\n- Mixed languages: Prioritize German identifiers over English ones\n- Abbreviations: Keep common abbreviations (e.g., \"BV\" for Bauvorhaben)\n- Multiple projects mentioned: Choose the primary/first-mentioned project\n- Scanned/low-quality text: Extract best-effort identifier or return UNKNOWN\n\n**Remember:** This identifier directly controls document routing. Precision and consistency are paramount. When in doubt between two identifiers at the same priority level, choose the one that appears most frequently or prominently in the document.`;\n\n// Build the API request body\nconst apiBody = {\n  model: \"claude-sonnet-4-20250514\",\n  max_tokens: 50,\n  messages: [\n    {\n      role: \"user\",\n      content: [\n        {\n          type: \"document\",\n          source: {\n            type: \"base64\",\n            media_type: item.json.imageData.media_type,\n            data: item.json.imageData.data\n          }\n        },\n        {\n          type: \"text\",\n          text: prompt\n        }\n      ]\n    }\n  ]\n};\n\nreturn {\n  json: {\n    ...item.json,\n    claudeApiBody: apiBody\n  }\n};"
          },
          "id": "build-claude-request-001",
          "name": "Build Claude API Request",
          "type": "n8n-nodes-base.code",
          "typeVersion": 2,
          "position": [
            1456,
            208
          ]
        }
      ],
      "connections": {
        "Gmail Trigger - Unread with Attachments": {
          "main": [
            [
              {
                "node": "Filter PDF/ZIP Attachments",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Filter PDF/ZIP Attachments": {
          "main": [
            [
              {
                "node": "Upload PDF to Temp Folder",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Upload PDF to Temp Folder": {
          "main": [
            [
              {
                "node": "Extract File ID & Metadata",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Extract File ID & Metadata": {
          "main": [
            [
              {
                "node": "Download PDF from Drive",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Download PDF from Drive": {
          "main": [
            [
              {
                "node": "Convert PDF to Base64",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Extract Text from PDF": {
          "main": [
            [
              {
                "node": "Evaluate Extraction Quality",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Evaluate Extraction Quality": {
          "main": [
            [
              {
                "node": "AI Extract Client Name",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "AI Extract Client Name": {
          "main": [
            [
              {
                "node": "Normalize Client Name",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Normalize Client Name": {
          "main": [
            [
              {
                "node": "Lookup Client Registry",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Lookup Client Registry": {
          "main": [
            [
              {
                "node": "Check Client Exists",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Check Client Exists": {
          "main": [
            [
              {
                "node": "Decision Gate",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Decision Gate": {
          "main": [
            [
              {
                "node": "Handle Unidentified Client",
                "type": "main",
                "index": 0
              }
            ],
            [
              {
                "node": "Execute Chunk 0 - Create Folders (NEW)",
                "type": "main",
                "index": 0
              }
            ],
            [
              {
                "node": "Lookup Staging Folder",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Prepare UNKNOWN Client Data": {
          "main": [
            [
              {
                "node": "Execute Chunk 0 - Create Folders (UNKNOWN)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Lookup Staging Folder": {
          "main": [
            [
              {
                "node": "Filter Staging Folder ID",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Filter Staging Folder ID": {
          "main": [
            [
              {
                "node": "Check Routing Decision",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Extract 38_Unknowns Folder ID": {
          "main": [
            [
              {
                "node": "Validate Folder IDs",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Validate Folder IDs": {
          "main": [
            [
              {
                "node": "Move PDF to 38_Unknowns",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Move PDF to 38_Unknowns": {
          "main": [
            [
              {
                "node": "Prepare Email Notification Data",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Prepare Email Notification Data": {
          "main": [
            [
              {
                "node": "Build Email HTML Body",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Build Email HTML Body": {
          "main": [
            [
              {
                "node": "Send Email Notification",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Handle Unidentified Client": {
          "main": [
            [
              {
                "node": "Prepare UNKNOWN Client Data",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Check Routing Decision": {
          "main": [
            [
              {
                "node": "Prepare Missing Folder Error",
                "type": "main",
                "index": 0
              }
            ],
            [
              {
                "node": "Move PDF to _Staging (EXISTING)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Prepare Missing Folder Error": {
          "main": [
            [
              {
                "node": "Prepare Registry Error Email Data",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Prepare Registry Error Email Data": {
          "main": [
            [
              {
                "node": "Send Registry Error Email",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Send Registry Error Email": {
          "main": [
            [
              {
                "node": "Move to 38_Unknowns (Registry Error)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Move to 38_Unknowns (Registry Error)": {
          "main": [
            [
              {
                "node": "Mark Email as Read (Registry Error)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Mark Email as Read (Registry Error)": {
          "main": [
            [
              {
                "node": "NoOp - Registry Error Complete",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Merge Chunk 0 Output (NEW)": {
          "main": [
            [
              {
                "node": "Move PDF to _Staging (NEW)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Prepare for Chunk 2.5 (NEW)": {
          "main": [
            [
              {
                "node": "Execute Chunk 2.5 (NEW)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Execute Chunk 2.5 (NEW)": {
          "main": [
            [
              {
                "node": "Mark Email as Read (NEW)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Mark Email as Read (NEW)": {
          "main": [
            [
              {
                "node": "NoOp - NEW Complete",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Prepare for Chunk 2.5 (EXISTING)": {
          "main": [
            [
              {
                "node": "Execute Chunk 2.5 (EXISTING)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Execute Chunk 2.5 (EXISTING)": {
          "main": [
            [
              {
                "node": "Mark Email as Read (EXISTING)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Mark Email as Read (EXISTING)": {
          "main": [
            [
              {
                "node": "NoOp - EXISTING Complete",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Move PDF to _Staging (NEW)": {
          "main": [
            [
              {
                "node": "Prepare for Chunk 2.5 (NEW)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Execute Chunk 0 - Create Folders (UNKNOWN)": {
          "main": [
            [
              {
                "node": "Extract 38_Unknowns Folder ID",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Execute Chunk 0 - Create Folders (NEW)": {
          "main": [
            [
              {
                "node": "Merge Chunk 0 Output (NEW)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Move PDF to _Staging (EXISTING)": {
          "main": [
            [
              {
                "node": "Wait After Staging (EXISTING)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Wait After Staging (EXISTING)": {
          "main": [
            [
              {
                "node": "Prepare for Chunk 2.5 (EXISTING)",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Prepare Document AI Request": {
          "main": [
            [
              {
                "node": "Call Document AI OCR",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Call Document AI OCR": {
          "main": [
            [
              {
                "node": "Parse Document AI Response",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Parse Document AI Response": {
          "main": [
            [
              {
                "node": "Evaluate Extraction Quality",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Claude Vision Extract Identifier": {
          "main": [
            [
              {
                "node": "Parse Claude Response",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Parse Claude Response": {
          "main": [
            [
              {
                "node": "Normalize Client Name",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Convert PDF to Base64": {
          "main": [
            [
              {
                "node": "Build Claude API Request",
                "type": "main",
                "index": 0
              }
            ]
          ]
        },
        "Build Claude API Request": {
          "main": [
            [
              {
                "node": "Claude Vision Extract Identifier",
                "type": "main",
                "index": 0
              }
            ]
          ]
        }
      },
      "authors": "Sway Clarke",
      "name": "Version 874db1e3",
      "description": "",
      "autosaved": false,
      "workflowPublishHistory": [
        {
          "createdAt": "2026-01-18T23:35:28.263Z",
          "id": 963,
          "workflowId": "YGXWjWcBIk66ArvT",
          "versionId": "874db1e3-121a-4b49-98ce-96765cd5fb0b",
          "event": "activated",
          "userId": "e9bd9112-c2e3-4f67-873a-e1001baeafd8"
        }
      ]
    }
  }
}
