{
  "updatedAt": "2026-01-08T23:17:40.826Z",
  "createdAt": "2026-01-07T09:49:33.855Z",
  "id": "YGXWjWcBIk66ArvT",
  "name": "AMA Pre-Chunk 0 - REBUILT v1",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        },
        "simple": false,
        "filters": {
          "labelIds": [
            "INBOX",
            "UNREAD",
            "Label_8011160688574026773"
          ],
          "q": "has:attachment"
        },
        "options": {
          "dataPropertyAttachmentsPrefixName": "attachment_",
          "downloadAttachments": true
        }
      },
      "id": "gmail-trigger-001",
      "name": "Gmail Trigger - Unread with Attachments",
      "type": "n8n-nodes-base.gmailTrigger",
      "typeVersion": 1.3,
      "position": [
        112,
        304
      ],
      "credentials": {
        "gmailOAuth2": {
          "id": "aYzk7sZF8ZVyfOan",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Filter PDF and ZIP attachments only\nconst items = $input.all();\nconst filtered = [];\n\nfor (const item of items) {\n  // Gmail trigger stores attachments in item.binary, not item.json.attachments\n  if (!item.binary) continue;\n  \n  // Iterate over binary keys (attachment_0, attachment_1, etc.)\n  for (const [key, attachment] of Object.entries(item.binary)) {\n    const filename = attachment.fileName;\n    if (!filename) continue;\n    \n    const ext = filename.toLowerCase().split('.').pop();\n    \n    if (['pdf', 'zip'].includes(ext)) {\n      filtered.push({\n        json: {\n          emailId: item.json.id,\n          emailSubject: item.json.Subject || item.json.subject,\n          emailFrom: item.json.From || item.json.from,\n          emailDate: item.json.date,\n          attachmentKey: key,\n          filename: filename,\n          mimeType: attachment.mimeType,\n          size: attachment.fileSize\n        },\n        binary: {\n          data: attachment\n        }\n      });\n    }\n  }\n}\n\nreturn filtered;"
      },
      "id": "filter-attachments-001",
      "name": "Filter PDF/ZIP Attachments",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        336,
        304
      ]
    },
    {
      "parameters": {
        "driveId": {
          "__rl": true,
          "mode": "list",
          "value": "My Drive"
        },
        "folderId": {
          "__rl": true,
          "mode": "list",
          "value": "root",
          "cachedResultName": "/ (Root folder)"
        },
        "options": {}
      },
      "id": "upload-pdf-gdrive-001",
      "name": "Upload PDF to Temp Folder",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        560,
        304
      ],
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "a4m50EefR3DJoU0R",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract Google Drive file ID from upload response and preserve email metadata\nconst uploadResult = $input.first().json;\nconst emailData = $('Filter PDF/ZIP Attachments').first().json;\n\nreturn [{\n  json: {\n    file_id: uploadResult.id,\n    filename: uploadResult.name,\n    emailId: emailData.emailId,\n    emailSubject: emailData.emailSubject,\n    emailFrom: emailData.emailFrom,\n    emailDate: emailData.emailDate\n  }\n}];"
      },
      "id": "extract-file-id-001",
      "name": "Extract File ID & Metadata",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        784,
        304
      ]
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "mode": "id",
          "value": "={{ $json.file_id }}"
        },
        "options": {}
      },
      "id": "download-pdf-from-gdrive-001",
      "name": "Download PDF from Drive",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        1008,
        304
      ],
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "a4m50EefR3DJoU0R",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "operation": "pdf",
        "options": {
          "joinPages": true,
          "keepSource": "json"
        }
      },
      "id": "extract-text-001",
      "name": "Extract Text from PDF",
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1.1,
      "position": [
        1232,
        304
      ]
    },
    {
      "parameters": {
        "jsCode": " // V4: Evaluate extraction quality for each PDF\n  const items = $input.all();\n  const results = [];\n\n  for (const item of items) {\n    const extractedText = item.json.text || '';\n    const wordCount = extractedText.trim().split(/\\s+/).length;\n\n    results.push({\n      json: {\n        ...item.json,\n        wordCount: wordCount,\n        needsOCR: wordCount < 10,\n        extractionQuality: wordCount < 10 ? 'poor' : 'good',\n        \n        // NEW: Keep extracted text for downstream use\n        extractedText: extractedText,\n        textLength: extractedText.trim().length,\n        extractionMethod: 'digital_pre_chunk'\n      },\n      binary: item.binary  // ‚úÖ Pass through binary data\n    });\n  }\n\n  return results;"
      },
      "id": "evaluate-extraction-001",
      "name": "Evaluate Extraction Quality",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1456,
        304
      ]
    },
    {
      "parameters": {
        "resource": "chat",
        "chatModel": "gpt-4.1-mini",
        "prompt": {
          "messages": [
            {
              "role": "system",
              "content": "Extract the CLIENT or PROPERTY NAME from this German real estate document.      \nValid client names (in order of priority):    \n1. Property/Villa names: \"Villa Martens\", \"Residenz Schmidt\", \"Parkhaus Meyer\"    \n2. Project names: \"Wohnpark Lichterfelde\", \"Ensemble Charlottenburg\"    \n3. Company names: \"Schmidt Immobilien GmbH\", \"Bautr√§ger M√ºller AG\"    \n4. Person/Family names: \"Familie Wagner\", \"M√ºller\", \"Schmidt\"      \n\nIMPORTANT RULES:    \n- \"Villa [Name]\" or \"[Name] Residenz\" = Extract the FULL name (\"Villa Martens\", not just \"Martens\")    \n- Property names mentioned in text like \"Wohneigentum in der Villa Martens\" ‚Üí Extract \"Villa Martens\"    \n- Look in titles, headers, and property descriptions FIRST    \n- Street addresses alone (\"Adolf-Martens-Stra√üe 10\") are NOT client names    \n- If address mentions a name (\"Martens-Stra√üe\") AND document mentions property (\"Villa Martens\"), use the property name      \n\nReturn ONLY the client/property name, nothing else.    \n\nIf no clear client/property name exists, return exactly: UNKNOWN    \nExamples:    \n- \"Wohneigentum in der Villa Martens\" ‚Üí Villa Martens    \n- \"Projekt Schmidt-Residenz\" ‚Üí Schmidt-Residenz    \n- Just address \"Hauptstra√üe 10\" with no property name ‚Üí UNKNOWN‚Ä®"
            }
          ]
        },
        "simplifyOutput": false,
        "options": {
          "maxTokens": 50,
          "temperature": 0
        },
        "requestOptions": {}
      },
      "id": "ai-extract-client-001",
      "name": "AI Extract Client Name",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1.1,
      "position": [
        1680,
        304
      ],
      "credentials": {
        "openAiApi": {
          "id": "xmJ7t6kaKgMwA1ce",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get all input items\nconst items = $input.all();\nconst results = [];\n\n// Process each item\nfor (const item of items) {\n  let clientNameRaw = '';\n  \n  // Extract AI response from OpenAI node output\n  // Chat API (unsimplified): choices[0].message.content\n  if (item.json && item.json.choices && item.json.choices[0] && item.json.choices[0].message) {\n    clientNameRaw = String(item.json.choices[0].message.content);\n  }\n  // Chat API (simplified): message.content\n  else if (item.json && item.json.message && item.json.message.content) {\n    clientNameRaw = String(item.json.message.content);\n  }\n  // Text API (simplified): text\n  else if (item.json && item.json.text) {\n    clientNameRaw = String(item.json.text);\n  }\n  \n  clientNameRaw = clientNameRaw.trim();\n  \n  // CRITICAL FIX: Remove duplicate responses from Chat API\n  // Chat API sometimes returns \"Villa Martens\\n\\nVilla Martens\"\n  // Split by double newline and take first occurrence\n  if (clientNameRaw.includes('\\n\\n')) {\n    const parts = clientNameRaw.split('\\n\\n');\n    // Check if it's a duplicate (same text repeated)\n    if (parts.length === 2 && parts[0].trim() === parts[1].trim()) {\n      clientNameRaw = parts[0].trim();\n    }\n  }\n  \n  // Normalize German client name for folder creation\n  let clientName = '';\n  if (clientNameRaw) {\n    clientName = clientNameRaw\n      .toLowerCase()\n      .trim()\n      .replace(/√§/g, 'ae')\n      .replace(/√∂/g, 'oe')\n      .replace(/√º/g, 'ue')\n      .replace(/√ü/g, 'ss')\n      .replace(/\\s*(gmbh|ag|kg|e\\.v\\.|mbh|co\\.|&\\s*co\\.?)\\s*/gi, '')\n      .replace(/[^a-z0-9]/g, '_')\n      .replace(/_+/g, '_')\n      .replace(/^_|_$/g, '');\n  }\n  \n  results.push({\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: '1ikw3k-EgpVg_h2ySDdqdUFB7-FQyYDFm'\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "normalize-name-001",
      "name": "Normalize Client Name",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1904,
        304
      ]
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "mode": "id",
          "value": "1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI"
        },
        "sheetName": {
          "__rl": true,
          "mode": "list",
          "value": 762792134,
          "cachedResultName": "Client_Registry",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI/edit#gid=762792134"
        },
        "options": {}
      },
      "id": "lookup-registry-001",
      "name": "Lookup Client Registry",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        2128,
        304
      ],
      "alwaysOutputData": true,
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "H7ewI1sOrDYabelt",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// V7: Check if client exists in Client_Registry\n// CRITICAL FIX V3: Detect literal \"UNKNOWN\" response from AI\n\n// Get normalized client name from Normalize Client Name node (not from $input!)\nconst normalizeOutput = $('Normalize Client Name').first().json;\nconst clientName = normalizeOutput.client_name || '';\nconst clientNameRaw = normalizeOutput.client_name_raw || '';\nconst parentFolderId = normalizeOutput.parent_folder_id || '';\n\n// Get registry rows from $input (Lookup Client Registry output)\nconst registryRows = $input.all();\n\n// ‚úÖ FIRST: Check if AI literally returned \"UNKNOWN\"\nif (clientNameRaw.toUpperCase().trim() === 'UNKNOWN') {\n  return [{\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: parentFolderId,\n      client_status: 'UNKNOWN',\n      root_folder_id: null,\n      staging_folder_id: null,\n      extraction_failure: true,\n      extraction_error_message: 'AI returned UNKNOWN'\n    }\n  }];\n}\n\n// ‚úÖ SECOND: Detect AI extraction failures (technical + polite refusals)\nconst extractionFailurePatterns = [\n  // Technical error messages\n  'unable_to_extract',\n  'error_extracting',\n  'could_not_identify',\n  'could_not_extract',\n  'no_client_name',\n  'extraction_failed',\n  'cannot_identify',\n  // Polite AI refusals\n  'i_m_sorry',\n  'sorry_but',\n  'doesn_t_seem',\n  'does_not_appear',\n  'no_company_name',\n  'cannot_find',\n  'not_able_to'\n];\n\nconst isExtractionFailure = extractionFailurePatterns.some(pattern => \n  clientName.toLowerCase().includes(pattern)\n);\n\nif (isExtractionFailure) {\n  // AI failed to extract client name ‚Üí Route to UNKNOWN path\n  return [{\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: parentFolderId,\n      client_status: 'UNKNOWN',\n      root_folder_id: null,\n      staging_folder_id: null,\n      extraction_failure: true,\n      extraction_error_message: clientNameRaw\n    }\n  }];\n}\n\n// If registry is empty, client is NEW\nif (registryRows.length === 0) {\n  return [{\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: parentFolderId,\n      client_status: 'NEW',\n      root_folder_id: null,\n      staging_folder_id: null\n    }\n  }];\n}\n\n// Search registry for matching client (with same normalization)\nconst clientRow = registryRows.find(row => {\n  const registryClientName = row.json.Client_Name || '';\n  const normalizedRegistryName = registryClientName\n    .toLowerCase()\n    .trim()\n    .replace(/√§/g, 'ae')\n    .replace(/√∂/g, 'oe')\n    .replace(/√º/g, 'ue')\n    .replace(/√ü/g, 'ss')\n    .replace(/\\s*(gmbh|ag|kg|e\\.v\\.|mbh|co\\.|&\\s*co\\.?)\\s*/gi, '')\n    .replace(/[^a-z0-9]/g, '_')\n    .replace(/_+/g, '_')\n    .replace(/^_|_$/g, '');\n  \n  return normalizedRegistryName === clientName;\n});\n\nif (clientRow) {\n  // Client exists ‚Üí EXISTING path\n  return [{\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: parentFolderId,\n      client_status: 'EXISTING',\n      root_folder_id: clientRow.json.Root_Folder_ID,\n      staging_folder_id: clientRow.json.Staging_Folder_ID\n    }\n  }];\n} else {\n  // Client not in registry ‚Üí NEW path\n  return [{\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: parentFolderId,\n      client_status: 'NEW',\n      root_folder_id: null,\n      staging_folder_id: null\n    }\n  }];\n}"
      },
      "id": "check-exists-001",
      "name": "Check Client Exists",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2352,
        304
      ]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.client_normalized }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "isEmpty"
                    },
                    "id": "fcfa78d7-b736-4c5c-8123-d82d2456ad6d"
                  },
                  {
                    "leftValue": "={{ $json.client_status }}",
                    "rightValue": "UNKNOWN",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "0d66b8d3-e3c7-4314-9d28-b4d60c45bef2"
                  }
                ],
                "combinator": "or"
              },
              "renameOutput": true,
              "outputKey": "unknown_client"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.client_status }}",
                    "rightValue": "NEW",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "ed430b2e-0251-4783-9c3f-a0d015a07a18"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "new_client"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.client_status }}",
                    "rightValue": "EXISTING",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "3db6573d-2127-4c22-855f-afca26e1b811"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "existing_client"
            }
          ]
        },
        "options": {}
      },
      "id": "decision-gate-001",
      "name": "Decision Gate",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        2576,
        288
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare UNKNOWN client data with simple static naming\n// V3: Use simple UNKNOWN_CLIENT naming instead of timestamp\nconst inputData = $input.first().json;\n\nconst clientName = \"unknown_client\";\n\nreturn [{\n  json: {\n    client_name: clientName,\n    parent_folder_id: inputData.parent_folder_id,\n    client_name_raw: inputData.client_name_raw,\n    client_status: inputData.client_status,\n    root_folder_id: inputData.root_folder_id,\n    staging_folder_id: inputData.staging_folder_id,\n    extraction_failure: inputData.extraction_failure,\n    extraction_error_message: inputData.extraction_error_message,\n    is_unknown_client: true,\n    unknown_timestamp: new Date().toISOString()\n  },\n  binary: $input.first().binary\n}];"
      },
      "id": "prepare-unknown-data-001",
      "name": "Prepare UNKNOWN Client Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3024,
        112
      ]
    },
    {
      "parameters": {
        "jsCode": "// Handle unidentified client - send to manual queue\n  const items = $input.all();\n  const results = [];\n\n  for (const item of items) {\n    results.push({\n      json: {\n        status: 'FAILED',\n        reason: 'Client name could not be identified',\n        email_id: item.json.emailId,\n        email_subject: item.json.emailSubject,\n        timestamp: new Date().toISOString()\n      }\n    });\n  }\n\n  return results;"
      },
      "id": "handle-unknown-001",
      "name": "Handle Unidentified Client",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2800,
        112
      ]
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "mode": "id",
          "value": "1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI"
        },
        "sheetName": {
          "__rl": true,
          "value": 762792134,
          "mode": "list",
          "cachedResultName": "Client_Registry",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI/edit#gid=762792134"
        },
        "options": {}
      },
      "id": "lookup-staging-folder-001",
      "name": "Lookup Staging Folder",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        2800,
        592
      ],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "H7ewI1sOrDYabelt",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// V6: GRACEFUL ERROR HANDLING - No errors thrown, route to 38_Unknowns if missing\n// Extract staging_folder_id from Client Registry lookup AND file_id from upload\nconst clientName = $('Check Client Exists').first().json.client_name;\nconst sheetRows = $input.all();\nconst fileData = $('Extract File ID & Metadata').first().json;\n\n// Find matching row by normalizing Client_Name the same way as \"Normalize Client Name\" node\nconst matchingRow = sheetRows.find(row => {\n  const registryClientName = row.json.Client_Name || '';\n  \n  // Normalize Client_Name to match client_name format\n  const normalizedName = registryClientName\n    .toLowerCase()\n    .trim()\n    .replace(/√§/g, 'ae')\n    .replace(/√∂/g, 'oe')\n    .replace(/√º/g, 'ue')\n    .replace(/√ü/g, 'ss')\n    .replace(/\\s*(gmbh|ag|kg|e\\.v\\.|mbh|co\\.|&\\s*co\\.?)\\s*/gi, '')\n    .replace(/[^a-z0-9]/g, '_')\n    .replace(/_+/g, '_')\n    .replace(/^_|_$/g, '');\n  \n  return normalizedName === clientName;\n});\n\n// GRACEFUL HANDLING: Route to 38_Unknowns if no matching row\nif (!matchingRow) {\n  return [{\n    json: {\n      ...fileData,\n      client_name: clientName,\n      error: `No staging folder found for client: ${clientName}`,\n      routeTo38Unknowns: true,\n      errorType: 'missing_client_in_registry',\n      skipChunk1: true\n    }\n  }];\n}\n\nconst stagingFolderId = matchingRow.json.Staging_Folder_ID || matchingRow.json['01_Staging'];\n\n// GRACEFUL HANDLING: Route to 38_Unknowns if staging folder ID is empty\nif (!stagingFolderId) {\n  return [{\n    json: {\n      ...fileData,\n      client_name: clientName,\n      error: `Staging_Folder_ID is empty for client: ${clientName}`,\n      routeTo38Unknowns: true,\n      errorType: 'missing_staging_folder',\n      skipChunk1: true\n    }\n  }];\n}\n\n// SUCCESS PATH: Continue with staging folder ID\nreturn [{\n  json: {\n    client_name: clientName,\n    staging_folder_id: stagingFolderId,\n    email_id: fileData.emailId,\n    file_id: fileData.file_id,\n    filename: fileData.filename,\n    routeTo38Unknowns: false\n  }\n}];"
      },
      "id": "filter-staging-folder-001",
      "name": "Filter Staging Folder ID",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3024,
        592
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "route-unknowns-check",
              "leftValue": "={{ $json.routeTo38Unknowns }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-routing-decision-001",
      "name": "Check Routing Decision",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        3248,
        592
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare data for routing to 38_Unknowns when staging folder is missing\nconst item = $input.first().json;\n\n// Create UNKNOWN_CLIENT structure to match existing unknowns path\nreturn [{\n  json: {\n    client_name: 'unknown_client',\n    parent_folder_id: '1ikw3k-EgpVg_h2ySDdqdUFB7-FQyYDFm',\n    client_status: 'UNKNOWN',\n    is_unknown_client: true,\n    error_reason: item.error || 'Missing staging folder',\n    error_type: item.errorType || 'missing_staging_folder',\n    file_id: item.file_id,\n    filename: item.filename,\n    email_id: item.email_id,\n    unknown_timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "prepare-missing-folder-error-001",
      "name": "Prepare Missing Folder Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3472,
        688
      ]
    },
    {
      "parameters": {
        "jsCode": "// Extract 38_Unknowns folder ID from Chunk 0 response\n// ALSO get file_id from earlier in workflow\n\nconst chunk0Response = $input.first().json;\nconst folderData = chunk0Response.folderIDs || [];\n\nconst unknownsFolder = folderData.find(item =>\n  item.Variable_Name === 'FOLDER_38_UNKNOWNS'\n);\n\nif (!unknownsFolder || !unknownsFolder.Folder_ID) {\n  throw new Error('FOLDER_38_UNKNOWNS not found in Chunk 0 response');\n}\n\n// Get file_id from Extract File ID & Metadata node\nconst fileMetadata = $('Extract File ID & Metadata').first().json;\nconst fileId = fileMetadata.file_id;\n\nif (!fileId) {\n  throw new Error('file_id not found from Extract File ID & Metadata node');\n}\n\nreturn {\n  json: {\n    unknowns_folder_id: unknownsFolder.Folder_ID,\n    temp_pdf_file_id: fileId,\n    root_folder_id: chunk0Response.Root_Folder_ID,\n    client_name: chunk0Response.Client_Name,\n    ...chunk0Response\n  },\n  binary: $input.first().binary\n};\n"
      },
      "id": "extract-unknowns-folder-001",
      "name": "Extract 38_Unknowns Folder ID",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3472,
        112
      ]
    },
    {
      "parameters": {
        "jsCode": "const folderId = $json.unknowns_folder_id;\nconst fileId = $json.temp_pdf_file_id;\n\nif (!folderId || folderId === '') {\n  throw new Error('Missing unknowns_folder_id - cannot move file');\n}\n\nif (!fileId || fileId === '') {\n  throw new Error('Missing temp_pdf_file_id - no file to move');\n}\n\nreturn {\n  json: {\n    unknowns_folder_id: folderId,\n    temp_pdf_file_id: fileId,\n    ...$json\n  },\n  binary: $input.first().binary\n};"
      },
      "id": "validate-folder-ids-001",
      "name": "Validate Folder IDs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3696,
        112
      ]
    },
    {
      "parameters": {
        "operation": "move",
        "fileId": "={{ $json.temp_pdf_file_id }}",
        "driveId": {
          "__rl": true,
          "mode": "list",
          "value": "My Drive"
        },
        "folderId": {
          "__rl": true,
          "value": "={{ $('Execute Chunk 0 - Create Folders (UNKNOWN)').item.json.folderIDs[43].Folder_ID }}",
          "mode": ""
        }
      },
      "id": "move-pdf-unknowns-001",
      "name": "Move PDF to 38_Unknowns",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        3920,
        112
      ],
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "a4m50EefR3DJoU0R",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get data from correct sources\n// CRITICAL FIX: Get root_folder_id from Validate Folder IDs (before Move PDF wiped data)\nconst folderData = $('Validate Folder IDs').first().json;\nconst emailData = $('Gmail Trigger - Unread with Attachments').first().json;\nconst moveResult = $input.first().json;\n\nconst rootFolderId = folderData.Root_Folder_ID || folderData.root_folder_id;\nconst rootFolderName = folderData.Client_Name || folderData.client_name || 'UNKNOWN';\nconst unknownsFolderId = folderData.unknowns_folder_id;\nconst pdfFileId = moveResult.id || folderData.temp_pdf_file_id;\n\nconst pdfLink = `https://drive.google.com/file/d/${pdfFileId}/view`;\nconst rootFolderLink = `https://drive.google.com/drive/folders/${rootFolderId}`;\n\nconst emailFrom = emailData.from || 'Unknown Sender';\nconst emailSubject = emailData.subject || 'No Subject';\nconst pdfFilename = folderData.pdf_filename || 'unknown.pdf';\n\nconst timestamp = new Date().toLocaleString('en-US', {\n  timeZone: 'Europe/Berlin',\n  year: 'numeric',\n  month: '2-digit',\n  day: '2-digit',\n  hour: '2-digit',\n  minute: '2-digit',\n  hour12: false\n});\n\nreturn [{\n  json: {\n    to: 'swayclarkeii@gmail.com',\n    pdf_filename: pdfFilename,\n    email_from: emailFrom,\n    email_subject: emailSubject,\n    root_folder_name: rootFolderName,\n    pdf_link: pdfLink,\n    root_folder_link: rootFolderLink,\n    timestamp: timestamp\n  },\n  binary: $input.first().binary\n}];"
      },
      "id": "prepare-email-data-001",
      "name": "Prepare Email Notification Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4144,
        112
      ]
    },
    {
      "parameters": {
        "jsCode": "// Build HTML email body for UNKNOWN client notification\nconst data = $input.first().json;\n\n// Extract just the email address (not the display name)\nconst emailAddress = data.email_from?.value?.[0]?.address || 'Unknown Sender';\n\nconst htmlBody = `<!DOCTYPE html>\n<html>\n<body style=\"font-family: Arial, sans-serif; line-height: 1.6; color: #333;\">\n  <div style=\"max-width: 600px; margin: 0 auto; padding: 20px;\">\n    <h2 style=\"color: #d32f2f;\">‚ö†Ô∏è Unknown Client Document Received</h2>\n    \n    <p>A document was received but the client could not be identified. Manual review is required.</p>\n    \n    <div style=\"background: #f5f5f5; padding: 15px; border-left: 4px solid #1976d2; margin: 20px 0;\">\n      <h3 style=\"margin-top: 0;\">Document Details</h3>\n      <ul style=\"list-style: none; padding: 0;\">\n        <li><strong>Filename:</strong> ${data.pdf_filename}</li>\n        <li><strong>From:</strong> ${emailAddress}</li>\n        <li><strong>Subject:</strong> ${data.email_subject}</li>\n      </ul>\n    </div>\n    \n    <div style=\"background: #fff3e0; padding: 15px; border-left: 4px solid #f57c00; margin: 20px 0;\">\n      <h3 style=\"margin-top: 0;\">üìÇ Created Folder Structure</h3>\n      <p>A temporary folder structure has been created:</p>\n      <ul style=\"list-style: none; padding: 0;\">\n        <li><strong>Root Folder:</strong> ${data.root_folder_name}</li>\n        <li><strong>Document Location:</strong> SONSTIGES/38_Unknowns/</li>\n      </ul>\n    </div>\n    \n    <div style=\"margin: 30px 0;\">\n      <h3>üîó Quick Actions</h3>\n      <div style=\"margin: 10px 0;\">\n        <a href=\"${data.pdf_link}\" \n           style=\"display: inline-block; padding: 12px 24px; background: #1976d2; color: white; text-decoration: none; border-radius: 4px; margin-right: 10px;\">\n          üìÑ View PDF\n        </a>\n        <a href=\"${data.root_folder_link}\" \n           style=\"display: inline-block; padding: 12px 24px; background: #43a047; color: white; text-decoration: none; border-radius: 4px;\">\n          üìÅ Open Folder Structure\n        </a>\n      </div>\n    </div>\n    \n    <div style=\"background: #e3f2fd; padding: 15px; border-left: 4px solid #1976d2; margin: 20px 0;\">\n      <h3 style=\"margin-top: 0;\">‚úÖ Next Steps</h3>\n      <ol>\n        <li>Review the PDF to identify the client</li>\n        <li>Rename the root folder to the correct client name</li>\n        <li>Update the Client_Registry sheet with the correct client name</li>\n        <li>Move the PDF from 38_Unknowns to the appropriate subfolder</li>\n      </ol>\n    </div>\n    \n    <hr style=\"border: none; border-top: 1px solid #ddd; margin: 30px 0;\">\n    \n    <p style=\"font-size: 12px; color: #666;\">\n      <strong>System:</strong> Eugene AMA Document Organizer V4<br>\n      <strong>Timestamp:</strong> ${data.timestamp}\n    </p>\n  </div>\n</body>\n</html>`;\n\nreturn [{\n  json: {\n    ...data,\n    html_body: htmlBody\n  },\n  binary: $input.first().binary\n}];"
      },
      "id": "build-email-html-001",
      "name": "Build Email HTML Body",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4368,
        112
      ]
    },
    {
      "parameters": {
        "sendTo": "swayclarkeii@gmail.com",
        "subject": "={{ $json.emailSubject || '[ACTION REQUIRED] Unknown Client Document' }}",
        "message": "={{ $json.html_body }}",
        "options": {}
      },
      "id": "send-email-notification-001",
      "name": "Send Email Notification",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2,
      "position": [
        4592,
        112
      ],
      "webhookId": "e028968d-b3d1-4dd6-bb18-20d1b6594069",
      "credentials": {
        "gmailOAuth2": {
          "id": "aYzk7sZF8ZVyfOan",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Format error email data for registry corruption\nconst inputData = $input.all();\n\nconst output = inputData.map(item => {\n  const clientName = item.json.client_name || 'Unknown Client';\n  const fileName = item.json.file_name || 'Unknown File';\n  const emailSubject = item.json.email_subject || 'N/A';\n  const emailFrom = item.json.email_from || 'N/A';\n  const emailDate = item.json.email_date || 'N/A';\n  \n  return {\n    json: {\n      ...item.json,\n      email_to: 'swayclarkeii@gmail.com',\n      email_subject: `[URGENT] Registry Error: ${clientName} - Missing Staging Folder`,\n      email_message: `CRITICAL REGISTRY ERROR DETECTED\n\nClient: ${clientName}\nError Type: Client marked EXISTING but staging_folder_id is MISSING in Client Registry\n\n--- ACTION TAKEN ---\nFile moved to 38_Unknowns folder for manual review\n\n--- ORIGINAL EMAIL DETAILS ---\nSubject: ${emailSubject}\nFrom: ${emailFrom}\nDate: ${emailDate}\nAttachment: ${fileName}\n\n--- NEXT STEPS ---\nPlease:\n1. Open the Client Registry spreadsheet\n2. Find the row for \"${clientName}\"\n3. Add the missing staging_folder_id to column E\n4. Manually move the file from 38_Unknowns to the correct staging folder\n\nThis is a data integrity issue that needs immediate attention.\n\n---\nWorkflow: AMA Pre-Chunk 0\nNode: Registry Error Handler`\n    }\n  };\n});\n\nreturn output;"
      },
      "id": "prepare-registry-error-email-001",
      "name": "Prepare Registry Error Email Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3696,
        688
      ]
    },
    {
      "parameters": {
        "sendTo": "={{ $json.email_to }}",
        "subject": "={{ $json.email_subject }}",
        "message": "={{ $json.email_message }}",
        "options": {}
      },
      "id": "send-registry-error-email-001",
      "name": "Send Registry Error Email",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        3920,
        688
      ],
      "webhookId": "6b7c8ac4-c32d-40d5-b4d0-44a55bc16b79",
      "credentials": {
        "gmailOAuth2": {
          "id": "aYzk7sZF8ZVyfOan",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "operation": "move",
        "fileId": {
          "__rl": true,
          "mode": "id",
          "value": "={{ $json.file_id }}"
        },
        "driveId": {
          "__rl": true,
          "mode": "list",
          "value": "My Drive"
        },
        "folderId": {
          "__rl": true,
          "mode": "list",
          "value": "1qdUu-dIkQR0oDaZKAL_8OhI0jST89_Vu"
        }
      },
      "id": "move-to-unknowns-registry-001",
      "name": "Move to 38_Unknowns (Registry Error)",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        4144,
        688
      ],
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "a4m50EefR3DJoU0R",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "operation": "addLabels",
        "messageId": "={{ $json.email_id }}",
        "labelIds": [
          "INBOX"
        ]
      },
      "id": "mark-read-registry-error-001",
      "name": "Mark Email as Read (Registry Error)",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        4368,
        688
      ],
      "webhookId": "f229ca84-1e69-43a0-90a0-f6ac4544b40f",
      "credentials": {
        "gmailOAuth2": {
          "id": "aYzk7sZF8ZVyfOan",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {},
      "id": "noop-registry-complete-001",
      "name": "NoOp - Registry Error Complete",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        4592,
        688
      ]
    },
    {
      "parameters": {
        "jsCode": "// Merge Chunk 0 output with original file data for NEW client path\nconst chunk0Output = $input.first().json;\n\n// Get file_id from Extract File ID & Metadata node (far upstream)\nconst fileMetadata = $('Extract File ID & Metadata').first().json;\n\nreturn [{\n  json: {\n    ...chunk0Output,\n    file_id: fileMetadata.file_id,\n    email_id: fileMetadata.emailId,\n    filename: fileMetadata.filename\n  }\n}];"
      },
      "id": "0180f051-407b-453b-89fc-faaf3439c20d",
      "name": "Merge Chunk 0 Output (NEW)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        3024,
        304
      ]
    },
    {
      "parameters": {
        "jsCode": "// Get Google Drive upload result from previous node\nconst driveUpload = $input.first().json;\n\n// Retrieve email metadata from Gmail Trigger\nconst emailData = $('Gmail Trigger - Unread with Attachments').first().json;\n\n// Retrieve binary metadata from Gmail Trigger\nconst binaryData = $('Gmail Trigger - Unread with Attachments').first().binary;\n\n// Get first attachment key\nconst attachmentKeys = Object.keys(binaryData);\nconst attachmentKey = attachmentKeys[0];\nconst attachment = binaryData[attachmentKey];\n\n// Extract file extension from filename\nconst fileName = driveUpload.name;\nconst extension = fileName.substring(fileName.lastIndexOf('.') + 1).toLowerCase();\n\n// Get client data from Normalize Client Name node\nconst clientData = $('Normalize Client Name').first().json;\nconst clientName = clientData.client_name || 'unknown';\n\n// Construct stagingPath\nconst stagingPath = `${clientName}/_Staging/${fileName}`;\n\n// Parse file size\nlet fileSizeBytes = 0;\nif (attachment.fileSize) {\n  const sizeStr = attachment.fileSize;\n  const match = sizeStr.match(/^([\\d.]+)\\s*(KB|MB|GB)$/i);\n  if (match) {\n    const value = parseFloat(match[1]);\n    const unit = match[2].toUpperCase();\n    const multipliers = { KB: 1024, MB: 1024 * 1024, GB: 1024 * 1024 * 1024 };\n    fileSizeBytes = Math.round(value * multipliers[unit]);\n  }\n}\n\n// Extract email sender\nlet emailFrom = '';\nif (emailData.from && emailData.from.value && emailData.from.value[0]) {\n  emailFrom = emailData.from.value[0].address;\n}\n\n// ‚úÖ NEW: Get extracted text from Evaluate Extraction Quality node\nconst extractionData = $('Evaluate Extraction Quality').first().json;\nconst extractedText = extractionData.extractedText || '';\nconst extractionMethod = extractionData.extractionMethod || 'digital_pre_chunk';\nconst textLength = extractionData.textLength || 0;\n\n// Build complete Chunk 2 input\nreturn [{\n  json: {\n    fileId: driveUpload.id,\n    fileName: driveUpload.name,\n    mimeType: driveUpload.mimeType,\n    extension: extension,\n    size: fileSizeBytes,\n    emailId: emailData.id,\n    emailFrom: emailFrom,\n    emailSubject: emailData.subject,\n    emailDate: emailData.date,\n    stagingPath: stagingPath,\n    originalFileName: attachment.fileName,\n    extractedFromZip: false,\n    zipFileName: null,\n    client_name: clientData.client_name_raw,\n    client_normalized: clientData.client_name,\n    \n    // ‚úÖ NEW: Pass extracted text to Chunk 2 (skip re-download)\n    extractedText: extractedText,\n    extractionMethod: extractionMethod,\n    textLength: textLength,\n    skipDownload: textLength > 100  // Skip download if we have meaningful text\n  }\n}];"
      },
      "id": "prepare-chunk2-new-001",
      "name": "Prepare for Chunk 2 (NEW)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3472,
        304
      ],
      "notes": "Enriches Google Drive data with email metadata for Chunk 2"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "g9J5kjVtqaF9GLyc"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "id": "={{ $json.fileId }}",
            "name": "={{ $json.fileName }}",
            "mimeType": "={{ $json.mimeType }}",
            "client_normalized": "={{ $json.client_normalized }}",
            "staging_folder_id": "={{ $json.stagingPath }}",
            "extractedText": "={{ $json.extractedText }}",
            "extractionMethod": "={{ $json.extractionMethod }}",
            "textLength": "={{ $json.textLength }}",
            "skipDownload": "={{ $json.skipDownload }}"
          },
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": false,
              "type": "string"
            },
            {
              "id": "name",
              "displayName": "name",
              "required": false,
              "type": "string"
            },
            {
              "id": "mimeType",
              "displayName": "mimeType",
              "required": false,
              "type": "string"
            },
            {
              "id": "client_normalized",
              "displayName": "client_normalized",
              "required": false,
              "type": "string"
            },
            {
              "id": "staging_folder_id",
              "displayName": "staging_folder_id",
              "required": false,
              "type": "string"
            },
            {
              "id": "extractedText",
              "displayName": "extractedText",
              "required": false,
              "type": "string"
            },
            {
              "id": "extractionMethod",
              "displayName": "extractionMethod",
              "required": false,
              "type": "string"
            },
            {
              "id": "textLength",
              "displayName": "textLength",
              "required": false,
              "type": "number"
            },
            {
              "id": "skipDownload",
              "displayName": "skipDownload",
              "required": false,
              "type": "boolean"
            }
          ],
          "convertFieldsToString": false,
          "attemptToConvertTypes": true
        }
      },
      "id": "execute-chunk2-new-001",
      "name": "Execute Chunk 2 (NEW)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        3696,
        304
      ],
      "notes": "Executes Chunk 2 text extraction workflow"
    },
    {
      "parameters": {
        "operation": "markAsRead",
        "messageId": "={{ $('Gmail Trigger - Unread with Attachments').first().json.id }}"
      },
      "id": "mark-read-new-001",
      "name": "Mark Email as Read (NEW)",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        3920,
        304
      ],
      "webhookId": "9967ebd9-7776-4d6d-a993-a3c7353a8c26",
      "credentials": {
        "gmailOAuth2": {
          "id": "aYzk7sZF8ZVyfOan",
          "name": "Gmail account"
        }
      },
      "notes": "Marks the processed email as read"
    },
    {
      "parameters": {},
      "id": "noop-new-complete-001",
      "name": "NoOp - NEW Complete",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        4144,
        304
      ]
    },
    {
      "parameters": {
        "jsCode": "// Get Google Drive upload result from previous node\nconst driveUpload = $input.first().json;\n\n// Retrieve email metadata from Gmail Trigger\nconst emailData = $('Gmail Trigger - Unread with Attachments').first().json;\n\n// Retrieve binary metadata from Gmail Trigger\nconst binaryData = $('Gmail Trigger - Unread with Attachments').first().binary;\n\n// Get first attachment key\nconst attachmentKeys = Object.keys(binaryData);\nconst attachmentKey = attachmentKeys[0];\nconst attachment = binaryData[attachmentKey];\n\n// Extract file extension from filename\nconst fileName = driveUpload.name;\nconst extension = fileName.substring(fileName.lastIndexOf('.') + 1).toLowerCase();\n\n// Get client data from Normalize Client Name node\nconst clientData = $('Normalize Client Name').first().json;\nconst clientName = clientData.client_name || 'unknown';\n\n// Construct stagingPath\nconst stagingPath = `${clientName}/_Staging/${fileName}`;\n\n// Parse file size\nlet fileSizeBytes = 0;\nif (attachment.fileSize) {\n  const sizeStr = attachment.fileSize;\n  const match = sizeStr.match(/^([\\d.]+)\\s*(KB|MB|GB)$/i);\n  if (match) {\n    const value = parseFloat(match[1]);\n    const unit = match[2].toUpperCase();\n    const multipliers = { KB: 1024, MB: 1024 * 1024, GB: 1024 * 1024 * 1024 };\n    fileSizeBytes = Math.round(value * multipliers[unit]);\n  }\n}\n\n// Extract email sender\nlet emailFrom = '';\nif (emailData.from && emailData.from.value && emailData.from.value[0]) {\n  emailFrom = emailData.from.value[0].address;\n}\n\n// ‚úÖ NEW: Get extracted text from Evaluate Extraction Quality node\nconst extractionData = $('Evaluate Extraction Quality').first().json;\nconst extractedText = extractionData.extractedText || '';\nconst extractionMethod = extractionData.extractionMethod || 'digital_pre_chunk';\nconst textLength = extractionData.textLength || 0;\n\n// Build complete Chunk 2 input\nreturn [{\n  json: {\n    fileId: driveUpload.id,\n    fileName: driveUpload.name,\n    mimeType: driveUpload.mimeType,\n    extension: extension,\n    size: fileSizeBytes,\n    emailId: emailData.id,\n    emailFrom: emailFrom,\n    emailSubject: emailData.subject,\n    emailDate: emailData.date,\n    stagingPath: stagingPath,\n    originalFileName: attachment.fileName,\n    extractedFromZip: false,\n    zipFileName: null,\n    client_name: clientData.client_name_raw,\n    client_normalized: clientData.client_name,\n    \n    // ‚úÖ NEW: Pass extracted text to Chunk 2 (skip re-download)\n    extractedText: extractedText,\n    extractionMethod: extractionMethod,\n    textLength: textLength,\n    skipDownload: textLength > 100  // Skip download if we have meaningful text\n  }\n}];"
      },
      "id": "prepare-chunk2-existing-001",
      "name": "Prepare for Chunk 2 (EXISTING)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3696,
        496
      ],
      "notes": "Enriches Google Drive data with email metadata for Chunk 2"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "g9J5kjVtqaF9GLyc"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "id": "={{ $json.fileId }}",
            "name": "={{ $json.fileName }}",
            "mimeType": "={{ $json.mimeType }}",
            "client_normalized": "={{ $json.client_normalized }}",
            "staging_folder_id": "={{ $json.stagingPath }}",
            "extractedText": "={{ $json.extractedText }}",
            "extractionMethod": "={{ $json.extractionMethod }}",
            "textLength": "={{ $json.textLength }}",
            "skipDownload": "={{ $json.skipDownload }}"
          },
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": false,
              "type": "string"
            },
            {
              "id": "name",
              "displayName": "name",
              "required": false,
              "type": "string"
            },
            {
              "id": "mimeType",
              "displayName": "mimeType",
              "required": false,
              "type": "string"
            },
            {
              "id": "client_normalized",
              "displayName": "client_normalized",
              "required": false,
              "type": "string"
            },
            {
              "id": "staging_folder_id",
              "displayName": "staging_folder_id",
              "required": false,
              "type": "string"
            },
            {
              "id": "extractedText",
              "displayName": "extractedText",
              "required": false,
              "type": "string"
            },
            {
              "id": "extractionMethod",
              "displayName": "extractionMethod",
              "required": false,
              "type": "string"
            },
            {
              "id": "textLength",
              "displayName": "textLength",
              "required": false,
              "type": "number"
            },
            {
              "id": "skipDownload",
              "displayName": "skipDownload",
              "required": false,
              "type": "boolean"
            }
          ],
          "convertFieldsToString": false,
          "attemptToConvertTypes": true
        }
      },
      "id": "execute-chunk2-existing-001",
      "name": "Execute Chunk 2 (EXISTING)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        3920,
        496
      ],
      "notes": "Executes Chunk 2 text extraction workflow"
    },
    {
      "parameters": {
        "operation": "markAsRead",
        "messageId": "={{ $('Gmail Trigger - Unread with Attachments').first().json.id }}"
      },
      "id": "mark-read-existing-001",
      "name": "Mark Email as Read (EXISTING)",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        4144,
        496
      ],
      "webhookId": "64c1fe12-1ad8-47a2-b59a-502812a88c50",
      "credentials": {
        "gmailOAuth2": {
          "id": "aYzk7sZF8ZVyfOan",
          "name": "Gmail account"
        }
      },
      "notes": "Marks the processed email as read"
    },
    {
      "parameters": {},
      "id": "noop-existing-complete-001",
      "name": "NoOp - EXISTING Complete",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        4368,
        496
      ]
    },
    {
      "parameters": {
        "operation": "move",
        "fileId": {
          "__rl": true,
          "value": "={{ $json.file_id }}",
          "mode": "id"
        },
        "driveId": {
          "__rl": true,
          "mode": "list",
          "value": "My Drive"
        },
        "folderId": {
          "__rl": true,
          "value": "={{ $json.Staging_Folder_ID }}",
          "mode": "id"
        }
      },
      "id": "b767c01a-345c-4a94-ba35-35f8dda0fb2c",
      "name": "Move PDF to _Staging (NEW)",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        3248,
        304
      ],
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "a4m50EefR3DJoU0R",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "operation": "move",
        "fileId": {
          "__rl": true,
          "value": "={{ $json.file_id }}",
          "mode": "id"
        },
        "driveId": {
          "__rl": true,
          "mode": "list",
          "value": "My Drive"
        },
        "folderId": {
          "__rl": true,
          "value": "={{ $json.Staging_Folder_ID }}",
          "mode": "id"
        }
      },
      "id": "90cc99fd-908d-4149-a2f7-35f42ab2e232",
      "name": "Move PDF to _Staging (EXISTING)",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        3472,
        496
      ],
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "a4m50EefR3DJoU0R",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "zbxHkXOoD1qaz6OS",
          "mode": "list",
          "cachedResultUrl": "/workflow/zbxHkXOoD1qaz6OS",
          "cachedResultName": "AMA Chunk 0: Folder Initialization (V4 - Parameterized)"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "client_name": "={{ $json.client_name_raw }}",
            "client_normalized": "={{ $json.client_name }}",
            "parent_folder_id": "={{ $('Check Client Exists').item.json.parent_folder_id }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "client_name",
              "displayName": "client_name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "client_normalized",
              "displayName": "client_normalized",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "parent_folder_id",
              "displayName": "parent_folder_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "id": "bc9b052a-1fdf-412c-990a-7c3e58178304",
      "name": "Execute Chunk 0 - Create Folders (UNKNOWN)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        3248,
        112
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "zbxHkXOoD1qaz6OS",
          "mode": "list",
          "cachedResultUrl": "/workflow/zbxHkXOoD1qaz6OS",
          "cachedResultName": "AMA Chunk 0: Folder Initialization (V4 - Parameterized)"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "client_name": "={{ $json.client_name_raw }}",
            "client_normalized": "={{ $json.client_name }}",
            "parent_folder_id": "={{ $('Check Client Exists').item.json.parent_folder_id }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "client_name",
              "displayName": "client_name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "client_normalized",
              "displayName": "client_normalized",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "parent_folder_id",
              "displayName": "parent_folder_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "id": "execute-chunk0-001",
      "name": "Execute Chunk 0 - Create Folders (NEW)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        2800,
        304
      ]
    }
  ],
  "connections": {
    "Gmail Trigger - Unread with Attachments": {
      "main": [
        [
          {
            "node": "Filter PDF/ZIP Attachments",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter PDF/ZIP Attachments": {
      "main": [
        [
          {
            "node": "Upload PDF to Temp Folder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload PDF to Temp Folder": {
      "main": [
        [
          {
            "node": "Extract File ID & Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract File ID & Metadata": {
      "main": [
        [
          {
            "node": "Download PDF from Drive",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download PDF from Drive": {
      "main": [
        [
          {
            "node": "Extract Text from PDF",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Text from PDF": {
      "main": [
        [
          {
            "node": "Evaluate Extraction Quality",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Evaluate Extraction Quality": {
      "main": [
        [
          {
            "node": "AI Extract Client Name",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Extract Client Name": {
      "main": [
        [
          {
            "node": "Normalize Client Name",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Client Name": {
      "main": [
        [
          {
            "node": "Lookup Client Registry",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Lookup Client Registry": {
      "main": [
        [
          {
            "node": "Check Client Exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Client Exists": {
      "main": [
        [
          {
            "node": "Decision Gate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Decision Gate": {
      "main": [
        [
          {
            "node": "Handle Unidentified Client",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Execute Chunk 0 - Create Folders (NEW)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Lookup Staging Folder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare UNKNOWN Client Data": {
      "main": [
        [
          {
            "node": "Execute Chunk 0 - Create Folders (UNKNOWN)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Lookup Staging Folder": {
      "main": [
        [
          {
            "node": "Filter Staging Folder ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Staging Folder ID": {
      "main": [
        [
          {
            "node": "Check Routing Decision",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract 38_Unknowns Folder ID": {
      "main": [
        [
          {
            "node": "Validate Folder IDs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Folder IDs": {
      "main": [
        [
          {
            "node": "Move PDF to 38_Unknowns",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Move PDF to 38_Unknowns": {
      "main": [
        [
          {
            "node": "Prepare Email Notification Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Email Notification Data": {
      "main": [
        [
          {
            "node": "Build Email HTML Body",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Email HTML Body": {
      "main": [
        [
          {
            "node": "Send Email Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Unidentified Client": {
      "main": [
        [
          {
            "node": "Prepare UNKNOWN Client Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Routing Decision": {
      "main": [
        [
          {
            "node": "Prepare Missing Folder Error",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Move PDF to _Staging (EXISTING)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Missing Folder Error": {
      "main": [
        [
          {
            "node": "Prepare Registry Error Email Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Registry Error Email Data": {
      "main": [
        [
          {
            "node": "Send Registry Error Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Registry Error Email": {
      "main": [
        [
          {
            "node": "Move to 38_Unknowns (Registry Error)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Move to 38_Unknowns (Registry Error)": {
      "main": [
        [
          {
            "node": "Mark Email as Read (Registry Error)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Email as Read (Registry Error)": {
      "main": [
        [
          {
            "node": "NoOp - Registry Error Complete",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Chunk 0 Output (NEW)": {
      "main": [
        [
          {
            "node": "Move PDF to _Staging (NEW)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare for Chunk 2 (NEW)": {
      "main": [
        [
          {
            "node": "Execute Chunk 2 (NEW)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Chunk 2 (NEW)": {
      "main": [
        [
          {
            "node": "Mark Email as Read (NEW)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Email as Read (NEW)": {
      "main": [
        [
          {
            "node": "NoOp - NEW Complete",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare for Chunk 2 (EXISTING)": {
      "main": [
        [
          {
            "node": "Execute Chunk 2 (EXISTING)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Chunk 2 (EXISTING)": {
      "main": [
        [
          {
            "node": "Mark Email as Read (EXISTING)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Email as Read (EXISTING)": {
      "main": [
        [
          {
            "node": "NoOp - EXISTING Complete",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Move PDF to _Staging (NEW)": {
      "main": [
        [
          {
            "node": "Prepare for Chunk 2 (NEW)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Move PDF to _Staging (EXISTING)": {
      "main": [
        [
          {
            "node": "Prepare for Chunk 2 (EXISTING)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Chunk 0 - Create Folders (UNKNOWN)": {
      "main": [
        [
          {
            "node": "Extract 38_Unknowns Folder ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Chunk 0 - Create Folders (NEW)": {
      "main": [
        [
          {
            "node": "Merge Chunk 0 Output (NEW)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "staticData": {
    "node:Gmail Trigger - Unread with Attachments": {
      "Gmail Trigger - Unread with Attachments": {
        "lastTimeChecked": 1767918398,
        "possibleDuplicates": [
          "19ba025fd6e8fad2"
        ]
      }
    }
  },
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "81a40793-6d75-4fe0-a191-f8a5de1f462f",
  "activeVersionId": "81a40793-6d75-4fe0-a191-f8a5de1f462f",
  "versionCounter": 291,
  "triggerCount": 1,
  "shared": [
    {
      "updatedAt": "2026-01-07T09:49:33.855Z",
      "createdAt": "2026-01-07T09:49:33.855Z",
      "role": "workflow:owner",
      "workflowId": "YGXWjWcBIk66ArvT",
      "projectId": "Rs8mhw052fnrzWZM",
      "project": {
        "updatedAt": "2025-12-31T15:54:29.115Z",
        "createdAt": "2025-12-31T15:27:33.865Z",
        "id": "Rs8mhw052fnrzWZM",
        "name": "Sway Clarke <sway@oloxa.ai>",
        "type": "personal",
        "icon": null,
        "description": null,
        "creatorId": "e9bd9112-c2e3-4f67-873a-e1001baeafd8",
        "projectRelations": [
          {
            "updatedAt": "2025-12-31T15:27:33.865Z",
            "createdAt": "2025-12-31T15:27:33.865Z",
            "userId": "e9bd9112-c2e3-4f67-873a-e1001baeafd8",
            "projectId": "Rs8mhw052fnrzWZM",
            "user": {
              "updatedAt": "2026-01-09T08:40:57.214Z",
              "createdAt": "2025-12-31T15:27:33.119Z",
              "id": "e9bd9112-c2e3-4f67-873a-e1001baeafd8",
              "email": "sway@oloxa.ai",
              "firstName": "Sway",
              "lastName": "Clarke",
              "personalizationAnswers": {
                "version": "v4",
                "personalization_survey_submitted_at": "2025-12-31T15:54:37.562Z",
                "personalization_survey_n8n_version": "2.1.4"
              },
              "settings": {
                "userActivated": true,
                "easyAIWorkflowOnboarded": true,
                "firstSuccessfulWorkflowId": "zbxHkXOoD1qaz6OS",
                "userActivatedAt": 1767398053308,
                "npsSurvey": {
                  "responded": true,
                  "lastShownAt": 1767684846804
                }
              },
              "disabled": false,
              "mfaEnabled": false,
              "lastActiveAt": "2026-01-08",
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": [],
  "activeVersion": {
    "updatedAt": "2026-01-08T23:17:40.828Z",
    "createdAt": "2026-01-08T23:17:40.828Z",
    "versionId": "81a40793-6d75-4fe0-a191-f8a5de1f462f",
    "workflowId": "YGXWjWcBIk66ArvT",
    "nodes": [
      {
        "parameters": {
          "pollTimes": {
            "item": [
              {
                "mode": "everyMinute"
              }
            ]
          },
          "simple": false,
          "filters": {
            "labelIds": [
              "INBOX",
              "UNREAD",
              "Label_8011160688574026773"
            ],
            "q": "has:attachment"
          },
          "options": {
            "dataPropertyAttachmentsPrefixName": "attachment_",
            "downloadAttachments": true
          }
        },
        "id": "gmail-trigger-001",
        "name": "Gmail Trigger - Unread with Attachments",
        "type": "n8n-nodes-base.gmailTrigger",
        "typeVersion": 1.3,
        "position": [
          112,
          304
        ],
        "credentials": {
          "gmailOAuth2": {
            "id": "aYzk7sZF8ZVyfOan",
            "name": "Gmail account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Filter PDF and ZIP attachments only\nconst items = $input.all();\nconst filtered = [];\n\nfor (const item of items) {\n  // Gmail trigger stores attachments in item.binary, not item.json.attachments\n  if (!item.binary) continue;\n  \n  // Iterate over binary keys (attachment_0, attachment_1, etc.)\n  for (const [key, attachment] of Object.entries(item.binary)) {\n    const filename = attachment.fileName;\n    if (!filename) continue;\n    \n    const ext = filename.toLowerCase().split('.').pop();\n    \n    if (['pdf', 'zip'].includes(ext)) {\n      filtered.push({\n        json: {\n          emailId: item.json.id,\n          emailSubject: item.json.Subject || item.json.subject,\n          emailFrom: item.json.From || item.json.from,\n          emailDate: item.json.date,\n          attachmentKey: key,\n          filename: filename,\n          mimeType: attachment.mimeType,\n          size: attachment.fileSize\n        },\n        binary: {\n          data: attachment\n        }\n      });\n    }\n  }\n}\n\nreturn filtered;"
        },
        "id": "filter-attachments-001",
        "name": "Filter PDF/ZIP Attachments",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          336,
          304
        ]
      },
      {
        "parameters": {
          "driveId": {
            "__rl": true,
            "mode": "list",
            "value": "My Drive"
          },
          "folderId": {
            "__rl": true,
            "mode": "list",
            "value": "root",
            "cachedResultName": "/ (Root folder)"
          },
          "options": {}
        },
        "id": "upload-pdf-gdrive-001",
        "name": "Upload PDF to Temp Folder",
        "type": "n8n-nodes-base.googleDrive",
        "typeVersion": 3,
        "position": [
          560,
          304
        ],
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "a4m50EefR3DJoU0R",
            "name": "Google Drive account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Extract Google Drive file ID from upload response and preserve email metadata\nconst uploadResult = $input.first().json;\nconst emailData = $('Filter PDF/ZIP Attachments').first().json;\n\nreturn [{\n  json: {\n    file_id: uploadResult.id,\n    filename: uploadResult.name,\n    emailId: emailData.emailId,\n    emailSubject: emailData.emailSubject,\n    emailFrom: emailData.emailFrom,\n    emailDate: emailData.emailDate\n  }\n}];"
        },
        "id": "extract-file-id-001",
        "name": "Extract File ID & Metadata",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          784,
          304
        ]
      },
      {
        "parameters": {
          "operation": "download",
          "fileId": {
            "__rl": true,
            "mode": "id",
            "value": "={{ $json.file_id }}"
          },
          "options": {}
        },
        "id": "download-pdf-from-gdrive-001",
        "name": "Download PDF from Drive",
        "type": "n8n-nodes-base.googleDrive",
        "typeVersion": 3,
        "position": [
          1008,
          304
        ],
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "a4m50EefR3DJoU0R",
            "name": "Google Drive account"
          }
        }
      },
      {
        "parameters": {
          "operation": "pdf",
          "options": {
            "joinPages": true,
            "keepSource": "json"
          }
        },
        "id": "extract-text-001",
        "name": "Extract Text from PDF",
        "type": "n8n-nodes-base.extractFromFile",
        "typeVersion": 1.1,
        "position": [
          1232,
          304
        ]
      },
      {
        "parameters": {
          "jsCode": " // V4: Evaluate extraction quality for each PDF\n  const items = $input.all();\n  const results = [];\n\n  for (const item of items) {\n    const extractedText = item.json.text || '';\n    const wordCount = extractedText.trim().split(/\\s+/).length;\n\n    results.push({\n      json: {\n        ...item.json,\n        wordCount: wordCount,\n        needsOCR: wordCount < 10,\n        extractionQuality: wordCount < 10 ? 'poor' : 'good',\n        \n        // NEW: Keep extracted text for downstream use\n        extractedText: extractedText,\n        textLength: extractedText.trim().length,\n        extractionMethod: 'digital_pre_chunk'\n      },\n      binary: item.binary  // ‚úÖ Pass through binary data\n    });\n  }\n\n  return results;"
        },
        "id": "evaluate-extraction-001",
        "name": "Evaluate Extraction Quality",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1456,
          304
        ]
      },
      {
        "parameters": {
          "resource": "chat",
          "chatModel": "gpt-4.1-mini",
          "prompt": {
            "messages": [
              {
                "role": "system",
                "content": "Extract the CLIENT or PROPERTY NAME from this German real estate document.      \nValid client names (in order of priority):    \n1. Property/Villa names: \"Villa Martens\", \"Residenz Schmidt\", \"Parkhaus Meyer\"    \n2. Project names: \"Wohnpark Lichterfelde\", \"Ensemble Charlottenburg\"    \n3. Company names: \"Schmidt Immobilien GmbH\", \"Bautr√§ger M√ºller AG\"    \n4. Person/Family names: \"Familie Wagner\", \"M√ºller\", \"Schmidt\"      \n\nIMPORTANT RULES:    \n- \"Villa [Name]\" or \"[Name] Residenz\" = Extract the FULL name (\"Villa Martens\", not just \"Martens\")    \n- Property names mentioned in text like \"Wohneigentum in der Villa Martens\" ‚Üí Extract \"Villa Martens\"    \n- Look in titles, headers, and property descriptions FIRST    \n- Street addresses alone (\"Adolf-Martens-Stra√üe 10\") are NOT client names    \n- If address mentions a name (\"Martens-Stra√üe\") AND document mentions property (\"Villa Martens\"), use the property name      \n\nReturn ONLY the client/property name, nothing else.    \n\nIf no clear client/property name exists, return exactly: UNKNOWN    \nExamples:    \n- \"Wohneigentum in der Villa Martens\" ‚Üí Villa Martens    \n- \"Projekt Schmidt-Residenz\" ‚Üí Schmidt-Residenz    \n- Just address \"Hauptstra√üe 10\" with no property name ‚Üí UNKNOWN‚Ä®"
              }
            ]
          },
          "simplifyOutput": false,
          "options": {
            "maxTokens": 50,
            "temperature": 0
          },
          "requestOptions": {}
        },
        "id": "ai-extract-client-001",
        "name": "AI Extract Client Name",
        "type": "n8n-nodes-base.openAi",
        "typeVersion": 1.1,
        "position": [
          1680,
          304
        ],
        "credentials": {
          "openAiApi": {
            "id": "xmJ7t6kaKgMwA1ce",
            "name": "OpenAi account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Get all input items\nconst items = $input.all();\nconst results = [];\n\n// Process each item\nfor (const item of items) {\n  let clientNameRaw = '';\n  \n  // Extract AI response from OpenAI node output\n  // Chat API (unsimplified): choices[0].message.content\n  if (item.json && item.json.choices && item.json.choices[0] && item.json.choices[0].message) {\n    clientNameRaw = String(item.json.choices[0].message.content);\n  }\n  // Chat API (simplified): message.content\n  else if (item.json && item.json.message && item.json.message.content) {\n    clientNameRaw = String(item.json.message.content);\n  }\n  // Text API (simplified): text\n  else if (item.json && item.json.text) {\n    clientNameRaw = String(item.json.text);\n  }\n  \n  clientNameRaw = clientNameRaw.trim();\n  \n  // CRITICAL FIX: Remove duplicate responses from Chat API\n  // Chat API sometimes returns \"Villa Martens\\n\\nVilla Martens\"\n  // Split by double newline and take first occurrence\n  if (clientNameRaw.includes('\\n\\n')) {\n    const parts = clientNameRaw.split('\\n\\n');\n    // Check if it's a duplicate (same text repeated)\n    if (parts.length === 2 && parts[0].trim() === parts[1].trim()) {\n      clientNameRaw = parts[0].trim();\n    }\n  }\n  \n  // Normalize German client name for folder creation\n  let clientName = '';\n  if (clientNameRaw) {\n    clientName = clientNameRaw\n      .toLowerCase()\n      .trim()\n      .replace(/√§/g, 'ae')\n      .replace(/√∂/g, 'oe')\n      .replace(/√º/g, 'ue')\n      .replace(/√ü/g, 'ss')\n      .replace(/\\s*(gmbh|ag|kg|e\\.v\\.|mbh|co\\.|&\\s*co\\.?)\\s*/gi, '')\n      .replace(/[^a-z0-9]/g, '_')\n      .replace(/_+/g, '_')\n      .replace(/^_|_$/g, '');\n  }\n  \n  results.push({\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: '1ikw3k-EgpVg_h2ySDdqdUFB7-FQyYDFm'\n    }\n  });\n}\n\nreturn results;"
        },
        "id": "normalize-name-001",
        "name": "Normalize Client Name",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1904,
          304
        ]
      },
      {
        "parameters": {
          "documentId": {
            "__rl": true,
            "mode": "id",
            "value": "1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI"
          },
          "sheetName": {
            "__rl": true,
            "mode": "list",
            "value": 762792134,
            "cachedResultName": "Client_Registry",
            "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI/edit#gid=762792134"
          },
          "options": {}
        },
        "id": "lookup-registry-001",
        "name": "Lookup Client Registry",
        "type": "n8n-nodes-base.googleSheets",
        "typeVersion": 4.7,
        "position": [
          2128,
          304
        ],
        "alwaysOutputData": true,
        "credentials": {
          "googleSheetsOAuth2Api": {
            "id": "H7ewI1sOrDYabelt",
            "name": "Google Sheets account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// V7: Check if client exists in Client_Registry\n// CRITICAL FIX V3: Detect literal \"UNKNOWN\" response from AI\n\n// Get normalized client name from Normalize Client Name node (not from $input!)\nconst normalizeOutput = $('Normalize Client Name').first().json;\nconst clientName = normalizeOutput.client_name || '';\nconst clientNameRaw = normalizeOutput.client_name_raw || '';\nconst parentFolderId = normalizeOutput.parent_folder_id || '';\n\n// Get registry rows from $input (Lookup Client Registry output)\nconst registryRows = $input.all();\n\n// ‚úÖ FIRST: Check if AI literally returned \"UNKNOWN\"\nif (clientNameRaw.toUpperCase().trim() === 'UNKNOWN') {\n  return [{\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: parentFolderId,\n      client_status: 'UNKNOWN',\n      root_folder_id: null,\n      staging_folder_id: null,\n      extraction_failure: true,\n      extraction_error_message: 'AI returned UNKNOWN'\n    }\n  }];\n}\n\n// ‚úÖ SECOND: Detect AI extraction failures (technical + polite refusals)\nconst extractionFailurePatterns = [\n  // Technical error messages\n  'unable_to_extract',\n  'error_extracting',\n  'could_not_identify',\n  'could_not_extract',\n  'no_client_name',\n  'extraction_failed',\n  'cannot_identify',\n  // Polite AI refusals\n  'i_m_sorry',\n  'sorry_but',\n  'doesn_t_seem',\n  'does_not_appear',\n  'no_company_name',\n  'cannot_find',\n  'not_able_to'\n];\n\nconst isExtractionFailure = extractionFailurePatterns.some(pattern => \n  clientName.toLowerCase().includes(pattern)\n);\n\nif (isExtractionFailure) {\n  // AI failed to extract client name ‚Üí Route to UNKNOWN path\n  return [{\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: parentFolderId,\n      client_status: 'UNKNOWN',\n      root_folder_id: null,\n      staging_folder_id: null,\n      extraction_failure: true,\n      extraction_error_message: clientNameRaw\n    }\n  }];\n}\n\n// If registry is empty, client is NEW\nif (registryRows.length === 0) {\n  return [{\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: parentFolderId,\n      client_status: 'NEW',\n      root_folder_id: null,\n      staging_folder_id: null\n    }\n  }];\n}\n\n// Search registry for matching client (with same normalization)\nconst clientRow = registryRows.find(row => {\n  const registryClientName = row.json.Client_Name || '';\n  const normalizedRegistryName = registryClientName\n    .toLowerCase()\n    .trim()\n    .replace(/√§/g, 'ae')\n    .replace(/√∂/g, 'oe')\n    .replace(/√º/g, 'ue')\n    .replace(/√ü/g, 'ss')\n    .replace(/\\s*(gmbh|ag|kg|e\\.v\\.|mbh|co\\.|&\\s*co\\.?)\\s*/gi, '')\n    .replace(/[^a-z0-9]/g, '_')\n    .replace(/_+/g, '_')\n    .replace(/^_|_$/g, '');\n  \n  return normalizedRegistryName === clientName;\n});\n\nif (clientRow) {\n  // Client exists ‚Üí EXISTING path\n  return [{\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: parentFolderId,\n      client_status: 'EXISTING',\n      root_folder_id: clientRow.json.Root_Folder_ID,\n      staging_folder_id: clientRow.json.Staging_Folder_ID\n    }\n  }];\n} else {\n  // Client not in registry ‚Üí NEW path\n  return [{\n    json: {\n      client_name: clientName,\n      client_name_raw: clientNameRaw,\n      parent_folder_id: parentFolderId,\n      client_status: 'NEW',\n      root_folder_id: null,\n      staging_folder_id: null\n    }\n  }];\n}"
        },
        "id": "check-exists-001",
        "name": "Check Client Exists",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2352,
          304
        ]
      },
      {
        "parameters": {
          "rules": {
            "values": [
              {
                "conditions": {
                  "options": {
                    "caseSensitive": true,
                    "leftValue": "",
                    "typeValidation": "strict",
                    "version": 3
                  },
                  "conditions": [
                    {
                      "leftValue": "={{ $json.client_normalized }}",
                      "rightValue": "",
                      "operator": {
                        "type": "string",
                        "operation": "isEmpty"
                      },
                      "id": "fcfa78d7-b736-4c5c-8123-d82d2456ad6d"
                    },
                    {
                      "leftValue": "={{ $json.client_status }}",
                      "rightValue": "UNKNOWN",
                      "operator": {
                        "type": "string",
                        "operation": "equals"
                      },
                      "id": "0d66b8d3-e3c7-4314-9d28-b4d60c45bef2"
                    }
                  ],
                  "combinator": "or"
                },
                "renameOutput": true,
                "outputKey": "unknown_client"
              },
              {
                "conditions": {
                  "options": {
                    "caseSensitive": true,
                    "leftValue": "",
                    "typeValidation": "strict",
                    "version": 3
                  },
                  "conditions": [
                    {
                      "leftValue": "={{ $json.client_status }}",
                      "rightValue": "NEW",
                      "operator": {
                        "type": "string",
                        "operation": "equals"
                      },
                      "id": "ed430b2e-0251-4783-9c3f-a0d015a07a18"
                    }
                  ],
                  "combinator": "and"
                },
                "renameOutput": true,
                "outputKey": "new_client"
              },
              {
                "conditions": {
                  "options": {
                    "caseSensitive": true,
                    "leftValue": "",
                    "typeValidation": "strict",
                    "version": 3
                  },
                  "conditions": [
                    {
                      "leftValue": "={{ $json.client_status }}",
                      "rightValue": "EXISTING",
                      "operator": {
                        "type": "string",
                        "operation": "equals"
                      },
                      "id": "3db6573d-2127-4c22-855f-afca26e1b811"
                    }
                  ],
                  "combinator": "and"
                },
                "renameOutput": true,
                "outputKey": "existing_client"
              }
            ]
          },
          "options": {}
        },
        "id": "decision-gate-001",
        "name": "Decision Gate",
        "type": "n8n-nodes-base.switch",
        "typeVersion": 3.4,
        "position": [
          2576,
          288
        ]
      },
      {
        "parameters": {
          "jsCode": "// Prepare UNKNOWN client data with simple static naming\n// V3: Use simple UNKNOWN_CLIENT naming instead of timestamp\nconst inputData = $input.first().json;\n\nconst clientName = \"unknown_client\";\n\nreturn [{\n  json: {\n    client_name: clientName,\n    parent_folder_id: inputData.parent_folder_id,\n    client_name_raw: inputData.client_name_raw,\n    client_status: inputData.client_status,\n    root_folder_id: inputData.root_folder_id,\n    staging_folder_id: inputData.staging_folder_id,\n    extraction_failure: inputData.extraction_failure,\n    extraction_error_message: inputData.extraction_error_message,\n    is_unknown_client: true,\n    unknown_timestamp: new Date().toISOString()\n  },\n  binary: $input.first().binary\n}];"
        },
        "id": "prepare-unknown-data-001",
        "name": "Prepare UNKNOWN Client Data",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3024,
          112
        ]
      },
      {
        "parameters": {
          "jsCode": "// Handle unidentified client - send to manual queue\n  const items = $input.all();\n  const results = [];\n\n  for (const item of items) {\n    results.push({\n      json: {\n        status: 'FAILED',\n        reason: 'Client name could not be identified',\n        email_id: item.json.emailId,\n        email_subject: item.json.emailSubject,\n        timestamp: new Date().toISOString()\n      }\n    });\n  }\n\n  return results;"
        },
        "id": "handle-unknown-001",
        "name": "Handle Unidentified Client",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2800,
          112
        ]
      },
      {
        "parameters": {
          "documentId": {
            "__rl": true,
            "mode": "id",
            "value": "1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI"
          },
          "sheetName": {
            "__rl": true,
            "value": 762792134,
            "mode": "list",
            "cachedResultName": "Client_Registry",
            "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1T-jL-cLgplVeZ3EMroQxvGEqI5G7t81jRZ2qINDvXNI/edit#gid=762792134"
          },
          "options": {}
        },
        "id": "lookup-staging-folder-001",
        "name": "Lookup Staging Folder",
        "type": "n8n-nodes-base.googleSheets",
        "typeVersion": 4.7,
        "position": [
          2800,
          592
        ],
        "credentials": {
          "googleSheetsOAuth2Api": {
            "id": "H7ewI1sOrDYabelt",
            "name": "Google Sheets account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// V6: GRACEFUL ERROR HANDLING - No errors thrown, route to 38_Unknowns if missing\n// Extract staging_folder_id from Client Registry lookup AND file_id from upload\nconst clientName = $('Check Client Exists').first().json.client_name;\nconst sheetRows = $input.all();\nconst fileData = $('Extract File ID & Metadata').first().json;\n\n// Find matching row by normalizing Client_Name the same way as \"Normalize Client Name\" node\nconst matchingRow = sheetRows.find(row => {\n  const registryClientName = row.json.Client_Name || '';\n  \n  // Normalize Client_Name to match client_name format\n  const normalizedName = registryClientName\n    .toLowerCase()\n    .trim()\n    .replace(/√§/g, 'ae')\n    .replace(/√∂/g, 'oe')\n    .replace(/√º/g, 'ue')\n    .replace(/√ü/g, 'ss')\n    .replace(/\\s*(gmbh|ag|kg|e\\.v\\.|mbh|co\\.|&\\s*co\\.?)\\s*/gi, '')\n    .replace(/[^a-z0-9]/g, '_')\n    .replace(/_+/g, '_')\n    .replace(/^_|_$/g, '');\n  \n  return normalizedName === clientName;\n});\n\n// GRACEFUL HANDLING: Route to 38_Unknowns if no matching row\nif (!matchingRow) {\n  return [{\n    json: {\n      ...fileData,\n      client_name: clientName,\n      error: `No staging folder found for client: ${clientName}`,\n      routeTo38Unknowns: true,\n      errorType: 'missing_client_in_registry',\n      skipChunk1: true\n    }\n  }];\n}\n\nconst stagingFolderId = matchingRow.json.Staging_Folder_ID || matchingRow.json['01_Staging'];\n\n// GRACEFUL HANDLING: Route to 38_Unknowns if staging folder ID is empty\nif (!stagingFolderId) {\n  return [{\n    json: {\n      ...fileData,\n      client_name: clientName,\n      error: `Staging_Folder_ID is empty for client: ${clientName}`,\n      routeTo38Unknowns: true,\n      errorType: 'missing_staging_folder',\n      skipChunk1: true\n    }\n  }];\n}\n\n// SUCCESS PATH: Continue with staging folder ID\nreturn [{\n  json: {\n    client_name: clientName,\n    staging_folder_id: stagingFolderId,\n    email_id: fileData.emailId,\n    file_id: fileData.file_id,\n    filename: fileData.filename,\n    routeTo38Unknowns: false\n  }\n}];"
        },
        "id": "filter-staging-folder-001",
        "name": "Filter Staging Folder ID",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3024,
          592
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "strict",
              "version": 1
            },
            "conditions": [
              {
                "id": "route-unknowns-check",
                "leftValue": "={{ $json.routeTo38Unknowns }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "true",
                  "singleValue": true
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "check-routing-decision-001",
        "name": "Check Routing Decision",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          3248,
          592
        ]
      },
      {
        "parameters": {
          "jsCode": "// Prepare data for routing to 38_Unknowns when staging folder is missing\nconst item = $input.first().json;\n\n// Create UNKNOWN_CLIENT structure to match existing unknowns path\nreturn [{\n  json: {\n    client_name: 'unknown_client',\n    parent_folder_id: '1ikw3k-EgpVg_h2ySDdqdUFB7-FQyYDFm',\n    client_status: 'UNKNOWN',\n    is_unknown_client: true,\n    error_reason: item.error || 'Missing staging folder',\n    error_type: item.errorType || 'missing_staging_folder',\n    file_id: item.file_id,\n    filename: item.filename,\n    email_id: item.email_id,\n    unknown_timestamp: new Date().toISOString()\n  }\n}];"
        },
        "id": "prepare-missing-folder-error-001",
        "name": "Prepare Missing Folder Error",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3472,
          688
        ]
      },
      {
        "parameters": {
          "jsCode": "// Extract 38_Unknowns folder ID from Chunk 0 response\n// ALSO get file_id from earlier in workflow\n\nconst chunk0Response = $input.first().json;\nconst folderData = chunk0Response.folderIDs || [];\n\nconst unknownsFolder = folderData.find(item =>\n  item.Variable_Name === 'FOLDER_38_UNKNOWNS'\n);\n\nif (!unknownsFolder || !unknownsFolder.Folder_ID) {\n  throw new Error('FOLDER_38_UNKNOWNS not found in Chunk 0 response');\n}\n\n// Get file_id from Extract File ID & Metadata node\nconst fileMetadata = $('Extract File ID & Metadata').first().json;\nconst fileId = fileMetadata.file_id;\n\nif (!fileId) {\n  throw new Error('file_id not found from Extract File ID & Metadata node');\n}\n\nreturn {\n  json: {\n    unknowns_folder_id: unknownsFolder.Folder_ID,\n    temp_pdf_file_id: fileId,\n    root_folder_id: chunk0Response.Root_Folder_ID,\n    client_name: chunk0Response.Client_Name,\n    ...chunk0Response\n  },\n  binary: $input.first().binary\n};\n"
        },
        "id": "extract-unknowns-folder-001",
        "name": "Extract 38_Unknowns Folder ID",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3472,
          112
        ]
      },
      {
        "parameters": {
          "jsCode": "const folderId = $json.unknowns_folder_id;\nconst fileId = $json.temp_pdf_file_id;\n\nif (!folderId || folderId === '') {\n  throw new Error('Missing unknowns_folder_id - cannot move file');\n}\n\nif (!fileId || fileId === '') {\n  throw new Error('Missing temp_pdf_file_id - no file to move');\n}\n\nreturn {\n  json: {\n    unknowns_folder_id: folderId,\n    temp_pdf_file_id: fileId,\n    ...$json\n  },\n  binary: $input.first().binary\n};"
        },
        "id": "validate-folder-ids-001",
        "name": "Validate Folder IDs",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3696,
          112
        ]
      },
      {
        "parameters": {
          "operation": "move",
          "fileId": "={{ $json.temp_pdf_file_id }}",
          "driveId": {
            "__rl": true,
            "mode": "list",
            "value": "My Drive"
          },
          "folderId": {
            "__rl": true,
            "value": "={{ $('Execute Chunk 0 - Create Folders (UNKNOWN)').item.json.folderIDs[43].Folder_ID }}",
            "mode": ""
          }
        },
        "id": "move-pdf-unknowns-001",
        "name": "Move PDF to 38_Unknowns",
        "type": "n8n-nodes-base.googleDrive",
        "typeVersion": 3,
        "position": [
          3920,
          112
        ],
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "a4m50EefR3DJoU0R",
            "name": "Google Drive account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Get data from correct sources\n// CRITICAL FIX: Get root_folder_id from Validate Folder IDs (before Move PDF wiped data)\nconst folderData = $('Validate Folder IDs').first().json;\nconst emailData = $('Gmail Trigger - Unread with Attachments').first().json;\nconst moveResult = $input.first().json;\n\nconst rootFolderId = folderData.Root_Folder_ID || folderData.root_folder_id;\nconst rootFolderName = folderData.Client_Name || folderData.client_name || 'UNKNOWN';\nconst unknownsFolderId = folderData.unknowns_folder_id;\nconst pdfFileId = moveResult.id || folderData.temp_pdf_file_id;\n\nconst pdfLink = `https://drive.google.com/file/d/${pdfFileId}/view`;\nconst rootFolderLink = `https://drive.google.com/drive/folders/${rootFolderId}`;\n\nconst emailFrom = emailData.from || 'Unknown Sender';\nconst emailSubject = emailData.subject || 'No Subject';\nconst pdfFilename = folderData.pdf_filename || 'unknown.pdf';\n\nconst timestamp = new Date().toLocaleString('en-US', {\n  timeZone: 'Europe/Berlin',\n  year: 'numeric',\n  month: '2-digit',\n  day: '2-digit',\n  hour: '2-digit',\n  minute: '2-digit',\n  hour12: false\n});\n\nreturn [{\n  json: {\n    to: 'swayclarkeii@gmail.com',\n    pdf_filename: pdfFilename,\n    email_from: emailFrom,\n    email_subject: emailSubject,\n    root_folder_name: rootFolderName,\n    pdf_link: pdfLink,\n    root_folder_link: rootFolderLink,\n    timestamp: timestamp\n  },\n  binary: $input.first().binary\n}];"
        },
        "id": "prepare-email-data-001",
        "name": "Prepare Email Notification Data",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          4144,
          112
        ]
      },
      {
        "parameters": {
          "jsCode": "// Build HTML email body for UNKNOWN client notification\nconst data = $input.first().json;\n\n// Extract just the email address (not the display name)\nconst emailAddress = data.email_from?.value?.[0]?.address || 'Unknown Sender';\n\nconst htmlBody = `<!DOCTYPE html>\n<html>\n<body style=\"font-family: Arial, sans-serif; line-height: 1.6; color: #333;\">\n  <div style=\"max-width: 600px; margin: 0 auto; padding: 20px;\">\n    <h2 style=\"color: #d32f2f;\">‚ö†Ô∏è Unknown Client Document Received</h2>\n    \n    <p>A document was received but the client could not be identified. Manual review is required.</p>\n    \n    <div style=\"background: #f5f5f5; padding: 15px; border-left: 4px solid #1976d2; margin: 20px 0;\">\n      <h3 style=\"margin-top: 0;\">Document Details</h3>\n      <ul style=\"list-style: none; padding: 0;\">\n        <li><strong>Filename:</strong> ${data.pdf_filename}</li>\n        <li><strong>From:</strong> ${emailAddress}</li>\n        <li><strong>Subject:</strong> ${data.email_subject}</li>\n      </ul>\n    </div>\n    \n    <div style=\"background: #fff3e0; padding: 15px; border-left: 4px solid #f57c00; margin: 20px 0;\">\n      <h3 style=\"margin-top: 0;\">üìÇ Created Folder Structure</h3>\n      <p>A temporary folder structure has been created:</p>\n      <ul style=\"list-style: none; padding: 0;\">\n        <li><strong>Root Folder:</strong> ${data.root_folder_name}</li>\n        <li><strong>Document Location:</strong> SONSTIGES/38_Unknowns/</li>\n      </ul>\n    </div>\n    \n    <div style=\"margin: 30px 0;\">\n      <h3>üîó Quick Actions</h3>\n      <div style=\"margin: 10px 0;\">\n        <a href=\"${data.pdf_link}\" \n           style=\"display: inline-block; padding: 12px 24px; background: #1976d2; color: white; text-decoration: none; border-radius: 4px; margin-right: 10px;\">\n          üìÑ View PDF\n        </a>\n        <a href=\"${data.root_folder_link}\" \n           style=\"display: inline-block; padding: 12px 24px; background: #43a047; color: white; text-decoration: none; border-radius: 4px;\">\n          üìÅ Open Folder Structure\n        </a>\n      </div>\n    </div>\n    \n    <div style=\"background: #e3f2fd; padding: 15px; border-left: 4px solid #1976d2; margin: 20px 0;\">\n      <h3 style=\"margin-top: 0;\">‚úÖ Next Steps</h3>\n      <ol>\n        <li>Review the PDF to identify the client</li>\n        <li>Rename the root folder to the correct client name</li>\n        <li>Update the Client_Registry sheet with the correct client name</li>\n        <li>Move the PDF from 38_Unknowns to the appropriate subfolder</li>\n      </ol>\n    </div>\n    \n    <hr style=\"border: none; border-top: 1px solid #ddd; margin: 30px 0;\">\n    \n    <p style=\"font-size: 12px; color: #666;\">\n      <strong>System:</strong> Eugene AMA Document Organizer V4<br>\n      <strong>Timestamp:</strong> ${data.timestamp}\n    </p>\n  </div>\n</body>\n</html>`;\n\nreturn [{\n  json: {\n    ...data,\n    html_body: htmlBody\n  },\n  binary: $input.first().binary\n}];"
        },
        "id": "build-email-html-001",
        "name": "Build Email HTML Body",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          4368,
          112
        ]
      },
      {
        "parameters": {
          "sendTo": "swayclarkeii@gmail.com",
          "subject": "={{ $json.emailSubject || '[ACTION REQUIRED] Unknown Client Document' }}",
          "message": "={{ $json.html_body }}",
          "options": {}
        },
        "id": "send-email-notification-001",
        "name": "Send Email Notification",
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2,
        "position": [
          4592,
          112
        ],
        "webhookId": "e028968d-b3d1-4dd6-bb18-20d1b6594069",
        "credentials": {
          "gmailOAuth2": {
            "id": "aYzk7sZF8ZVyfOan",
            "name": "Gmail account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "// Format error email data for registry corruption\nconst inputData = $input.all();\n\nconst output = inputData.map(item => {\n  const clientName = item.json.client_name || 'Unknown Client';\n  const fileName = item.json.file_name || 'Unknown File';\n  const emailSubject = item.json.email_subject || 'N/A';\n  const emailFrom = item.json.email_from || 'N/A';\n  const emailDate = item.json.email_date || 'N/A';\n  \n  return {\n    json: {\n      ...item.json,\n      email_to: 'swayclarkeii@gmail.com',\n      email_subject: `[URGENT] Registry Error: ${clientName} - Missing Staging Folder`,\n      email_message: `CRITICAL REGISTRY ERROR DETECTED\n\nClient: ${clientName}\nError Type: Client marked EXISTING but staging_folder_id is MISSING in Client Registry\n\n--- ACTION TAKEN ---\nFile moved to 38_Unknowns folder for manual review\n\n--- ORIGINAL EMAIL DETAILS ---\nSubject: ${emailSubject}\nFrom: ${emailFrom}\nDate: ${emailDate}\nAttachment: ${fileName}\n\n--- NEXT STEPS ---\nPlease:\n1. Open the Client Registry spreadsheet\n2. Find the row for \"${clientName}\"\n3. Add the missing staging_folder_id to column E\n4. Manually move the file from 38_Unknowns to the correct staging folder\n\nThis is a data integrity issue that needs immediate attention.\n\n---\nWorkflow: AMA Pre-Chunk 0\nNode: Registry Error Handler`\n    }\n  };\n});\n\nreturn output;"
        },
        "id": "prepare-registry-error-email-001",
        "name": "Prepare Registry Error Email Data",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3696,
          688
        ]
      },
      {
        "parameters": {
          "sendTo": "={{ $json.email_to }}",
          "subject": "={{ $json.email_subject }}",
          "message": "={{ $json.email_message }}",
          "options": {}
        },
        "id": "send-registry-error-email-001",
        "name": "Send Registry Error Email",
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          3920,
          688
        ],
        "webhookId": "6b7c8ac4-c32d-40d5-b4d0-44a55bc16b79",
        "credentials": {
          "gmailOAuth2": {
            "id": "aYzk7sZF8ZVyfOan",
            "name": "Gmail account"
          }
        }
      },
      {
        "parameters": {
          "operation": "move",
          "fileId": {
            "__rl": true,
            "mode": "id",
            "value": "={{ $json.file_id }}"
          },
          "driveId": {
            "__rl": true,
            "mode": "list",
            "value": "My Drive"
          },
          "folderId": {
            "__rl": true,
            "mode": "list",
            "value": "1qdUu-dIkQR0oDaZKAL_8OhI0jST89_Vu"
          }
        },
        "id": "move-to-unknowns-registry-001",
        "name": "Move to 38_Unknowns (Registry Error)",
        "type": "n8n-nodes-base.googleDrive",
        "typeVersion": 3,
        "position": [
          4144,
          688
        ],
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "a4m50EefR3DJoU0R",
            "name": "Google Drive account"
          }
        }
      },
      {
        "parameters": {
          "operation": "addLabels",
          "messageId": "={{ $json.email_id }}",
          "labelIds": [
            "INBOX"
          ]
        },
        "id": "mark-read-registry-error-001",
        "name": "Mark Email as Read (Registry Error)",
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          4368,
          688
        ],
        "webhookId": "f229ca84-1e69-43a0-90a0-f6ac4544b40f",
        "credentials": {
          "gmailOAuth2": {
            "id": "aYzk7sZF8ZVyfOan",
            "name": "Gmail account"
          }
        }
      },
      {
        "parameters": {},
        "id": "noop-registry-complete-001",
        "name": "NoOp - Registry Error Complete",
        "type": "n8n-nodes-base.noOp",
        "typeVersion": 1,
        "position": [
          4592,
          688
        ]
      },
      {
        "parameters": {
          "jsCode": "// Merge Chunk 0 output with original file data for NEW client path\nconst chunk0Output = $input.first().json;\n\n// Get file_id from Extract File ID & Metadata node (far upstream)\nconst fileMetadata = $('Extract File ID & Metadata').first().json;\n\nreturn [{\n  json: {\n    ...chunk0Output,\n    file_id: fileMetadata.file_id,\n    email_id: fileMetadata.emailId,\n    filename: fileMetadata.filename\n  }\n}];"
        },
        "id": "0180f051-407b-453b-89fc-faaf3439c20d",
        "name": "Merge Chunk 0 Output (NEW)",
        "type": "n8n-nodes-base.code",
        "typeVersion": 1,
        "position": [
          3024,
          304
        ]
      },
      {
        "parameters": {
          "jsCode": "// Get Google Drive upload result from previous node\nconst driveUpload = $input.first().json;\n\n// Retrieve email metadata from Gmail Trigger\nconst emailData = $('Gmail Trigger - Unread with Attachments').first().json;\n\n// Retrieve binary metadata from Gmail Trigger\nconst binaryData = $('Gmail Trigger - Unread with Attachments').first().binary;\n\n// Get first attachment key\nconst attachmentKeys = Object.keys(binaryData);\nconst attachmentKey = attachmentKeys[0];\nconst attachment = binaryData[attachmentKey];\n\n// Extract file extension from filename\nconst fileName = driveUpload.name;\nconst extension = fileName.substring(fileName.lastIndexOf('.') + 1).toLowerCase();\n\n// Get client data from Normalize Client Name node\nconst clientData = $('Normalize Client Name').first().json;\nconst clientName = clientData.client_name || 'unknown';\n\n// Construct stagingPath\nconst stagingPath = `${clientName}/_Staging/${fileName}`;\n\n// Parse file size\nlet fileSizeBytes = 0;\nif (attachment.fileSize) {\n  const sizeStr = attachment.fileSize;\n  const match = sizeStr.match(/^([\\d.]+)\\s*(KB|MB|GB)$/i);\n  if (match) {\n    const value = parseFloat(match[1]);\n    const unit = match[2].toUpperCase();\n    const multipliers = { KB: 1024, MB: 1024 * 1024, GB: 1024 * 1024 * 1024 };\n    fileSizeBytes = Math.round(value * multipliers[unit]);\n  }\n}\n\n// Extract email sender\nlet emailFrom = '';\nif (emailData.from && emailData.from.value && emailData.from.value[0]) {\n  emailFrom = emailData.from.value[0].address;\n}\n\n// ‚úÖ NEW: Get extracted text from Evaluate Extraction Quality node\nconst extractionData = $('Evaluate Extraction Quality').first().json;\nconst extractedText = extractionData.extractedText || '';\nconst extractionMethod = extractionData.extractionMethod || 'digital_pre_chunk';\nconst textLength = extractionData.textLength || 0;\n\n// Build complete Chunk 2 input\nreturn [{\n  json: {\n    fileId: driveUpload.id,\n    fileName: driveUpload.name,\n    mimeType: driveUpload.mimeType,\n    extension: extension,\n    size: fileSizeBytes,\n    emailId: emailData.id,\n    emailFrom: emailFrom,\n    emailSubject: emailData.subject,\n    emailDate: emailData.date,\n    stagingPath: stagingPath,\n    originalFileName: attachment.fileName,\n    extractedFromZip: false,\n    zipFileName: null,\n    client_name: clientData.client_name_raw,\n    client_normalized: clientData.client_name,\n    \n    // ‚úÖ NEW: Pass extracted text to Chunk 2 (skip re-download)\n    extractedText: extractedText,\n    extractionMethod: extractionMethod,\n    textLength: textLength,\n    skipDownload: textLength > 100  // Skip download if we have meaningful text\n  }\n}];"
        },
        "id": "prepare-chunk2-new-001",
        "name": "Prepare for Chunk 2 (NEW)",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3472,
          304
        ],
        "notes": "Enriches Google Drive data with email metadata for Chunk 2"
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "mode": "id",
            "value": "g9J5kjVtqaF9GLyc"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "id": "={{ $json.fileId }}",
              "name": "={{ $json.fileName }}",
              "mimeType": "={{ $json.mimeType }}",
              "client_normalized": "={{ $json.client_normalized }}",
              "staging_folder_id": "={{ $json.stagingPath }}",
              "extractedText": "={{ $json.extractedText }}",
              "extractionMethod": "={{ $json.extractionMethod }}",
              "textLength": "={{ $json.textLength }}",
              "skipDownload": "={{ $json.skipDownload }}"
            },
            "schema": [
              {
                "id": "id",
                "displayName": "id",
                "required": false,
                "type": "string"
              },
              {
                "id": "name",
                "displayName": "name",
                "required": false,
                "type": "string"
              },
              {
                "id": "mimeType",
                "displayName": "mimeType",
                "required": false,
                "type": "string"
              },
              {
                "id": "client_normalized",
                "displayName": "client_normalized",
                "required": false,
                "type": "string"
              },
              {
                "id": "staging_folder_id",
                "displayName": "staging_folder_id",
                "required": false,
                "type": "string"
              },
              {
                "id": "extractedText",
                "displayName": "extractedText",
                "required": false,
                "type": "string"
              },
              {
                "id": "extractionMethod",
                "displayName": "extractionMethod",
                "required": false,
                "type": "string"
              },
              {
                "id": "textLength",
                "displayName": "textLength",
                "required": false,
                "type": "number"
              },
              {
                "id": "skipDownload",
                "displayName": "skipDownload",
                "required": false,
                "type": "boolean"
              }
            ],
            "convertFieldsToString": false,
            "attemptToConvertTypes": true
          }
        },
        "id": "execute-chunk2-new-001",
        "name": "Execute Chunk 2 (NEW)",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.3,
        "position": [
          3696,
          304
        ],
        "notes": "Executes Chunk 2 text extraction workflow"
      },
      {
        "parameters": {
          "operation": "markAsRead",
          "messageId": "={{ $('Gmail Trigger - Unread with Attachments').first().json.id }}"
        },
        "id": "mark-read-new-001",
        "name": "Mark Email as Read (NEW)",
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          3920,
          304
        ],
        "webhookId": "9967ebd9-7776-4d6d-a993-a3c7353a8c26",
        "credentials": {
          "gmailOAuth2": {
            "id": "aYzk7sZF8ZVyfOan",
            "name": "Gmail account"
          }
        },
        "notes": "Marks the processed email as read"
      },
      {
        "parameters": {},
        "id": "noop-new-complete-001",
        "name": "NoOp - NEW Complete",
        "type": "n8n-nodes-base.noOp",
        "typeVersion": 1,
        "position": [
          4144,
          304
        ]
      },
      {
        "parameters": {
          "jsCode": "// Get Google Drive upload result from previous node\nconst driveUpload = $input.first().json;\n\n// Retrieve email metadata from Gmail Trigger\nconst emailData = $('Gmail Trigger - Unread with Attachments').first().json;\n\n// Retrieve binary metadata from Gmail Trigger\nconst binaryData = $('Gmail Trigger - Unread with Attachments').first().binary;\n\n// Get first attachment key\nconst attachmentKeys = Object.keys(binaryData);\nconst attachmentKey = attachmentKeys[0];\nconst attachment = binaryData[attachmentKey];\n\n// Extract file extension from filename\nconst fileName = driveUpload.name;\nconst extension = fileName.substring(fileName.lastIndexOf('.') + 1).toLowerCase();\n\n// Get client data from Normalize Client Name node\nconst clientData = $('Normalize Client Name').first().json;\nconst clientName = clientData.client_name || 'unknown';\n\n// Construct stagingPath\nconst stagingPath = `${clientName}/_Staging/${fileName}`;\n\n// Parse file size\nlet fileSizeBytes = 0;\nif (attachment.fileSize) {\n  const sizeStr = attachment.fileSize;\n  const match = sizeStr.match(/^([\\d.]+)\\s*(KB|MB|GB)$/i);\n  if (match) {\n    const value = parseFloat(match[1]);\n    const unit = match[2].toUpperCase();\n    const multipliers = { KB: 1024, MB: 1024 * 1024, GB: 1024 * 1024 * 1024 };\n    fileSizeBytes = Math.round(value * multipliers[unit]);\n  }\n}\n\n// Extract email sender\nlet emailFrom = '';\nif (emailData.from && emailData.from.value && emailData.from.value[0]) {\n  emailFrom = emailData.from.value[0].address;\n}\n\n// ‚úÖ NEW: Get extracted text from Evaluate Extraction Quality node\nconst extractionData = $('Evaluate Extraction Quality').first().json;\nconst extractedText = extractionData.extractedText || '';\nconst extractionMethod = extractionData.extractionMethod || 'digital_pre_chunk';\nconst textLength = extractionData.textLength || 0;\n\n// Build complete Chunk 2 input\nreturn [{\n  json: {\n    fileId: driveUpload.id,\n    fileName: driveUpload.name,\n    mimeType: driveUpload.mimeType,\n    extension: extension,\n    size: fileSizeBytes,\n    emailId: emailData.id,\n    emailFrom: emailFrom,\n    emailSubject: emailData.subject,\n    emailDate: emailData.date,\n    stagingPath: stagingPath,\n    originalFileName: attachment.fileName,\n    extractedFromZip: false,\n    zipFileName: null,\n    client_name: clientData.client_name_raw,\n    client_normalized: clientData.client_name,\n    \n    // ‚úÖ NEW: Pass extracted text to Chunk 2 (skip re-download)\n    extractedText: extractedText,\n    extractionMethod: extractionMethod,\n    textLength: textLength,\n    skipDownload: textLength > 100  // Skip download if we have meaningful text\n  }\n}];"
        },
        "id": "prepare-chunk2-existing-001",
        "name": "Prepare for Chunk 2 (EXISTING)",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3696,
          496
        ],
        "notes": "Enriches Google Drive data with email metadata for Chunk 2"
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "mode": "id",
            "value": "g9J5kjVtqaF9GLyc"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "id": "={{ $json.fileId }}",
              "name": "={{ $json.fileName }}",
              "mimeType": "={{ $json.mimeType }}",
              "client_normalized": "={{ $json.client_normalized }}",
              "staging_folder_id": "={{ $json.stagingPath }}",
              "extractedText": "={{ $json.extractedText }}",
              "extractionMethod": "={{ $json.extractionMethod }}",
              "textLength": "={{ $json.textLength }}",
              "skipDownload": "={{ $json.skipDownload }}"
            },
            "schema": [
              {
                "id": "id",
                "displayName": "id",
                "required": false,
                "type": "string"
              },
              {
                "id": "name",
                "displayName": "name",
                "required": false,
                "type": "string"
              },
              {
                "id": "mimeType",
                "displayName": "mimeType",
                "required": false,
                "type": "string"
              },
              {
                "id": "client_normalized",
                "displayName": "client_normalized",
                "required": false,
                "type": "string"
              },
              {
                "id": "staging_folder_id",
                "displayName": "staging_folder_id",
                "required": false,
                "type": "string"
              },
              {
                "id": "extractedText",
                "displayName": "extractedText",
                "required": false,
                "type": "string"
              },
              {
                "id": "extractionMethod",
                "displayName": "extractionMethod",
                "required": false,
                "type": "string"
              },
              {
                "id": "textLength",
                "displayName": "textLength",
                "required": false,
                "type": "number"
              },
              {
                "id": "skipDownload",
                "displayName": "skipDownload",
                "required": false,
                "type": "boolean"
              }
            ],
            "convertFieldsToString": false,
            "attemptToConvertTypes": true
          }
        },
        "id": "execute-chunk2-existing-001",
        "name": "Execute Chunk 2 (EXISTING)",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.3,
        "position": [
          3920,
          496
        ],
        "notes": "Executes Chunk 2 text extraction workflow"
      },
      {
        "parameters": {
          "operation": "markAsRead",
          "messageId": "={{ $('Gmail Trigger - Unread with Attachments').first().json.id }}"
        },
        "id": "mark-read-existing-001",
        "name": "Mark Email as Read (EXISTING)",
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          4144,
          496
        ],
        "webhookId": "64c1fe12-1ad8-47a2-b59a-502812a88c50",
        "credentials": {
          "gmailOAuth2": {
            "id": "aYzk7sZF8ZVyfOan",
            "name": "Gmail account"
          }
        },
        "notes": "Marks the processed email as read"
      },
      {
        "parameters": {},
        "id": "noop-existing-complete-001",
        "name": "NoOp - EXISTING Complete",
        "type": "n8n-nodes-base.noOp",
        "typeVersion": 1,
        "position": [
          4368,
          496
        ]
      },
      {
        "parameters": {
          "operation": "move",
          "fileId": {
            "__rl": true,
            "value": "={{ $json.file_id }}",
            "mode": "id"
          },
          "driveId": {
            "__rl": true,
            "mode": "list",
            "value": "My Drive"
          },
          "folderId": {
            "__rl": true,
            "value": "={{ $json.Staging_Folder_ID }}",
            "mode": "id"
          }
        },
        "id": "b767c01a-345c-4a94-ba35-35f8dda0fb2c",
        "name": "Move PDF to _Staging (NEW)",
        "type": "n8n-nodes-base.googleDrive",
        "typeVersion": 3,
        "position": [
          3248,
          304
        ],
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "a4m50EefR3DJoU0R",
            "name": "Google Drive account"
          }
        }
      },
      {
        "parameters": {
          "operation": "move",
          "fileId": {
            "__rl": true,
            "value": "={{ $json.file_id }}",
            "mode": "id"
          },
          "driveId": {
            "__rl": true,
            "mode": "list",
            "value": "My Drive"
          },
          "folderId": {
            "__rl": true,
            "value": "={{ $json.Staging_Folder_ID }}",
            "mode": "id"
          }
        },
        "id": "90cc99fd-908d-4149-a2f7-35f42ab2e232",
        "name": "Move PDF to _Staging (EXISTING)",
        "type": "n8n-nodes-base.googleDrive",
        "typeVersion": 3,
        "position": [
          3472,
          496
        ],
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "a4m50EefR3DJoU0R",
            "name": "Google Drive account"
          }
        }
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "value": "zbxHkXOoD1qaz6OS",
            "mode": "list",
            "cachedResultUrl": "/workflow/zbxHkXOoD1qaz6OS",
            "cachedResultName": "AMA Chunk 0: Folder Initialization (V4 - Parameterized)"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "client_name": "={{ $json.client_name_raw }}",
              "client_normalized": "={{ $json.client_name }}",
              "parent_folder_id": "={{ $('Check Client Exists').item.json.parent_folder_id }}"
            },
            "matchingColumns": [],
            "schema": [
              {
                "id": "client_name",
                "displayName": "client_name",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "client_normalized",
                "displayName": "client_normalized",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "parent_folder_id",
                "displayName": "parent_folder_id",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              }
            ],
            "attemptToConvertTypes": false,
            "convertFieldsToString": true
          },
          "options": {}
        },
        "id": "bc9b052a-1fdf-412c-990a-7c3e58178304",
        "name": "Execute Chunk 0 - Create Folders (UNKNOWN)",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.3,
        "position": [
          3248,
          112
        ]
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "value": "zbxHkXOoD1qaz6OS",
            "mode": "list",
            "cachedResultUrl": "/workflow/zbxHkXOoD1qaz6OS",
            "cachedResultName": "AMA Chunk 0: Folder Initialization (V4 - Parameterized)"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "client_name": "={{ $json.client_name_raw }}",
              "client_normalized": "={{ $json.client_name }}",
              "parent_folder_id": "={{ $('Check Client Exists').item.json.parent_folder_id }}"
            },
            "matchingColumns": [],
            "schema": [
              {
                "id": "client_name",
                "displayName": "client_name",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "client_normalized",
                "displayName": "client_normalized",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              },
              {
                "id": "parent_folder_id",
                "displayName": "parent_folder_id",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "canBeUsedToMatch": true,
                "type": "string"
              }
            ],
            "attemptToConvertTypes": false,
            "convertFieldsToString": true
          },
          "options": {}
        },
        "id": "execute-chunk0-001",
        "name": "Execute Chunk 0 - Create Folders (NEW)",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.3,
        "position": [
          2800,
          304
        ]
      }
    ],
    "connections": {
      "Gmail Trigger - Unread with Attachments": {
        "main": [
          [
            {
              "node": "Filter PDF/ZIP Attachments",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Filter PDF/ZIP Attachments": {
        "main": [
          [
            {
              "node": "Upload PDF to Temp Folder",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Upload PDF to Temp Folder": {
        "main": [
          [
            {
              "node": "Extract File ID & Metadata",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract File ID & Metadata": {
        "main": [
          [
            {
              "node": "Download PDF from Drive",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Download PDF from Drive": {
        "main": [
          [
            {
              "node": "Extract Text from PDF",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract Text from PDF": {
        "main": [
          [
            {
              "node": "Evaluate Extraction Quality",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Evaluate Extraction Quality": {
        "main": [
          [
            {
              "node": "AI Extract Client Name",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "AI Extract Client Name": {
        "main": [
          [
            {
              "node": "Normalize Client Name",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Normalize Client Name": {
        "main": [
          [
            {
              "node": "Lookup Client Registry",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Lookup Client Registry": {
        "main": [
          [
            {
              "node": "Check Client Exists",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check Client Exists": {
        "main": [
          [
            {
              "node": "Decision Gate",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Decision Gate": {
        "main": [
          [
            {
              "node": "Handle Unidentified Client",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Execute Chunk 0 - Create Folders (NEW)",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Lookup Staging Folder",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare UNKNOWN Client Data": {
        "main": [
          [
            {
              "node": "Execute Chunk 0 - Create Folders (UNKNOWN)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Lookup Staging Folder": {
        "main": [
          [
            {
              "node": "Filter Staging Folder ID",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Filter Staging Folder ID": {
        "main": [
          [
            {
              "node": "Check Routing Decision",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract 38_Unknowns Folder ID": {
        "main": [
          [
            {
              "node": "Validate Folder IDs",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Validate Folder IDs": {
        "main": [
          [
            {
              "node": "Move PDF to 38_Unknowns",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Move PDF to 38_Unknowns": {
        "main": [
          [
            {
              "node": "Prepare Email Notification Data",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Email Notification Data": {
        "main": [
          [
            {
              "node": "Build Email HTML Body",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Email HTML Body": {
        "main": [
          [
            {
              "node": "Send Email Notification",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Handle Unidentified Client": {
        "main": [
          [
            {
              "node": "Prepare UNKNOWN Client Data",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check Routing Decision": {
        "main": [
          [
            {
              "node": "Prepare Missing Folder Error",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Move PDF to _Staging (EXISTING)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Missing Folder Error": {
        "main": [
          [
            {
              "node": "Prepare Registry Error Email Data",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Registry Error Email Data": {
        "main": [
          [
            {
              "node": "Send Registry Error Email",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Send Registry Error Email": {
        "main": [
          [
            {
              "node": "Move to 38_Unknowns (Registry Error)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Move to 38_Unknowns (Registry Error)": {
        "main": [
          [
            {
              "node": "Mark Email as Read (Registry Error)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Mark Email as Read (Registry Error)": {
        "main": [
          [
            {
              "node": "NoOp - Registry Error Complete",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Merge Chunk 0 Output (NEW)": {
        "main": [
          [
            {
              "node": "Move PDF to _Staging (NEW)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare for Chunk 2 (NEW)": {
        "main": [
          [
            {
              "node": "Execute Chunk 2 (NEW)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Execute Chunk 2 (NEW)": {
        "main": [
          [
            {
              "node": "Mark Email as Read (NEW)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Mark Email as Read (NEW)": {
        "main": [
          [
            {
              "node": "NoOp - NEW Complete",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare for Chunk 2 (EXISTING)": {
        "main": [
          [
            {
              "node": "Execute Chunk 2 (EXISTING)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Execute Chunk 2 (EXISTING)": {
        "main": [
          [
            {
              "node": "Mark Email as Read (EXISTING)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Mark Email as Read (EXISTING)": {
        "main": [
          [
            {
              "node": "NoOp - EXISTING Complete",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Move PDF to _Staging (NEW)": {
        "main": [
          [
            {
              "node": "Prepare for Chunk 2 (NEW)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Move PDF to _Staging (EXISTING)": {
        "main": [
          [
            {
              "node": "Prepare for Chunk 2 (EXISTING)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Execute Chunk 0 - Create Folders (UNKNOWN)": {
        "main": [
          [
            {
              "node": "Extract 38_Unknowns Folder ID",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Execute Chunk 0 - Create Folders (NEW)": {
        "main": [
          [
            {
              "node": "Merge Chunk 0 Output (NEW)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "Sway Clarke",
    "name": null,
    "description": null,
    "autosaved": false,
    "workflowPublishHistory": [
      {
        "createdAt": "2026-01-08T23:17:42.010Z",
        "id": 497,
        "workflowId": "YGXWjWcBIk66ArvT",
        "versionId": "81a40793-6d75-4fe0-a191-f8a5de1f462f",
        "event": "activated",
        "userId": "e9bd9112-c2e3-4f67-873a-e1001baeafd8"
      }
    ]
  }
}
