{
  "name": "Document Organizer V3.5 - Complete Workflow (Phase 1 with Project Tracking)",
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        },
        "filters": {
          "labelIds": ["{{ $vars.GMAIL_LABEL_ID || 'Bautraeger_Docs' }}"]
        },
        "options": {
          "attachments": true,
          "downloadAttachments": false
        }
      },
      "name": "Gmail Trigger: Watch for Labeled Emails",
      "type": "n8n-nodes-base.gmailTrigger",
      "typeVersion": 1,
      "position": [240, 400],
      "id": "c1-node-gmail-trigger",
      "credentials": {
        "gmailOAuth2": {
          "id": "{{GMAIL_CREDENTIAL_ID}}",
          "name": "Gmail OAuth2"
        }
      },
      "notes": "Triggers when email with Bautraeger_Docs label is detected. Checks every minute for new emails with attachments."
    },
    {
      "parameters": {
        "options": {
          "dataPropertyAttachmentsPrefixName": "attachment_"
        }
      },
      "name": "Download All Attachments",
      "type": "n8n-nodes-base.emailReadImap",
      "typeVersion": 2,
      "position": [460, 400],
      "id": "c1-node-download-attachments",
      "notes": "Downloads all attachments from the email. Stores each attachment as binary data with prefix 'attachment_'."
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $binary.attachment_0.fileName }}",
              "operation": "endsWith",
              "value2": ".zip"
            }
          ]
        }
      },
      "name": "IF: Is ZIP Archive?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [680, 400],
      "id": "c1-node-if-zip",
      "notes": "Checks if attachment is a ZIP archive by examining file extension. Routes to extraction if true, continues normally if false."
    },
    {
      "parameters": {
        "binaryPropertyName": "attachment_0",
        "options": {}
      },
      "name": "Extract ZIP Contents",
      "type": "n8n-nodes-base.decompress",
      "typeVersion": 1,
      "position": [900, 300],
      "id": "c1-node-extract-zip",
      "notes": "Extracts all files from ZIP archive. Each extracted file becomes a separate item with binary data. (TRUE branch)"
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "mergeByPosition",
        "options": {}
      },
      "name": "Merge: Combine All Files",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [1120, 400],
      "id": "c1-node-merge-files",
      "notes": "Combines files from both paths: extracted ZIP contents (if any) + regular attachments. All files proceed together."
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $binary.attachment_0.mimeType }}",
              "operation": "contains",
              "value2": "pdf"
            },
            {
              "value1": "={{ $binary.attachment_0.mimeType }}",
              "operation": "contains",
              "value2": "word"
            },
            {
              "value1": "={{ $binary.attachment_0.mimeType }}",
              "operation": "contains",
              "value2": "document"
            }
          ],
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "combineOperation": "any"
        }
      },
      "name": "Filter: PDF and DOCX Only",
      "type": "n8n-nodes-base.filter",
      "typeVersion": 1,
      "position": [1340, 400],
      "id": "c1-node-filter-files",
      "notes": "Keeps only PDF and DOCX files. Filters out images (JPG, PNG), spreadsheets (XLSX), and other file types. Prevents processing of irrelevant attachments."
    },
    {
      "parameters": {
        "operation": "upload",
        "fileContent": "={{ $binary.attachment_0 }}",
        "name": "={{ $binary.attachment_0.fileName }}",
        "driveId": {
          "__rl": true,
          "mode": "list",
          "value": "My Drive"
        },
        "folderId": {
          "__rl": true,
          "mode": "id",
          "value": "={{ $vars.FOLDER_STAGING }}"
        },
        "options": {
          "googleFileConvert": false
        }
      },
      "name": "Upload to Staging Folder",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [1560, 400],
      "id": "c1-node-upload-staging",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "{{GOOGLE_DRIVE_CREDENTIAL_ID}}",
          "name": "Google Drive OAuth2"
        }
      },
      "notes": "Uploads file to Google Drive staging folder (_Staging). Preserves original filename. Returns Drive file ID for next chunk. Does NOT convert to Google Docs format."
    },
    {
      "parameters": {
        "jsCode": "// Detect if PDF is scanned (image-based) or digital (text-selectable)\n// Scanned PDFs need OCR, digital PDFs can extract text directly\n\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  let needsOCR = false;\n  let detectionMethod = 'unknown';\n  \n  const fileName = item.json.name || item.binary?.attachment_0?.fileName || 'unknown';\n  const mimeType = item.json.mimeType || item.binary?.attachment_0?.mimeType || '';\n  \n  // DOCX files never need OCR\n  if (mimeType.includes('word') || mimeType.includes('document') || fileName.toLowerCase().endsWith('.docx')) {\n    needsOCR = false;\n    detectionMethod = 'file_type_docx';\n  }\n  // For PDFs, we'll assume digital by default\n  // In production, you could analyze the PDF structure to detect if it's image-based\n  // For now, we'll route to digital extraction and only use OCR if extraction fails\n  else if (mimeType.includes('pdf') || fileName.toLowerCase().endsWith('.pdf')) {\n    needsOCR = false; // Try digital first\n    detectionMethod = 'pdf_assumed_digital';\n  }\n  else {\n    // Unknown file type, try digital extraction\n    needsOCR = false;\n    detectionMethod = 'unknown_try_digital';\n  }\n  \n  results.push({\n    json: {\n      ...item.json,\n      needsOCR: needsOCR,\n      detectionMethod: detectionMethod,\n      originalFileName: fileName,\n      originalMimeType: mimeType\n    },\n    binary: item.binary\n  });\n}\n\nreturn results;"
      },
      "name": "Detect: Scan vs Digital",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1780, 400],
      "id": "c2-node-detect-scan",
      "notes": "Determines if document needs OCR (scanned/image-based) or can extract text directly (digital). DOCX always skips OCR. PDFs assume digital first."
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.needsOCR }}",
              "value2": true
            }
          ]
        }
      },
      "name": "IF: Needs OCR?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [2000, 400],
      "id": "c2-node-if-needs-ocr",
      "notes": "Routes to OCR path (TRUE) for scanned documents, or direct text extraction (FALSE) for digital documents."
    },
    {
      "parameters": {
        "operation": "extractText",
        "binaryPropertyName": "attachment_0",
        "options": {}
      },
      "name": "Extract Text (Digital PDF/DOCX)",
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [2220, 500],
      "id": "c2-node-extract-text-digital",
      "notes": "Extracts selectable text from digital PDFs and DOCX files. (FALSE branch - no OCR needed)"
    },
    {
      "parameters": {
        "operation": "detectText",
        "binaryPropertyName": "attachment_0",
        "options": {
          "languagesList": ["deu"]
        }
      },
      "name": "AWS Textract: OCR (German)",
      "type": "n8n-nodes-base.awsTextract",
      "typeVersion": 1,
      "position": [2220, 300],
      "id": "c2-node-aws-textract",
      "credentials": {
        "aws": {
          "id": "{{AWS_CREDENTIAL_ID}}",
          "name": "AWS"
        }
      },
      "notes": "Performs OCR on scanned/image-based PDFs using AWS Textract with German language support. (TRUE branch)"
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "mergeByPosition",
        "options": {}
      },
      "name": "Merge: Text Outputs",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [2440, 400],
      "id": "c2-node-merge-text",
      "notes": "Combines text from both extraction paths (OCR or digital). Only one path will have data per document."
    },
    {
      "parameters": {
        "jsCode": "// Prepare extracted text for AI classification\n// Truncate to 3000 characters to stay within AI context limits\n// Preserve German characters (ä, ö, ü, ß)\n\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  let extractedText = '';\n  let textSource = 'unknown';\n  let textQuality = 'good';\n  \n  // Get text from either OCR or digital extraction\n  if (item.json.text) {\n    extractedText = item.json.text;\n    textSource = item.json.needsOCR ? 'ocr' : 'digital';\n  } else if (item.json.extractedText) {\n    extractedText = item.json.extractedText;\n    textSource = 'digital';\n  } else {\n    // No text extracted - might be empty document or extraction failed\n    extractedText = '';\n    textQuality = 'failed';\n  }\n  \n  // Clean and normalize text\n  extractedText = String(extractedText).trim();\n  \n  // Assess text quality (basic heuristic)\n  if (extractedText.length < 50) {\n    textQuality = 'poor';\n  } else if (extractedText.length < 200) {\n    textQuality = 'partial';\n  }\n  \n  // Truncate to 3000 characters for AI input\n  const truncatedText = extractedText.substring(0, 3000);\n  const wasTruncated = extractedText.length > 3000;\n  \n  results.push({\n    json: {\n      ...item.json,\n      extractedText: truncatedText,\n      textForClassification: truncatedText,\n      originalTextLength: extractedText.length,\n      textTruncated: wasTruncated,\n      textSource: textSource,\n      textQuality: textQuality\n    },\n    binary: item.binary\n  });\n}\n\nreturn results;"
      },
      "name": "Prepare Text for AI",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2660, 400],
      "id": "c2-node-prepare-ai-input",
      "notes": "Cleans and truncates extracted text to 3000 characters for AI classification. Assesses text quality. Preserves German special characters."
    },
    {
      "parameters": {
        "resource": "text",
        "operation": "message",
        "modelId": "gpt-4o-mini",
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are a property/project name extraction assistant for German real estate construction projects (Bauträger). Extract the property or project name from the provided document text.\n\nRETURN FORMAT (JSON only):\n{\n  \"projectName\": \"Exact property/project name\",\n  \"confidence\": \"high/medium/low\",\n  \"extractedFrom\": \"Brief quote showing where name was found\"\n}\n\nEXAMPLES:\n- \"Neubau Müller Apartmenthaus, Berlin\" → {\"projectName\": \"Müller Apartmenthaus\", \"confidence\": \"high\", \"extractedFrom\": \"Neubau Müller Apartmenthaus, Berlin\"}\n- \"Wohnanlage Schmidt-Straße 15\" → {\"projectName\": \"Wohnanlage Schmidt-Straße 15\", \"confidence\": \"high\", \"extractedFrom\": \"Wohnanlage Schmidt-Straße 15\"}\n- Document with unclear property reference → {\"projectName\": \"Unknown Project\", \"confidence\": \"low\", \"extractedFrom\": \"No clear project name found\"}\n\nKEY PATTERNS:\n- Look for \"Projekt:\", \"Objekt:\", \"Bauvorhaben:\", \"Wohnanlage:\"\n- Look for street addresses (Straße, Weg, Platz)\n- Look for distinctive property names\n- If multiple names found, use the most prominent one\n\nIMPORTANT:\n- Return ONLY valid JSON\n- If no clear project name found, use \"Unknown Project\" with low confidence\n- Keep project names concise (max 50 characters)"
            },
            {
              "role": "user",
              "content": "=Extract the property/project name from this German real estate document:\n\n{{ $json.extractedText }}\n\nReturn JSON only."
            }
          ]
        },
        "options": {
          "temperature": 0.2,
          "maxTokens": 150
        }
      },
      "name": "OpenAI: Extract Project Name",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.3,
      "position": [2880, 400],
      "id": "c2.5-node-extract-project-name",
      "credentials": {
        "openAiApi": {
          "id": "{{OPENAI_CREDENTIAL_ID}}",
          "name": "OpenAI API"
        }
      },
      "notes": "Uses GPT-4o-mini to extract property/project name from document text"
    },
    {
      "parameters": {
        "jsCode": "// Parse OpenAI response and extract project name\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  let projectName = 'Unknown Project';\n  let confidence = 'low';\n  let extractedFrom = '';\n  \n  try {\n    // Get AI response\n    const aiResponse = item.json.output;\n    \n    // Try to parse as JSON\n    let parsed;\n    if (typeof aiResponse === 'string') {\n      // Remove markdown code blocks if present\n      const cleaned = aiResponse.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n      parsed = JSON.parse(cleaned);\n    } else {\n      parsed = aiResponse;\n    }\n    \n    // Extract project name\n    if (parsed.projectName && parsed.projectName !== 'Unknown Project') {\n      projectName = parsed.projectName.trim();\n      confidence = parsed.confidence || 'medium';\n      extractedFrom = parsed.extractedFrom || '';\n    }\n  } catch (error) {\n    // If parsing fails, try to extract from raw text\n    console.log('Failed to parse AI response as JSON:', error.message);\n    \n    // Fallback: Look for common patterns in raw response\n    const aiText = String(item.json.output || '');\n    const patterns = [\n      /\"projectName\"\\s*:\\s*\"([^\"]+)\"/,\n      /projectName:\\s*\"([^\"]+)\"/,\n      /Projekt:\\s*([^\\n,]+)/,\n      /Objekt:\\s*([^\\n,]+)/\n    ];\n    \n    for (const pattern of patterns) {\n      const match = aiText.match(pattern);\n      if (match && match[1] && match[1] !== 'Unknown Project') {\n        projectName = match[1].trim();\n        confidence = 'medium';\n        break;\n      }\n    }\n  }\n  \n  // Normalize project name (remove special characters, limit length)\n  projectName = projectName\n    .substring(0, 50)\n    .replace(/[\"']/g, '')\n    .trim();\n  \n  results.push({\n    json: {\n      ...item.json,\n      projectName,\n      projectConfidence: confidence,\n      projectExtractedFrom: extractedFrom\n    }\n  });\n}\n\nreturn results;"
      },
      "name": "Code: Parse Project Name",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3100, 400],
      "id": "c2.5-node-parse-project-name",
      "notes": "Parses AI response and normalizes project name (max 50 chars)"
    },
    {
      "parameters": {
        "operation": "search",
        "documentId": "{{ $vars.PROJECT_TRACKER_SHEET_ID || $vars.MAIN_LOG_SHEET_ID }}",
        "sheetName": "=Project Tracker",
        "filtersUI": {
          "values": [
            {
              "lookupColumn": "Project Name",
              "lookupValue": "={{ $json.projectName }}"
            }
          ]
        },
        "options": {
          "returnAllMatches": false
        }
      },
      "name": "Google Sheets: Search Project Tracker",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.4,
      "position": [3320, 400],
      "id": "c2.5-node-search-project-tracker",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "{{GOOGLE_SHEETS_CREDENTIAL_ID}}",
          "name": "Google Sheets OAuth2"
        }
      },
      "notes": "Searches for existing project in Project Tracker sheet"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "combineOperation": "any"
          },
          "conditions": [
            {
              "id": "condition-project-found",
              "leftValue": "={{ $json.rowNumber }}",
              "rightValue": "",
              "operator": {
                "type": "number",
                "operation": "exists"
              }
            }
          ]
        },
        "options": {}
      },
      "name": "IF: Project Exists in Tracker?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [3540, 400],
      "id": "c2.5-node-if-project-exists",
      "notes": "Routes based on whether project was found in tracker"
    },
    {
      "parameters": {
        "operation": "read",
        "documentId": "{{ $vars.PROJECT_TRACKER_SHEET_ID || $vars.MAIN_LOG_SHEET_ID }}",
        "sheetName": "=Project Tracker",
        "filtersUI": {
          "values": [
            {
              "lookupColumn": "Project Name",
              "lookupValue": "={{ $json.projectName }}"
            }
          ]
        },
        "options": {
          "returnAllMatches": false
        }
      },
      "name": "Google Sheets: Get Existing Project",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.4,
      "position": [3760, 300],
      "id": "c2.5-node-get-existing-project",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "{{GOOGLE_SHEETS_CREDENTIAL_ID}}",
          "name": "Google Sheets OAuth2"
        }
      },
      "notes": "Retrieves existing project row data (TRUE branch)"
    },
    {
      "parameters": {
        "jsCode": "// Prepare new project row data for creation\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const projectName = item.json.projectName || 'Unknown Project';\n  const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD\n  \n  results.push({\n    json: {\n      ...item.json,\n      newProjectRow: {\n        'Project Name': projectName,\n        'Exposé': false,\n        'Grundbuch': false,\n        'Calculation': false,\n        'Exit Strategy': false,\n        'Last Updated': today,\n        'Notes': `Auto-created from document upload on ${today}`\n      }\n    }\n  });\n}\n\nreturn results;"
      },
      "name": "Code: Prepare New Project Row",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3760, 500],
      "id": "c2.5-node-prepare-new-project",
      "notes": "Prepares data for new project creation (FALSE branch)"
    },
    {
      "parameters": {
        "operation": "appendOrUpdate",
        "documentId": "{{ $vars.PROJECT_TRACKER_SHEET_ID || $vars.MAIN_LOG_SHEET_ID }}",
        "sheetName": "=Project Tracker",
        "dataMode": "defineBelow",
        "fieldsUi": {
          "values": [
            {
              "fieldId": "Project Name",
              "fieldValue": "={{ $json.newProjectRow['Project Name'] }}"
            },
            {
              "fieldId": "Exposé",
              "fieldValue": "={{ $json.newProjectRow['Exposé'] }}"
            },
            {
              "fieldId": "Grundbuch",
              "fieldValue": "={{ $json.newProjectRow['Grundbuch'] }}"
            },
            {
              "fieldId": "Calculation",
              "fieldValue": "={{ $json.newProjectRow['Calculation'] }}"
            },
            {
              "fieldId": "Exit Strategy",
              "fieldValue": "={{ $json.newProjectRow['Exit Strategy'] }}"
            },
            {
              "fieldId": "Last Updated",
              "fieldValue": "={{ $json.newProjectRow['Last Updated'] }}"
            },
            {
              "fieldId": "Notes",
              "fieldValue": "={{ $json.newProjectRow['Notes'] }}"
            }
          ]
        },
        "options": {}
      },
      "name": "Google Sheets: Create New Project Row",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.4,
      "position": [3980, 500],
      "id": "c2.5-node-create-new-project",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "{{GOOGLE_SHEETS_CREDENTIAL_ID}}",
          "name": "Google Sheets OAuth2"
        }
      },
      "notes": "Creates new project row in tracker (FALSE branch)"
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "mergeByPosition",
        "options": {}
      },
      "name": "Merge: Combine Project Data",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [4200, 400],
      "id": "c2.5-node-merge-project-data",
      "notes": "Merges project data (existing or newly created) with document data for next chunk"
    },
    {
      "parameters": {
        "model": "gpt-4o-mini",
        "options": {
          "temperature": 0.1,
          "maxTokens": 50
        },
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are a document classifier for German Bauträger (construction developer) projects.\n\nYour task is to classify documents into ONE of these 4 categories:\n\n1. **OBJEKTUNTERLAGEN** (Property Documents)\n   Documents related to the physical property: purchase contracts, land registers, building permits, construction plans, DIN calculations, site plans, insurance, appraisals.\n   Key terms: Kaufvertrag, Grundbuch, Baugenehmigung, DIN 276, DIN 277, Bauzeichnung, Lageplan\n\n2. **WIRTSCHAFTLICHE** (Economic/Financial Documents)\n   Financial statements, tax documents, income verification, asset overviews.\n   Key terms: Jahresabschluss, BWA, Steuernummer, SCHUFA, Einkommensteuerbescheid, Vermögensübersicht\n\n3. **RECHTLICHE** (Legal Documents)\n   Corporate legal documents, registrations, licenses.\n   Key terms: Handelsregister, Gesellschaftsvertrag, §34c GewO, Personalausweis\n\n4. **SONSTIGES** (Other/Custom Documents)\n   Exit strategies, liquidation plans, documents not matching above categories.\n   Key terms: Exit, Ausstiegsstrategie, ROI, Liquidation\n\nAnalyze the document and respond with ONLY the category name.\n\nReturn ONLY: OBJEKTUNTERLAGEN, WIRTSCHAFTLICHE, RECHTLICHE, or SONSTIGES"
            },
            {
              "role": "user",
              "content": "Classify this German document:\n\n={{ $json.textForClassification }}"
            }
          ]
        }
      },
      "name": "AI Level 1: Category Detection",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [4420, 400],
      "id": "c3-node-ai-level1",
      "credentials": {
        "openAiApi": {
          "id": "{{OPENAI_CREDENTIAL_ID}}",
          "name": "OpenAI API"
        }
      },
      "notes": "First classification level: determines main category (4 options)"
    },
    {
      "parameters": {
        "rules": {
          "rules": [
            {
              "operation": "contains",
              "value1": "={{ $json.choices[0].message.content.toUpperCase() }}",
              "value2": "OBJEKTUNTERLAGEN",
              "output": 0
            },
            {
              "operation": "contains",
              "value1": "={{ $json.choices[0].message.content.toUpperCase() }}",
              "value2": "WIRTSCHAFTLICHE",
              "output": 1
            },
            {
              "operation": "contains",
              "value1": "={{ $json.choices[0].message.content.toUpperCase() }}",
              "value2": "RECHTLICHE",
              "output": 2
            },
            {
              "operation": "contains",
              "value1": "={{ $json.choices[0].message.content.toUpperCase() }}",
              "value2": "SONSTIGES",
              "output": 3
            }
          ],
          "fallbackOutput": 4
        },
        "options": {}
      },
      "name": "Switch: Route by Category",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [4640, 400],
      "id": "c3-node-category-switch",
      "notes": "Routes to Level 2 classification based on category. Fallback goes to UNKNOWN."
    },
    {
      "parameters": {
        "model": "gpt-4o-mini",
        "options": {
          "temperature": 0.1,
          "maxTokens": 50
        },
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are classifying a German OBJEKTUNTERLAGEN (property document).\n\nFor Phase 1, identify if this is ONE of these 3 priority types:\n\n1. **expose** - Project description, Exposé, Projektbeschreibung, teaser, property overview\n   Key indicators: \"Exposé\", \"Projektbeschreibung\", overview of property, marketing description\n\n2. **grundbuch** - Land register extract, Grundbuchauszug\n   Key indicators: \"Grundbuch\", \"Abteilung I/II/III\", property ownership records, \"Amtsgericht\"\n\n3. **calculation** - Developer calculation according to DIN 276, Bauträgerkalkulation\n   Key indicators: \"DIN 276\", \"Kostenberechnung\", \"Baukosten\", cost breakdown, development calculation\n\nIf the document matches ANY of these 3 types, return that type name.\nIf it is a different OBJEKTUNTERLAGEN type (Baugenehmigung, Kaufvertrag, Bauzeichnung, etc.), return: others\n\nReturn ONLY ONE of: expose, grundbuch, calculation, others"
            },
            {
              "role": "user",
              "content": "Classify this OBJEKTUNTERLAGEN document:\n\n={{ $json.textForClassification }}"
            }
          ]
        }
      },
      "name": "AI Level 2: Objektunterlagen Priority",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [4860, 200],
      "id": "c3-node-ai-level2-obj",
      "credentials": {
        "openAiApi": {
          "id": "{{OPENAI_CREDENTIAL_ID}}",
          "name": "OpenAI API"
        }
      },
      "notes": "Checks if OBJEKTUNTERLAGEN doc is one of 3 priorities (expose, grundbuch, calculation) or others"
    },
    {
      "parameters": {
        "model": "gpt-4o-mini",
        "options": {
          "temperature": 0.1,
          "maxTokens": 50
        },
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are classifying a German SONSTIGES (other) document.\n\nCheck if this is an EXIT STRATEGY document:\n\n**exitstrategie** - Exit strategy, liquidation plan, ROI projections, property sale timeline\n   Key indicators: \"Exit\", \"Ausstiegsstrategie\", \"Liquidation\", \"Verkaufsstrategie\", \"ROI\", \"Rendite\", timeline for selling\n\nIf it is an exit strategy, return: exitstrategie\nIf it is any other document type, return: others\n\nReturn ONLY: exitstrategie or others"
            },
            {
              "role": "user",
              "content": "Check if this is an exit strategy document:\n\n={{ $json.textForClassification }}"
            }
          ]
        }
      },
      "name": "AI Level 2: Check Exit Strategy",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [4860, 600],
      "id": "c3-node-ai-level2-sonstiges",
      "credentials": {
        "openAiApi": {
          "id": "{{OPENAI_CREDENTIAL_ID}}",
          "name": "OpenAI API"
        }
      },
      "notes": "Checks if SONSTIGES doc is exit strategy or generic other"
    },
    {
      "parameters": {
        "jsCode": "// WIRTSCHAFTLICHE and RECHTLICHE documents go to 'others' in Phase 1\n// They are valid documents but not priority - Eugene will manually sort\n\nconst items = $input.all();\nreturn items.map(item => ({\n  json: {\n    ...item.json,\n    documentType: 'others',\n    typeReason: 'Non-priority category (WIRTSCHAFTLICHE or RECHTLICHE)',\n    manualSortRequired: true\n  },\n  binary: item.binary\n}));"
      },
      "name": "Set Type: Others (Non-Priority Category)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4860, 400],
      "id": "c3-node-set-others-nonpriority",
      "notes": "WIRTSCHAFTLICHE and RECHTLICHE docs go to Others folder in Phase 1"
    },
    {
      "parameters": {
        "rules": {
          "rules": [
            {
              "operation": "contains",
              "value1": "={{ $json.choices[0].message.content.toLowerCase() }}",
              "value2": "expose",
              "output": 0
            },
            {
              "operation": "contains",
              "value1": "={{ $json.choices[0].message.content.toLowerCase() }}",
              "value2": "grundbuch",
              "output": 1
            },
            {
              "operation": "contains",
              "value1": "={{ $json.choices[0].message.content.toLowerCase() }}",
              "value2": "calculation",
              "output": 2
            },
            {
              "operation": "contains",
              "value1": "={{ $json.choices[0].message.content.toLowerCase() }}",
              "value2": "others",
              "output": 3
            }
          ],
          "fallbackOutput": 3
        },
        "options": {}
      },
      "name": "Switch: Objektunterlagen Type",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [5080, 200],
      "id": "c3-node-obj-type-switch",
      "notes": "Routes to specific type or Others based on Level 2 classification"
    },
    {
      "parameters": {
        "rules": {
          "rules": [
            {
              "operation": "contains",
              "value1": "={{ $json.choices[0].message.content.toLowerCase() }}",
              "value2": "exitstrategie",
              "output": 0
            },
            {
              "operation": "contains",
              "value1": "={{ $json.choices[0].message.content.toLowerCase() }}",
              "value2": "others",
              "output": 1
            }
          ],
          "fallbackOutput": 1
        },
        "options": {}
      },
      "name": "Switch: Exit or Others",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [5080, 600],
      "id": "c3-node-exit-type-switch",
      "notes": "Routes exit strategy to its folder, others to Others folder"
    },
    {
      "parameters": {
        "jsCode": "// V3.5 UPDATE: Added timestamp to filename for guaranteed uniqueness\nconst items = $input.all();\nconst clientName = $vars.CLIENT_NAME || 'Eugene';\n\n// Generate date and time for filename\nconst now = new Date();\nconst date = now.toISOString().split('T')[0].replace(/-/g, ''); // YYYYMMDD\nconst time = now.toTimeString().split(' ')[0].replace(/:/g, ''); // HHMMSS\n\nconst originalExt = (items[0].json.originalFileName || 'document.pdf').split('.').pop();\n\nreturn items.map(item => ({\n  json: {\n    ...item.json,\n    documentType: 'expose',\n    newFileName: `EXPOSE_${clientName}_${date}_${time}.${originalExt}`,\n    targetFolderPath: 'OBJEKTUNTERLAGEN/01_Projektbeschreibung/',\n    targetFolderVar: 'FOLDER_01_PROJEKTBESCHREIBUNG',\n    filePrefix: 'EXPOSE',\n    clientName: clientName,\n    processedDate: date,\n    processedTime: time\n  },\n  binary: item.binary\n}));"
      },
      "name": "Set Filename: Expose",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5300, 100],
      "id": "c3-node-set-filename-expose",
      "notes": "Sets EXPOSE prefix and routing to 01_Projektbeschreibung folder (V3.5: added timestamp)"
    },
    {
      "parameters": {
        "jsCode": "// V3.5 UPDATE: Added timestamp to filename for guaranteed uniqueness\nconst items = $input.all();\nconst clientName = $vars.CLIENT_NAME || 'Eugene';\n\n// Generate date and time for filename\nconst now = new Date();\nconst date = now.toISOString().split('T')[0].replace(/-/g, ''); // YYYYMMDD\nconst time = now.toTimeString().split(' ')[0].replace(/:/g, ''); // HHMMSS\n\nconst originalExt = (items[0].json.originalFileName || 'document.pdf').split('.').pop();\n\nreturn items.map(item => ({\n  json: {\n    ...item.json,\n    documentType: 'grundbuch',\n    newFileName: `GRUNDBUCH_${clientName}_${date}_${time}.${originalExt}`,\n    targetFolderPath: 'OBJEKTUNTERLAGEN/03_Grundbuchauszug/',\n    targetFolderVar: 'FOLDER_03_GRUNDBUCHAUSZUG',\n    filePrefix: 'GRUNDBUCH',\n    clientName: clientName,\n    processedDate: date,\n    processedTime: time\n  },\n  binary: item.binary\n}));"
      },
      "name": "Set Filename: Grundbuch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5300, 200],
      "id": "c3-node-set-filename-grundbuch",
      "notes": "Sets GRUNDBUCH prefix and routing to 03_Grundbuchauszug folder (V3.5: added timestamp)"
    },
    {
      "parameters": {
        "jsCode": "// V3.5 UPDATE: Added timestamp to filename for guaranteed uniqueness\nconst items = $input.all();\nconst clientName = $vars.CLIENT_NAME || 'Eugene';\n\n// Generate date and time for filename\nconst now = new Date();\nconst date = now.toISOString().split('T')[0].replace(/-/g, ''); // YYYYMMDD\nconst time = now.toTimeString().split(' ')[0].replace(/:/g, ''); // HHMMSS\n\nconst originalExt = (items[0].json.originalFileName || 'document.pdf').split('.').pop();\n\nreturn items.map(item => ({\n  json: {\n    ...item.json,\n    documentType: 'calculation',\n    newFileName: `KALK276_${clientName}_${date}_${time}.${originalExt}`,\n    targetFolderPath: 'OBJEKTUNTERLAGEN/10_Bautraegerkalkulation_DIN276/',\n    targetFolderVar: 'FOLDER_10_BAUTRAEGERKALKULATION',\n    filePrefix: 'KALK276',\n    clientName: clientName,\n    processedDate: date,\n    processedTime: time\n  },\n  binary: item.binary\n}));"
      },
      "name": "Set Filename: Calculation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5300, 300],
      "id": "c3-node-set-filename-calculation",
      "notes": "Sets KALK276 prefix and routing to 10_Bautraegerkalkulation folder (V3.5: added timestamp)"
    },
    {
      "parameters": {
        "jsCode": "// V3.5 UPDATE: Added timestamp to filename for guaranteed uniqueness\nconst items = $input.all();\nconst clientName = $vars.CLIENT_NAME || 'Eugene';\n\n// Generate date and time for filename\nconst now = new Date();\nconst date = now.toISOString().split('T')[0].replace(/-/g, ''); // YYYYMMDD\nconst time = now.toTimeString().split(' ')[0].replace(/:/g, ''); // HHMMSS\n\nconst originalExt = (items[0].json.originalFileName || 'document.pdf').split('.').pop();\n\nreturn items.map(item => ({\n  json: {\n    ...item.json,\n    documentType: 'exitstrategie',\n    newFileName: `EXIT_${clientName}_${date}_${time}.${originalExt}`,\n    targetFolderPath: 'SONSTIGES/36_Exit_Strategie/',\n    targetFolderVar: 'FOLDER_36_EXIT_STRATEGIE',\n    filePrefix: 'EXIT',\n    clientName: clientName,\n    processedDate: date,\n    processedTime: time\n  },\n  binary: item.binary\n}));"
      },
      "name": "Set Filename: Exit Strategy",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5300, 550],
      "id": "c3-node-set-filename-exit",
      "notes": "Sets EXIT prefix and routing to 36_Exit_Strategie folder (V3.5: added timestamp)"
    },
    {
      "parameters": {
        "jsCode": "// V3.5 UPDATE: Added timestamp to filename for guaranteed uniqueness\nconst items = $input.all();\nconst clientName = $vars.CLIENT_NAME || 'Eugene';\n\n// Generate date and time for filename\nconst now = new Date();\nconst date = now.toISOString().split('T')[0].replace(/-/g, ''); // YYYYMMDD\nconst time = now.toTimeString().split(' ')[0].replace(/:/g, ''); // HHMMSS\n\nconst originalExt = (items[0].json.originalFileName || 'document.pdf').split('.').pop();\n\nreturn items.map(item => ({\n  json: {\n    ...item.json,\n    documentType: 'others',\n    newFileName: `OTHERS_${clientName}_${date}_${time}.${originalExt}`,\n    targetFolderPath: 'SONSTIGES/37_Others/',\n    targetFolderVar: 'FOLDER_37_OTHERS',\n    filePrefix: 'OTHERS',\n    clientName: clientName,\n    processedDate: date,\n    processedTime: time,\n    manualSortRequired: true\n  },\n  binary: item.binary\n}));"
      },
      "name": "Set Filename: Others",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5300, 450],
      "id": "c3-node-set-filename-others",
      "notes": "Sets OTHERS prefix - Eugene will manually sort these later (V3.5: added timestamp)"
    },
    {
      "parameters": {
        "jsCode": "// V3.5 UPDATE: Added timestamp to filename for guaranteed uniqueness\nconst items = $input.all();\nconst clientName = $vars.CLIENT_NAME || 'Eugene';\n\n// Generate date and time for filename\nconst now = new Date();\nconst date = now.toISOString().split('T')[0].replace(/-/g, ''); // YYYYMMDD\nconst time = now.toTimeString().split(' ')[0].replace(/:/g, ''); // HHMMSS\n\nconst originalExt = (items[0].json.originalFileName || 'document.pdf').split('.').pop();\n\nreturn items.map(item => ({\n  json: {\n    ...item.json,\n    documentType: 'unknown',\n    newFileName: `UNKNOWN_${clientName}_${date}_${time}.${originalExt}`,\n    targetFolderPath: 'SONSTIGES/38_Unknowns/',\n    targetFolderVar: 'FOLDER_38_UNKNOWNS',\n    filePrefix: 'UNKNOWN',\n    clientName: clientName,\n    processedDate: date,\n    processedTime: time,\n    manualReviewRequired: true,\n    classificationFailed: true\n  },\n  binary: item.binary\n}));"
      },
      "name": "Set Filename: Unknown",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5300, 700],
      "id": "c3-node-set-filename-unknown",
      "notes": "Sets UNKNOWN prefix - classification failed, needs manual review (V3.5: added timestamp)"
    },
    {
      "parameters": {
        "mode": "append",
        "options": {}
      },
      "name": "Merge All Classified",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [5520, 400],
      "id": "c3-node-merge-classified",
      "notes": "Combines all classification branches into single stream for file operations"
    },
    {
      "parameters": {
        "operation": "move",
        "fileId": {
          "__rl": true,
          "mode": "id",
          "value": "={{ $json.driveFileId || $json.id }}"
        },
        "driveId": {
          "__rl": true,
          "mode": "list",
          "value": "My Drive"
        },
        "folderId": {
          "__rl": true,
          "mode": "id",
          "value": "={{ $vars[$json.targetFolderVar] || $vars.FOLDER_37_OTHERS }}"
        },
        "options": {}
      },
      "name": "Move to Target Folder",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [5740, 400],
      "id": "c4-node-move-file",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "{{GOOGLE_DRIVE_CREDENTIAL_ID}}",
          "name": "Google Drive"
        }
      },
      "notes": "Moves file from staging to target folder based on classification. Uses folder ID from n8n variable (e.g., FOLDER_03_GRUNDBUCH). Falls back to Others folder if variable not set."
    },
    {
      "parameters": {
        "operation": "update",
        "fileId": {
          "__rl": true,
          "mode": "id",
          "value": "={{ $json.driveFileId || $json.id }}"
        },
        "updateFields": {
          "name": "={{ $json.newFileName }}"
        },
        "options": {}
      },
      "name": "Rename File",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [5960, 400],
      "id": "c4-node-rename-file",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "{{GOOGLE_DRIVE_CREDENTIAL_ID}}",
          "name": "Google Drive"
        }
      },
      "notes": "Renames file with standardized prefix. Example: KALK276_Eugene_20251221_143052.pdf"
    },
    {
      "parameters": {
        "jsCode": "// Prepare log entry data for Google Sheets\n\nconst items = $input.all();\nconst logEntries = [];\n\nfor (const item of items) {\n  const now = new Date();\n  const timestamp = now.toISOString();\n  const dateStr = now.toLocaleDateString('de-DE');\n  const timeStr = now.toLocaleTimeString('de-DE');\n  \n  logEntries.push({\n    json: {\n      ...item.json,\n      // Log fields for Google Sheets\n      logTimestamp: timestamp,\n      logDate: dateStr,\n      logTime: timeStr,\n      logOriginalFileName: item.json.originalFileName || 'unknown',\n      logNewFileName: item.json.newFileName || 'unknown',\n      logDocumentType: item.json.documentType || 'unknown',\n      logCategory: item.json.category || 'unknown',\n      logTargetFolder: item.json.targetFolderPath || 'unknown',\n      logConfidence: item.json.confidence || 'N/A',\n      logClientName: item.json.clientName || $vars.CLIENT_NAME || 'Eugene',\n      logFileId: item.json.driveFileId || item.json.id || 'N/A',\n      logProcessingStatus: 'SUCCESS',\n      logErrorMessage: '',\n      // Track for summary email\n      processingSuccess: true\n    },\n    binary: item.binary\n  });\n}\n\nreturn logEntries;"
      },
      "name": "Prepare Log Entry",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [6180, 400],
      "id": "c4-node-prepare-log",
      "notes": "Prepares structured log entry for Google Sheets with timestamp, filenames, classification results, and processing status."
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "mode": "id",
          "value": "={{ $vars.MAIN_LOG_SHEET_ID }}"
        },
        "sheetName": {
          "__rl": true,
          "mode": "name",
          "value": "Processing Log"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Timestamp": "={{ $json.logTimestamp }}",
            "Date": "={{ $json.logDate }}",
            "Time": "={{ $json.logTime }}",
            "Original Filename": "={{ $json.logOriginalFileName }}",
            "New Filename": "={{ $json.logNewFileName }}",
            "Document Type": "={{ $json.logDocumentType }}",
            "Category": "={{ $json.logCategory }}",
            "Target Folder": "={{ $json.logTargetFolder }}",
            "Confidence": "={{ $json.logConfidence }}",
            "Client": "={{ $json.logClientName }}",
            "File ID": "={{ $json.logFileId }}",
            "Status": "={{ $json.logProcessingStatus }}",
            "Error": "={{ $json.logErrorMessage }}"
          }
        },
        "options": {}
      },
      "name": "Log to Main Sheet",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "position": [6400, 400],
      "id": "c4-node-log-main",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "{{GOOGLE_SHEETS_CREDENTIAL_ID}}",
          "name": "Google Sheets"
        }
      },
      "notes": "Appends processing record to main log spreadsheet. Creates audit trail for all processed documents."
    },
    {
      "parameters": {
        "operation": "update",
        "documentId": {
          "__rl": true,
          "mode": "id",
          "value": "={{ $vars.PROJECT_TRACKER_SHEET_ID || $vars.MAIN_LOG_SHEET_ID }}"
        },
        "sheetName": {
          "__rl": true,
          "mode": "name",
          "value": "Project Tracker"
        },
        "dataMode": "autoMap",
        "columnToMatchOn": "Project Name",
        "valueToMatchOn": "={{ $json.projectName || 'Unknown Project' }}",
        "fieldsUi": {
          "values": [
            {
              "fieldId": "={{ $json.documentType === 'expose' ? 'Exposé' : '' }}",
              "fieldValue": "={{ $json.documentType === 'expose' ? true : '' }}"
            },
            {
              "fieldId": "={{ $json.documentType === 'grundbuch' ? 'Grundbuch' : '' }}",
              "fieldValue": "={{ $json.documentType === 'grundbuch' ? true : '' }}"
            },
            {
              "fieldId": "={{ $json.documentType === 'calculation' ? 'Calculation' : '' }}",
              "fieldValue": "={{ $json.documentType === 'calculation' ? true : '' }}"
            },
            {
              "fieldId": "={{ $json.documentType === 'exitstrategie' ? 'Exit Strategy' : '' }}",
              "fieldValue": "={{ $json.documentType === 'exitstrategie' ? true : '' }}"
            },
            {
              "fieldId": "Last Updated",
              "fieldValue": "={{ $now.toFormat('yyyy-MM-dd') }}"
            }
          ]
        },
        "options": {
          "useAppend": true
        }
      },
      "name": "Update Project Tracker",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "position": [6620, 400],
      "id": "c4-node-update-project-tracker",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "{{GOOGLE_SHEETS_CREDENTIAL_ID}}",
          "name": "Google Sheets"
        }
      },
      "notes": "V3.5: Marks the received document type as ✓ in Project Tracker sheet. Updates 'Last Updated' date."
    },
    {
      "parameters": {
        "jsCode": "// V3.5: Calculate project completion status after updating tracker\n// Reads the updated project row and calculates how many priority docs are complete\n\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const projectName = item.json.projectName || 'Unknown Project';\n  \n  // Count completed priority documents\n  const expose = item.json['Exposé'] === true ? 1 : 0;\n  const grundbuch = item.json['Grundbuch'] === true ? 1 : 0;\n  const calculation = item.json['Calculation'] === true ? 1 : 0;\n  const exitStrategy = item.json['Exit Strategy'] === true ? 1 : 0;\n  \n  const totalComplete = expose + grundbuch + calculation + exitStrategy;\n  const totalPriority = 4;\n  \n  // Determine status\n  let projectStatus = '';\n  let isComplete = false;\n  \n  if (totalComplete === 4) {\n    projectStatus = 'COMPLETE';\n    isComplete = true;\n  } else if (totalComplete === 0) {\n    projectStatus = 'NEW';\n  } else {\n    projectStatus = `IN PROGRESS (${totalComplete}/${totalPriority})`;\n  }\n  \n  // Identify missing documents\n  const missingDocs = [];\n  if (!expose) missingDocs.push('Exposé');\n  if (!grundbuch) missingDocs.push('Grundbuch');\n  if (!calculation) missingDocs.push('Calculation');\n  if (!exitStrategy) missingDocs.push('Exit Strategy');\n  \n  results.push({\n    json: {\n      ...item.json,\n      // Project completion data\n      projectName: projectName,\n      projectStatus: projectStatus,\n      projectComplete: isComplete,\n      projectCompletionRatio: `${totalComplete}/${totalPriority}`,\n      projectMissingDocs: missingDocs,\n      projectHasExpose: expose === 1,\n      projectHasGrundbuch: grundbuch === 1,\n      projectHasCalculation: calculation === 1,\n      projectHasExitStrategy: exitStrategy === 1\n    },\n    binary: item.binary\n  });\n}\n\nreturn results;"
      },
      "name": "Calculate Project Completion",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [6840, 400],
      "id": "c4-node-calculate-completion",
      "notes": "V3.5: Calculates project completion status (2/4, 3/4, 4/4) and identifies missing documents for email summary."
    },
    {
      "parameters": {
        "jsCode": "// V3.5 UPDATED: Aggregate results for Eugene notification email WITH PROJECT STATUS\n// This runs after all documents are processed in a batch\n\nconst items = $input.all();\n\n// Get project data from last item (passed through from Calculate Project Completion)\nconst lastItem = items[items.length - 1].json;\nconst projectName = lastItem.projectName || 'Unknown Project';\nconst projectStatus = lastItem.projectStatus || 'UNKNOWN';\nconst projectComplete = lastItem.projectComplete || false;\nconst projectCompletionRatio = lastItem.projectCompletionRatio || '0/4';\nconst projectMissingDocs = lastItem.projectMissingDocs || [];\n\nconst summary = {\n  totalProcessed: items.length,\n  successCount: 0,\n  byType: {\n    expose: [],\n    grundbuch: [],\n    calculation: [],\n    exitstrategie: [],\n    others: [],\n    unknown: []\n  },\n  processingTime: new Date().toISOString()\n};\n\nfor (const item of items) {\n  if (item.json.processingSuccess) {\n    summary.successCount++;\n  }\n  \n  const docType = item.json.documentType || 'unknown';\n  if (summary.byType[docType]) {\n    summary.byType[docType].push({\n      originalName: item.json.logOriginalFileName,\n      newName: item.json.logNewFileName,\n      folder: item.json.logTargetFolder\n    });\n  }\n}\n\n// Build email subject with project status\nconst priorityDocsCount = summary.byType.expose.length + summary.byType.grundbuch.length + summary.byType.calculation.length + summary.byType.exitstrategie.length;\nconst emailSubject = `[Doc Organizer] Project ${projectName} - ${projectCompletionRatio} complete`;\n\n// Build email body\nlet emailBody = `Document Organizer - Processing Summary\\n`;\nemailBody += `========================================\\n\\n`;\n\n// V3.5 NEW: PROJECT STATUS SECTION\nemailBody += `--- PROJECT STATUS ---\\n\\n`;\nemailBody += `Project: ${projectName}\\n`;\nemailBody += `Completion: ${projectCompletionRatio} Priority Documents\\n`;\nemailBody += `Status: ${projectStatus}\\n\\n`;\n\n// Show checkmarks for received docs\nemailBody += `${lastItem.projectHasExpose ? '✓' : '✗'} Exposé\\n`;\nemailBody += `${lastItem.projectHasGrundbuch ? '✓' : '✗'} Grundbuch\\n`;\nemailBody += `${lastItem.projectHasCalculation ? '✓' : '✗'} Calculation\\n`;\nemailBody += `${lastItem.projectHasExitStrategy ? '✓' : '✗'} Exit Strategy\\n\\n`;\n\nif (projectMissingDocs.length > 0) {\n  emailBody += `⚠️  Still missing: ${projectMissingDocs.join(', ')}\\n\\n`;\n} else if (projectComplete) {\n  emailBody += `🎉 ALL PRIORITY DOCUMENTS COMPLETE!\\n\\n`;\n}\n\nemailBody += `\\n`;\n\n// Latest batch processed section\nemailBody += `--- LATEST BATCH PROCESSED ---\\n\\n`;\nemailBody += `Documents: ${summary.totalProcessed}\\n`;\nemailBody += `Successful: ${summary.successCount}\\n`;\nemailBody += `Time: ${summary.processingTime}\\n\\n`;\n\n// Priority documents section\nif (priorityDocsCount > 0) {\n  emailBody += `📄 PRIORITY DOCUMENTS IN THIS BATCH:\\n\\n`;\n  \n  if (summary.byType.expose.length > 0) {\n    emailBody += `  EXPOSÉ (${summary.byType.expose.length}):\\n`;\n    summary.byType.expose.forEach(doc => {\n      emailBody += `    • ${doc.newName}\\n`;\n    });\n    emailBody += `\\n`;\n  }\n  \n  if (summary.byType.grundbuch.length > 0) {\n    emailBody += `  GRUNDBUCH (${summary.byType.grundbuch.length}):\\n`;\n    summary.byType.grundbuch.forEach(doc => {\n      emailBody += `    • ${doc.newName}\\n`;\n    });\n    emailBody += `\\n`;\n  }\n  \n  if (summary.byType.calculation.length > 0) {\n    emailBody += `  KALKULATION DIN 276 (${summary.byType.calculation.length}):\\n`;\n    summary.byType.calculation.forEach(doc => {\n      emailBody += `    • ${doc.newName}\\n`;\n    });\n    emailBody += `\\n`;\n  }\n  \n  if (summary.byType.exitstrategie.length > 0) {\n    emailBody += `  EXIT STRATEGIE (${summary.byType.exitstrategie.length}):\\n`;\n    summary.byType.exitstrategie.forEach(doc => {\n      emailBody += `    • ${doc.newName}\\n`;\n    });\n    emailBody += `\\n`;\n  }\n}\n\n// Catch-all folders section\nif (summary.byType.others.length > 0 || summary.byType.unknown.length > 0) {\n  emailBody += `--- NEEDS MANUAL SORTING ---\\n\\n`;\n  \n  if (summary.byType.others.length > 0) {\n    emailBody += `📁 OTHERS - Identifiable docs for manual sorting (${summary.byType.others.length}):\\n`;\n    summary.byType.others.forEach(doc => {\n      emailBody += `  • ${doc.originalName} → ${doc.folder}\\n`;\n    });\n    emailBody += `\\n`;\n  }\n  \n  if (summary.byType.unknown.length > 0) {\n    emailBody += `❓ UNKNOWN - Needs review (${summary.byType.unknown.length}):\\n`;\n    summary.byType.unknown.forEach(doc => {\n      emailBody += `  • ${doc.originalName}\\n`;\n    });\n    emailBody += `\\n`;\n  }\n}\n\nemailBody += `\\n---\\n`;\nemailBody += `View full log: https://docs.google.com/spreadsheets/d/${$vars.MAIN_LOG_SHEET_ID}\\n`;\nemailBody += `Project tracker: https://docs.google.com/spreadsheets/d/${$vars.PROJECT_TRACKER_SHEET_ID || $vars.MAIN_LOG_SHEET_ID}\\n`;\n\nreturn [{\n  json: {\n    emailSubject: emailSubject,\n    emailBody: emailBody,\n    summary: summary,\n    projectName: projectName,\n    projectStatus: projectStatus,\n    projectComplete: projectComplete,\n    // Pass through last item's data\n    ...lastItem\n  }\n}];"
      },
      "name": "Build Email Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [7060, 400],
      "id": "c4-node-build-email",
      "notes": "V3.5: Aggregates all processed documents into enhanced summary email for Eugene with project completion status. Shows which priority docs are complete/missing."
    },
    {
      "parameters": {
        "sendTo": "={{ $vars.EUGENE_EMAIL }}",
        "subject": "={{ $json.emailSubject }}",
        "message": "={{ $json.emailBody }}",
        "options": {}
      },
      "name": "Email Eugene Summary",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2,
      "position": [7280, 400],
      "id": "c4-node-email-eugene",
      "credentials": {
        "gmailOAuth2": {
          "id": "{{GMAIL_CREDENTIAL_ID}}",
          "name": "Gmail OAuth2"
        }
      },
      "notes": "V3.5: Sends enhanced processing summary to Eugene with project completion status. NO emails to clients. Shows which priority docs are complete/missing."
    }
  ],
  "connections": {
    "Gmail Trigger: Watch for Labeled Emails": {
      "main": [[{"node": "Download All Attachments", "type": "main", "index": 0}]]
    },
    "Download All Attachments": {
      "main": [[{"node": "IF: Is ZIP Archive?", "type": "main", "index": 0}]]
    },
    "IF: Is ZIP Archive?": {
      "main": [
        [{"node": "Extract ZIP Contents", "type": "main", "index": 0}],
        [{"node": "Merge: Combine All Files", "type": "main", "index": 1}]
      ]
    },
    "Extract ZIP Contents": {
      "main": [[{"node": "Merge: Combine All Files", "type": "main", "index": 0}]]
    },
    "Merge: Combine All Files": {
      "main": [[{"node": "Filter: PDF and DOCX Only", "type": "main", "index": 0}]]
    },
    "Filter: PDF and DOCX Only": {
      "main": [[{"node": "Upload to Staging Folder", "type": "main", "index": 0}]]
    },
    "Upload to Staging Folder": {
      "main": [[{"node": "Detect: Scan vs Digital", "type": "main", "index": 0}]]
    },
    "Detect: Scan vs Digital": {
      "main": [[{"node": "IF: Needs OCR?", "type": "main", "index": 0}]]
    },
    "IF: Needs OCR?": {
      "main": [
        [{"node": "AWS Textract: OCR (German)", "type": "main", "index": 0}],
        [{"node": "Extract Text (Digital PDF/DOCX)", "type": "main", "index": 0}]
      ]
    },
    "Extract Text (Digital PDF/DOCX)": {
      "main": [[{"node": "Merge: Text Outputs", "type": "main", "index": 1}]]
    },
    "AWS Textract: OCR (German)": {
      "main": [[{"node": "Merge: Text Outputs", "type": "main", "index": 0}]]
    },
    "Merge: Text Outputs": {
      "main": [[{"node": "Prepare Text for AI", "type": "main", "index": 0}]]
    },
    "Prepare Text for AI": {
      "main": [[{"node": "OpenAI: Extract Project Name", "type": "main", "index": 0}]]
    },
    "OpenAI: Extract Project Name": {
      "main": [[{"node": "Code: Parse Project Name", "type": "main", "index": 0}]]
    },
    "Code: Parse Project Name": {
      "main": [[{"node": "Google Sheets: Search Project Tracker", "type": "main", "index": 0}]]
    },
    "Google Sheets: Search Project Tracker": {
      "main": [[{"node": "IF: Project Exists in Tracker?", "type": "main", "index": 0}]]
    },
    "IF: Project Exists in Tracker?": {
      "main": [
        [{"node": "Google Sheets: Get Existing Project", "type": "main", "index": 0}],
        [{"node": "Code: Prepare New Project Row", "type": "main", "index": 0}]
      ]
    },
    "Google Sheets: Get Existing Project": {
      "main": [[{"node": "Merge: Combine Project Data", "type": "main", "index": 0}]]
    },
    "Code: Prepare New Project Row": {
      "main": [[{"node": "Google Sheets: Create New Project Row", "type": "main", "index": 0}]]
    },
    "Google Sheets: Create New Project Row": {
      "main": [[{"node": "Merge: Combine Project Data", "type": "main", "index": 1}]]
    },
    "Merge: Combine Project Data": {
      "main": [[{"node": "AI Level 1: Category Detection", "type": "main", "index": 0}]]
    },
    "AI Level 1: Category Detection": {
      "main": [[{"node": "Switch: Route by Category", "type": "main", "index": 0}]]
    },
    "Switch: Route by Category": {
      "main": [
        [{"node": "AI Level 2: Objektunterlagen Priority", "type": "main", "index": 0}],
        [{"node": "Set Type: Others (Non-Priority Category)", "type": "main", "index": 0}],
        [{"node": "Set Type: Others (Non-Priority Category)", "type": "main", "index": 0}],
        [{"node": "AI Level 2: Check Exit Strategy", "type": "main", "index": 0}],
        [{"node": "Set Filename: Unknown", "type": "main", "index": 0}]
      ]
    },
    "AI Level 2: Objektunterlagen Priority": {
      "main": [[{"node": "Switch: Objektunterlagen Type", "type": "main", "index": 0}]]
    },
    "AI Level 2: Check Exit Strategy": {
      "main": [[{"node": "Switch: Exit or Others", "type": "main", "index": 0}]]
    },
    "Set Type: Others (Non-Priority Category)": {
      "main": [[{"node": "Set Filename: Others", "type": "main", "index": 0}]]
    },
    "Switch: Objektunterlagen Type": {
      "main": [
        [{"node": "Set Filename: Expose", "type": "main", "index": 0}],
        [{"node": "Set Filename: Grundbuch", "type": "main", "index": 0}],
        [{"node": "Set Filename: Calculation", "type": "main", "index": 0}],
        [{"node": "Set Filename: Others", "type": "main", "index": 0}]
      ]
    },
    "Switch: Exit or Others": {
      "main": [
        [{"node": "Set Filename: Exit Strategy", "type": "main", "index": 0}],
        [{"node": "Set Filename: Others", "type": "main", "index": 0}]
      ]
    },
    "Set Filename: Expose": {
      "main": [[{"node": "Merge All Classified", "type": "main", "index": 0}]]
    },
    "Set Filename: Grundbuch": {
      "main": [[{"node": "Merge All Classified", "type": "main", "index": 0}]]
    },
    "Set Filename: Calculation": {
      "main": [[{"node": "Merge All Classified", "type": "main", "index": 0}]]
    },
    "Set Filename: Exit Strategy": {
      "main": [[{"node": "Merge All Classified", "type": "main", "index": 0}]]
    },
    "Set Filename: Others": {
      "main": [[{"node": "Merge All Classified", "type": "main", "index": 0}]]
    },
    "Set Filename: Unknown": {
      "main": [[{"node": "Merge All Classified", "type": "main", "index": 0}]]
    },
    "Merge All Classified": {
      "main": [[{"node": "Move to Target Folder", "type": "main", "index": 0}]]
    },
    "Move to Target Folder": {
      "main": [[{"node": "Rename File", "type": "main", "index": 0}]]
    },
    "Rename File": {
      "main": [[{"node": "Prepare Log Entry", "type": "main", "index": 0}]]
    },
    "Prepare Log Entry": {
      "main": [[{"node": "Log to Main Sheet", "type": "main", "index": 0}]]
    },
    "Log to Main Sheet": {
      "main": [[{"node": "Update Project Tracker", "type": "main", "index": 0}]]
    },
    "Update Project Tracker": {
      "main": [[{"node": "Calculate Project Completion", "type": "main", "index": 0}]]
    },
    "Calculate Project Completion": {
      "main": [[{"node": "Build Email Summary", "type": "main", "index": 0}]]
    },
    "Build Email Summary": {
      "main": [[{"node": "Email Eugene Summary", "type": "main", "index": 0}]]
    },
    "Email Eugene Summary": {
      "main": [[]]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": false,
    "instanceId": "document-organizer-v3.5-complete"
  },
  "pinData": {},
  "versionId": "v3.5-complete-2025-12-21",
  "triggerCount": 0,
  "notes": "**Document Organizer V3.5 - Complete Workflow**\n\nPhase 1 implementation with project tracking capability.\n\n**Total Nodes:** 52 (across 5 chunks)\n- Chunk 1: Email → Staging (7 nodes)\n- Chunk 2: Text Extraction + OCR (6 nodes)\n- Chunk 2.5: Project Tracking (9 nodes)\n- Chunk 3: AI Classification (14 nodes)\n- Chunk 4: File Operations + Logging (8 nodes)\n- Chunk 5: Error Handling (14 nodes, separate workflow)\n\n**Key Features:**\n- Automated folder creation (Chunk 0, separate one-time setup)\n- ZIP file extraction\n- German OCR support (AWS Textract)\n- 2-level AI classification (GPT-4o-mini)\n- Project-level document tracking\n- Enhanced email notifications with completion status\n- Timestamp-based unique filenames\n- Comprehensive error handling (separate workflow)\n\n**Setup Requirements:**\n1. Run Chunk 0 (Folder Initialization) once before activating this workflow\n2. Configure n8n variables (see IMPLEMENTATION_GUIDE.md)\n3. Set up credentials (Gmail, Google Drive, Google Sheets, OpenAI, AWS)\n4. Create Project Tracker sheet with columns:\n   - Project Name, Exposé, Grundbuch, Calculation, Exit Strategy, Last Updated, Notes\n\n**Cost:** ~$0.006-0.012 per document\n**Processing Time:** 9-20 seconds per document (digital PDF: 9-12s, scanned PDF: 15-20s)\n\nVersion: 3.5 (Phase 1 with Project Tracking)\nCreated: 2025-12-21"
}
