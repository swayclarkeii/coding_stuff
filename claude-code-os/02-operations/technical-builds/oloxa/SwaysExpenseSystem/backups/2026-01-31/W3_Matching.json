{
  "updatedAt": "2026-01-29T19:11:49.296Z",
  "createdAt": "2026-01-05T21:08:23.061Z",
  "id": "CJtdqMreZ17esJAW",
  "name": "Expense System - Workflow 3 v2.1: Transaction-Receipt-Invoice Matching",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {},
      "id": "node-1",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        96,
        144
      ]
    },
    {
      "parameters": {
        "documentId": {
          "mode": "id",
          "value": "1l1uA8qA0DCGzGLBhmP2HqTzaajjbkURY2SLeqSuHMXM"
        },
        "sheetName": {
          "mode": "name",
          "value": "Receipts"
        },
        "options": {}
      },
      "id": "node-2",
      "name": "Read Unmatched Receipts",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        320,
        192
      ],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "H7ewI1sOrDYabelt",
          "name": "Google Sheets account"
        }
      },
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000
    },
    {
      "parameters": {
        "jsCode": "const receipts = $input.all();\n\n// Filter for unmatched receipts (Matched = FALSE or empty transaction_id)\nconst unmatchedReceipts = receipts.filter(item => {\n  const matched = item.json.Matched;\n  const transactionId = item.json.transaction_id;\n  \n  // Include if Matched is FALSE or empty, OR transaction_id is empty\n  return (!matched || matched === 'FALSE' || matched === false || !transactionId || transactionId === '');\n});\n\n// Return unmatched receipts, or empty array if none\nif (unmatchedReceipts.length === 0) {\n  return [{ json: { message: 'No unmatched receipts found', count: 0 } }];\n}\n\nreturn unmatchedReceipts;"
      },
      "id": "node-3",
      "name": "Filter Unmatched Receipts Only",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        544,
        192
      ]
    },
    {
      "parameters": {
        "documentId": {
          "mode": "id",
          "value": "1l1uA8qA0DCGzGLBhmP2HqTzaajjbkURY2SLeqSuHMXM"
        },
        "sheetName": {
          "mode": "name",
          "value": "Transactions"
        },
        "options": {}
      },
      "id": "node-4",
      "name": "Read All Transactions",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        320,
        672
      ],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "H7ewI1sOrDYabelt",
          "name": "Google Sheets account"
        }
      },
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000
    },
    {
      "parameters": {
        "jsCode": "// Get transactions from Read All Transactions node\nconst transactions = $input.all();\n\n// Filter for Type = 'expense' transactions only\nconst expenseTransactions = transactions.filter(item => {\n  const type = item.json.Type;\n  return type && type.toLowerCase() === 'expense';\n});\n\n// Return expense transactions\nif (expenseTransactions.length === 0) {\n  return [{ json: { message: 'No expense transactions found', count: 0 } }];\n}\n\nreturn expenseTransactions;"
      },
      "id": "node-filter-expense",
      "name": "Filter Expense Transactions",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        544,
        384
      ]
    },
    {
      "parameters": {
        "jsCode": "// Get transactions from Read All Transactions node\nconst transactions = $input.all();\n\n// Filter for Type = 'income' transactions only\nconst incomeTransactions = transactions.filter(item => {\n  const type = item.json.Type;\n  return type && type.toLowerCase() === 'income';\n});\n\n// Return income transactions\nif (incomeTransactions.length === 0) {\n  return [{ json: { message: 'No income transactions found', count: 0 } }];\n}\n\nreturn incomeTransactions;"
      },
      "id": "node-filter-income",
      "name": "Filter Income Transactions",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        544,
        672
      ]
    },
    {
      "parameters": {
        "jsCode": "// Match receipts to expense transactions from merged data\n// n8n Merge creates combinations (receipts \u00d7 transactions)\n// Each item contains fields from BOTH sources\n\nconst allItems = $input.all();\nconsole.log(`Processing ${allItems.length} merged combinations`);\n\nif (allItems.length === 0) {\n  return [{ json: { message: 'No merged items to process' } }];\n}\n\n// Log first item to understand structure\nconsole.log('First merged item sample:', JSON.stringify(allItems[0]?.json, null, 2));\n\n// ===== DATE NORMALIZATION =====\n// Converts all date formats to YYYY-MM-DD for comparison\nfunction normalizeDate(dateStr) {\n  if (!dateStr) return null;\n  if (dateStr instanceof Date) {\n    const d = dateStr;\n    return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;\n  }\n  \n  const str = String(dateStr).trim();\n  \n  // DD.MM.YYYY (European format with dots)\n  let match = str.match(/^(\\d{1,2})\\.(\\d{1,2})\\.(\\d{4})$/);\n  if (match) {\n    const [_, day, month, year] = match;\n    return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;\n  }\n  \n  // DD/MM/YYYY (European format with slashes)\n  match = str.match(/^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/);\n  if (match) {\n    const [_, day, month, year] = match;\n    return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;\n  }\n  \n  // YYYY-MM-DD (already normalized)\n  match = str.match(/^(\\d{4})-(\\d{1,2})-(\\d{1,2})$/);\n  if (match) {\n    const [_, year, month, day] = match;\n    return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;\n  }\n  \n  // Jan 29, 2026 or January 29, 2026 (text month)\n  match = str.match(/(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\\s+(\\d{1,2}),?\\s+(\\d{4})/i);\n  if (match) {\n    const monthMap = {jan:1,feb:2,mar:3,apr:4,may:5,jun:6,jul:7,aug:8,sep:9,oct:10,nov:11,dec:12};\n    const month = monthMap[match[1].toLowerCase()];\n    const day = match[2];\n    const year = match[3];\n    return `${year}-${String(month).padStart(2, '0')}-${day.padStart(2, '0')}`;\n  }\n  \n  // Fallback to Date parsing\n  try {\n    const parsed = new Date(str);\n    if (!isNaN(parsed.getTime())) {\n      return `${parsed.getFullYear()}-${String(parsed.getMonth() + 1).padStart(2, '0')}-${String(parsed.getDate()).padStart(2, '0')}`;\n    }\n  } catch (e) {}\n  \n  return null;\n}\n\n// ===== AMOUNT NORMALIZATION =====\n// Strips currency symbols, handles German/US number formats, returns float\nfunction normalizeAmount(amountStr) {\n  if (typeof amountStr === 'number') return Math.abs(amountStr);\n  if (!amountStr) return null;\n  \n  let str = String(amountStr).trim();\n  \n  // Strip currency symbols (\u20ac, $, \u00a3, CHF, etc.)\n  str = str.replace(/[\u20ac$\u00a3\u00a5\u20b9]/g, '');\n  str = str.replace(/CHF|USD|EUR|GBP/gi, '');\n  str = str.trim();\n  \n  // Handle German format: 1.572,94 (dot as thousand separator, comma as decimal)\n  // vs US format: 1,572.94 (comma as thousand separator, dot as decimal)\n  \n  const hasDot = str.includes('.');\n  const hasComma = str.includes(',');\n  \n  if (hasDot && hasComma) {\n    // Both present - determine format by position\n    const dotPos = str.lastIndexOf('.');\n    const commaPos = str.lastIndexOf(',');\n    \n    if (commaPos > dotPos) {\n      // German format: 1.572,94 \u2192 remove dots, replace comma with dot\n      str = str.replace(/\\./g, '').replace(',', '.');\n    } else {\n      // US format: 1,572.94 \u2192 remove commas\n      str = str.replace(/,/g, '');\n    }\n  } else if (hasComma) {\n    // Only comma - could be decimal separator or thousand separator\n    // If 2 digits after comma, it's decimal (1,99 or 1572,94)\n    const afterComma = str.split(',')[1];\n    if (afterComma && afterComma.length === 2) {\n      // Decimal separator\n      str = str.replace(',', '.');\n    } else {\n      // Thousand separator\n      str = str.replace(/,/g, '');\n    }\n  } else if (hasDot) {\n    // Only dot - likely decimal separator (US format)\n    // Unless it's like 1.000 (German thousand)\n    const afterDot = str.split('.')[1];\n    if (afterDot && afterDot.length === 3 && !afterDot.match(/\\d{1,2}/)) {\n      // Might be German thousand: 1.000\n      str = str.replace(/\\./g, '');\n    }\n  }\n  \n  // Remove any remaining spaces\n  str = str.replace(/\\s/g, '');\n  \n  const parsed = parseFloat(str);\n  return isNaN(parsed) ? null : Math.abs(parsed);\n}\n\nconst matches = [];\nconst seenPairs = new Set();\nlet skipped = 0;\n\nfor (const item of allItems) {\n  const json = item.json;\n  \n  const receiptFileName = json.FileName;\n  const transactionId = json.TransactionID;\n  \n  if (!receiptFileName || !transactionId) {\n    skipped++;\n    continue;\n  }\n  \n  if (json.receipt_id && json.receipt_id !== '') {\n    continue;\n  }\n  \n  // ===== NORMALIZE DATE =====\n  const dateStr = json.Date || json.date;\n  const normalizedDate = normalizeDate(dateStr);\n  if (!normalizedDate) {\n    console.log(`Skipping - invalid date: ${dateStr}`);\n    skipped++;\n    continue;\n  }\n  \n  // ===== NORMALIZE AMOUNT =====\n  const amountRaw = json.Amount || json.amount;\n  const normalizedAmount = normalizeAmount(amountRaw);\n  if (!normalizedAmount || isNaN(normalizedAmount)) {\n    console.log(`Skipping - invalid amount: ${amountRaw}`);\n    skipped++;\n    continue;\n  }\n  \n  const receiptRow = json.receipt_row_number || json.row_number;\n  const txnRow = json.transaction_row_number || json.row_number;\n  \n  const pairKey = `${receiptRow}-${transactionId}`;\n  if (seenPairs.has(pairKey)) {\n    continue;\n  }\n  seenPairs.add(pairKey);\n  \n  matches.push({\n    json: {\n      receiptId: json.ReceiptID || receiptRow,\n      transactionId: transactionId,\n      receiptFileName: receiptFileName,\n      receiptVendor: json.Vendor,\n      transactionDescription: json.Description,\n      transactionBank: json.Bank,\n      matchedAmount: normalizedAmount,\n      matchedDate: normalizedDate,\n      originalDate: dateStr,\n      originalAmount: amountRaw,\n      receiptRowNumber: receiptRow,\n      transactionRowNumber: txnRow,\n      matchType: 'receipt-expense',\n      confidence: 'high'\n    }\n  });\n}\n\nconsole.log(`Found ${matches.length} matches (skipped ${skipped} items)`);\n\nif (matches.length === 0) {\n  console.log('WARNING: No matches found!');\n  return [{ json: { \n    message: 'No matches found', \n    totalCombinations: allItems.length,\n    skipped: skipped,\n    sampleItem: allItems[0]?.json \n  } }];\n}\n\nreturn matches;"
      },
      "id": "node-5",
      "name": "Match Receipts to Expense Transactions",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        992,
        288
      ]
    },
    {
      "parameters": {
        "resource": "fileFolder",
        "queryString": "='1_zVNS3JHS15pUjvfEJMh9nzYWn6TltbS' in parents and mimeType='application/pdf'",
        "filter": {},
        "options": {
          "fields": [
            "id",
            "name",
            "mimeType",
            "createdTime",
            "modifiedTime"
          ]
        }
      },
      "id": "node-search-invoices",
      "name": "Search Production Folder (Priority 1)",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        768,
        576
      ],
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "PGGNF2ZKD2XqDhe0",
          "name": "Google Drive (swayfromthehook)"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Enhanced invoice matching with invoice # extraction and fuzzy client name matching\nconst invoices = $input.all();\nconst incomeTransactions = $('Filter Income Transactions').all();\n\n// Levenshtein distance for fuzzy matching\nfunction levenshtein(a, b) {\n  const matrix = [];\n  for (let i = 0; i <= b.length; i++) {\n    matrix[i] = [i];\n  }\n  for (let j = 0; j <= a.length; j++) {\n    matrix[0][j] = j;\n  }\n  for (let i = 1; i <= b.length; i++) {\n    for (let j = 1; j <= a.length; j++) {\n      if (b.charAt(i - 1) === a.charAt(j - 1)) {\n        matrix[i][j] = matrix[i - 1][j - 1];\n      } else {\n        matrix[i][j] = Math.min(\n          matrix[i - 1][j - 1] + 1,\n          matrix[i][j - 1] + 1,\n          matrix[i - 1][j] + 1\n        );\n      }\n    }\n  }\n  return matrix[b.length][a.length];\n}\n\nfunction similarity(s1, s2) {\n  const longer = s1.length > s2.length ? s1 : s2;\n  const shorter = s1.length > s2.length ? s2 : s1;\n  if (longer.length === 0) return 1.0;\n  return (longer.length - levenshtein(longer, shorter)) / longer.length;\n}\n\n// Extract invoice number from bank description\nfunction extractInvoiceNumber(description) {\n  if (!description) return null;\n\n  // Patterns: #123, Invoice 123, Rechnung 123, INV-123, Rech. #123\n  const patterns = [\n    /#(\\d+)/i,\n    /Invoice[:\\s]+(\\d+)/i,\n    /Rechnung[:\\s]+#?(\\d+)/i,\n    /INV-?(\\d+)/i,\n    /Rech\\.?[:\\s]+#?(\\d+)/i\n  ];\n\n  for (const pattern of patterns) {\n    const match = description.match(pattern);\n    if (match && match[1]) {\n      return match[1];\n    }\n  }\n\n  return null;\n}\n\n// Match transactions to invoices\nconst matches = [];\n\nfor (const txnItem of incomeTransactions) {\n  const txn = txnItem.json;\n  let bestMatch = null;\n  let matchConfidence = 'none';\n  let matchMethod = null;\n\n  // Extract invoice # from transaction description\n  const invoiceNumber = extractInvoiceNumber(txn['Description/Vendor']);\n\n  // PRIMARY MATCH: Invoice # + amount + date\n  if (invoiceNumber) {\n    for (const invItem of invoices) {\n      const inv = invItem.json;\n      const fileNameMatch = inv.file_name && inv.file_name.includes(invoiceNumber);\n\n      if (fileNameMatch) {\n        // Check amount match (\u00b12 EUR tolerance)\n        const txnAmount = Math.abs(parseFloat(txn.Amount || 0));\n        const invAmount = parseFloat(inv.amount || 0);\n        const amountMatch = Math.abs(txnAmount - invAmount) <= 2;\n\n        // Check date match (\u00b17 days)\n        const txnDate = new Date(txn.Date);\n        const invDate = new Date(inv.date);\n        const daysDiff = Math.abs((txnDate - invDate) / (1000 * 60 * 60 * 24));\n        const dateMatch = daysDiff <= 7;\n\n        if (amountMatch && dateMatch) {\n          bestMatch = inv;\n          matchConfidence = 'primary';\n          matchMethod = 'invoice#';\n          break;\n        }\n      }\n    }\n  }\n\n  // SECONDARY MATCH: Fuzzy client name + amount + date\n  if (!bestMatch) {\n    const txnDescription = (txn['Description/Vendor'] || '').toLowerCase();\n\n    for (const invItem of invoices) {\n      const inv = invItem.json;\n      const clientName = (inv.client_name || '').toLowerCase();\n\n      if (clientName) {\n        const similarityScore = similarity(txnDescription, clientName);\n\n        if (similarityScore >= 0.7) {\n          // Check exact amount match\n          const txnAmount = Math.abs(parseFloat(txn.Amount || 0));\n          const invAmount = parseFloat(inv.amount || 0);\n          const amountMatch = txnAmount === invAmount;\n\n          // Check date match (\u00b114 days)\n          const txnDate = new Date(txn.Date);\n          const invDate = new Date(inv.date);\n          const daysDiff = Math.abs((txnDate - invDate) / (1000 * 60 * 60 * 24));\n          const dateMatch = daysDiff <= 14;\n\n          if (amountMatch && dateMatch) {\n            bestMatch = inv;\n            matchConfidence = 'secondary';\n            matchMethod = 'fuzzy-client';\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  // \u2705 FIX: Ensure proper object structure for ALL items\n  matches.push({\n    json: {\n      TransactionID: txn.TransactionID,\n      Date: txn.Date,\n      'Description/Vendor': txn['Description/Vendor'],\n      Amount: txn.Amount,\n      matched: bestMatch ? true : false,\n      invoice_id: bestMatch?.invoice_id || null,\n      invoice_file_id: bestMatch?.file_id || null,\n      invoice_file_name: bestMatch?.file_name || null,\n      match_confidence: matchConfidence,\n      match_method: matchMethod,\n      extracted_invoice_number: invoiceNumber,\n      confidence: bestMatch ? (matchConfidence === 'primary' ? 0.95 : 0.75) : 0,\n      matchType: 'invoice'\n    }\n  });\n}\n\n// \u2705 FIX: Always return array of objects with json property\n// Even if no matches, return empty match structure\nif (matches.length === 0) {\n  return [{\n    json: {\n      message: 'No income transactions to match',\n      matched: false,\n      matchType: 'invoice',\n      confidence: 0\n    }\n  }];\n}\n\nreturn matches;"
      },
      "id": "node-match-invoices",
      "name": "Match Invoices to Income Transactions",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1440,
        768
      ]
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineAll",
        "options": {}
      },
      "id": "merge-receipt-invoice-matches",
      "name": "Merge Receipt and Invoice Matches",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        1664,
        480
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "condition-1",
              "leftValue": "={{ $json.matched }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            },
            {
              "id": "condition-2",
              "leftValue": "={{ $json.confidence }}",
              "rightValue": 0.7,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "node-6",
      "name": "Filter Successful Matches",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1888,
        480
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare receipt updates (only receipt matches)\nconst matches = $input.all().filter(item => item.json.matchType === 'receipt');\n\nconst updates = matches.map(match => ({\n  json: {\n    range: `Receipts!A${match.json.receiptRow}:Z${match.json.receiptRow}`,\n    values: [[\n      // Assumes ReceiptID is in a specific column - adjust as needed\n      // This creates an update for the TransactionID column in the receipt row\n      match.json.transactionId\n    ]]\n  }\n}));\n\nreturn updates;"
      },
      "id": "node-7",
      "name": "Prepare Receipt Updates",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2112,
        384
      ]
    },
    {
      "parameters": {
        "documentId": {
          "mode": "id",
          "value": "1l1uA8qA0DCGzGLBhmP2HqTzaajjbkURY2SLeqSuHMXM"
        },
        "sheetName": {
          "mode": "name",
          "value": "Receipts"
        }
      },
      "id": "node-8",
      "name": "Update Receipts Sheet",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        2336,
        384
      ],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "H7ewI1sOrDYabelt",
          "name": "Google Sheets account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Prepare transaction updates with enhanced invoice matching data\nconst matches = $input.all();\n\nconst updates = [];\n\nfor (const match of matches) {\n  const json = match.json;\n\n  // For receipt matches (expenses)\n  if (json.matchType === 'receipt') {\n    updates.push({\n      json: {\n        TransactionID: json.transactionId,\n        ReceiptID: json.receiptId,\n        MatchConfidence: json.confidence,\n        MatchMethod: 'receipt',\n        // New columns (leave empty for receipt matches)\n        InvoiceID: '',\n        InvoiceFileID: ''\n      }\n    });\n  }\n  // For invoice matches (income)\n  else if (json.matchType === 'invoice' && json.matched) {\n    updates.push({\n      json: {\n        TransactionID: json.TransactionID,\n        // New invoice columns\n        InvoiceID: json.invoice_id || '',\n        InvoiceFileID: json.invoice_file_id || '',\n        MatchConfidence: json.match_confidence || 'none',\n        MatchMethod: json.match_method || 'none',\n        // Receipt columns (leave empty for invoice matches)\n        ReceiptID: ''\n      }\n    });\n  }\n}\n\n// \u2705 FIX: Always return valid structure, even if empty\nif (updates.length === 0) {\n  return [{\n    json: {\n      message: 'No transaction updates needed',\n      updateCount: 0\n    }\n  }];\n}\n\nreturn updates;"
      },
      "id": "node-9",
      "name": "Prepare Transaction Updates",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2112,
        576
      ]
    },
    {
      "parameters": {
        "documentId": {
          "mode": "id",
          "value": "1l1uA8qA0DCGzGLBhmP2HqTzaajjbkURY2SLeqSuHMXM"
        },
        "sheetName": {
          "mode": "name",
          "value": "Transactions"
        }
      },
      "id": "node-10",
      "name": "Update Transactions Sheet",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        2336,
        576
      ],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "H7ewI1sOrDYabelt",
          "name": "Google Sheets account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Get all match results from both branches\nconst receiptMatches = $('Match Receipts to Expense Transactions').all();\nconst invoiceMatches = $('Match Invoices to Income Transactions').all();\n\n// Combine both\nconst allMatches = [...receiptMatches, ...invoiceMatches];\n\n// Calculate statistics\nconst totalItems = allMatches.length;\nconst matched = allMatches.filter(m => m.json.matched && m.json.confidence > 0.7);\nconst unmatched = allMatches.filter(m => !m.json.matched || m.json.confidence <= 0.7);\nconst receiptMatchCount = matched.filter(m => m.json.matchType === 'receipt').length;\nconst invoiceMatchCount = matched.filter(m => m.json.matchType === 'invoice').length;\nconst exactMatches = matched.filter(m => m.json.matchTier === 'EXACT');\nconst fuzzyMatches = matched.filter(m => m.json.matchTier === 'FUZZY');\n\n// Calculate average confidence (only for successful matches)\nconst avgConfidence = matched.length > 0 \n  ? matched.reduce((sum, m) => sum + m.json.confidence, 0) / matched.length \n  : 0;\n\nreturn [{\n  json: {\n    summary: `Processed ${totalItems} items: ${matched.length} matched (${receiptMatchCount} receipts, ${invoiceMatchCount} invoices), ${unmatched.length} unmatched`,\n    totalItems: totalItems,\n    successfulMatches: matched.length,\n    receiptMatches: receiptMatchCount,\n    invoiceMatches: invoiceMatchCount,\n    unmatchedItems: unmatched.length,\n    exactMatches: exactMatches.length,\n    fuzzyMatches: fuzzyMatches.length,\n    averageConfidence: avgConfidence.toFixed(2),\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "node-11",
      "name": "Generate Summary Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2560,
        480
      ]
    },
    {
      "parameters": {
        "jsCode": "// \u2705 REUSE existing data from 'Read All Transactions' node (no duplicate read)\nconst transactions = $('Read All Transactions').all();\n\n// Filter for unmatched expense transactions (Type='expense' AND ReceiptID is empty)\nconst unmatchedExpenses = transactions.filter(item => {\n  const type = item.json.Type;\n  const receiptId = item.json.ReceiptID;\n  \n  return type && type.toLowerCase() === 'expense' && (!receiptId || receiptId === '');\n});\n\n// Return unmatched expense transactions\nif (unmatchedExpenses.length === 0) {\n  return [{ json: { message: 'No unmatched expense transactions', count: 0, items: [] } }];\n}\n\nreturn [{\n  json: {\n    message: `Found ${unmatchedExpenses.length} unmatched expense transactions`,\n    count: unmatchedExpenses.length,\n    items: unmatchedExpenses.map(item => ({\n      TransactionID: item.json.TransactionID,\n      Date: item.json.Date,\n      Vendor: item.json.Vendor,\n      Amount: item.json.Amount,\n      Type: item.json.Type\n    }))\n  }\n}];"
      },
      "id": "node-find-unmatched-expenses",
      "name": "Find Unmatched Expense Transactions",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3008,
        288
      ]
    },
    {
      "parameters": {
        "jsCode": "// \u2705 REUSE existing data from 'Read All Transactions' node (no duplicate read)\nconst transactions = $('Read All Transactions').all();\n\n// Extract invoice number helper function\nfunction extractInvoiceNumber(description) {\n  if (!description) return null;\n\n  const patterns = [\n    /#(\\d+)/i,\n    /Invoice[:\\s]+(\\d+)/i,\n    /Rechnung[:\\s]+#?(\\d+)/i,\n    /INV-?(\\d+)/i,\n    /Rech\\.?[:\\s]+#?(\\d+)/i\n  ];\n\n  for (const pattern of patterns) {\n    const match = description.match(pattern);\n    if (match && match[1]) {\n      return match[1];\n    }\n  }\n\n  return null;\n}\n\n// Filter for unmatched income transactions\nconst unmatchedIncome = transactions.filter(item => {\n  const type = item.json.Type;\n  const invoiceId = item.json.InvoiceID;\n\n  return type && type.toLowerCase() === 'income' && (!invoiceId || invoiceId === '');\n});\n\n// Build items array BEFORE return statement (more explicit)\nconst items = unmatchedIncome.map(item => {\n  const description = item.json['Description/Vendor'] || '';\n  const extractedInvoiceNum = extractInvoiceNumber(description);\n\n  return {\n    TransactionID: item.json.TransactionID,\n    Date: item.json.Date,\n    Client: item.json['Description/Vendor'],\n    Amount: item.json.Amount,\n    ExtractedInvoiceNumber: extractedInvoiceNum,\n    Reason: extractedInvoiceNum\n      ? `Invoice #${extractedInvoiceNum} not found in any source`\n      : 'No invoice number found in description'\n  };\n});\n\n// \u2705 FIX: Return explicit object structure\nif (unmatchedIncome.length === 0) {\n  return [{\n    json: {\n      message: 'No unmatched income transactions',\n      count: 0,\n      items: []\n    }\n  }];\n}\n\n// \u2705 FIX: Use pre-built items array\nreturn [{\n  json: {\n    message: `Found ${unmatchedIncome.length} unmatched income transactions`,\n    count: unmatchedIncome.length,\n    items: items\n  }\n}];"
      },
      "id": "node-find-unmatched-income",
      "name": "Find Unmatched Income Transactions",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3008,
        480
      ]
    },
    {
      "parameters": {
        "jsCode": "// \u2705 REUSE existing data from 'Read Unmatched Receipts' node (no duplicate read)\nconst receipts = $('Read Unmatched Receipts').all();\n\n// Filter for orphaned receipts (no transaction_id or empty transaction_id)\nconst orphanedReceipts = receipts.filter(item => {\n  const transactionId = item.json.transaction_id;\n  return !transactionId || transactionId === '';\n});\n\n// Return orphaned receipts\nif (orphanedReceipts.length === 0) {\n  return [{ json: { message: 'No orphaned receipts', count: 0, items: [] } }];\n}\n\nreturn [{\n  json: {\n    message: `Found ${orphanedReceipts.length} orphaned receipts`,\n    count: orphanedReceipts.length,\n    items: orphanedReceipts.map(item => ({\n      ReceiptID: item.json.ReceiptID,\n      Date: item.json.Date,\n      Vendor: item.json.Vendor,\n      Amount: item.json.Amount\n    }))\n  }\n}];"
      },
      "id": "node-find-orphaned-receipts",
      "name": "Find Orphaned Receipts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3008,
        672
      ]
    },
    {
      "parameters": {
        "jsCode": "// Get data from all missing items nodes\nconst unmatchedExpenses = $('Find Unmatched Expense Transactions').first().json;\nconst unmatchedIncome = $('Find Unmatched Income Transactions').first().json;\nconst orphanedReceipts = $('Find Orphaned Receipts').first().json;\nconst summary = $('Generate Summary Report').first().json;\n\n// Calculate totals\nconst totalUnmatched = unmatchedExpenses.count + unmatchedIncome.count;\nconst totalOrphaned = orphanedReceipts.count;\nconst totalTransactions = parseInt(summary.totalItems) || 0;\nconst totalMatched = parseInt(summary.successfulMatches) || 0;\n\n// Calculate success rate\nconst successRate = totalTransactions > 0 \n  ? ((totalMatched / totalTransactions) * 100).toFixed(1)\n  : '0.0';\n\n// Build markdown report\nlet report = `# Missing Items Report\\n\\n`;\nreport += `**Generated:** ${new Date().toISOString()}\\n\\n`;\nreport += `---\\n\\n`;\n\n// Overall Statistics\nreport += `## \ud83d\udcca Overall Statistics\\n\\n`;\nreport += `- **Total Transactions Processed:** ${totalTransactions}\\n`;\nreport += `- **Successfully Matched:** ${totalMatched} (${successRate}%)\\n`;\nreport += `- **Unmatched Transactions:** ${totalUnmatched}\\n`;\nreport += `- **Orphaned Documents:** ${totalOrphaned}\\n\\n`;\nreport += `---\\n\\n`;\n\n// Unmatched Expense Transactions\nreport += `## \ud83d\udcb3 Unmatched Expense Transactions (Need Receipts)\\n\\n`;\nif (unmatchedExpenses.count > 0) {\n  report += `**Count:** ${unmatchedExpenses.count}\\n\\n`;\n  report += `| Date | Vendor | Amount |\\n`;\n  report += `|------|--------|--------|\\n`;\n  unmatchedExpenses.items.forEach(item => {\n    report += `| ${item.Date} | ${item.Vendor} | $${item.Amount} |\\n`;\n  });\n  report += `\\n`;\n} else {\n  report += `\u2705 **All expense transactions have receipts!**\\n\\n`;\n}\n\nreport += `---\\n\\n`;\n\n// Unmatched Income Transactions (ENHANCED)\nreport += `## \ud83d\udcc4 Unmatched Income Transactions (Need Invoices)\\n\\n`;\nif (unmatchedIncome.count > 0) {\n  report += `**Count:** ${unmatchedIncome.count}\\n\\n`;\n  report += `| Date | Client | Amount | Extracted Invoice # | Reason |\\n`;\n  report += `|------|--------|--------|---------------------|--------|\\n`;\n  unmatchedIncome.items.forEach(item => {\n    const invoiceNum = item.ExtractedInvoiceNumber || 'N/A';\n    const reason = item.Reason || 'Unknown';\n    report += `| ${item.Date} | ${item.Client} | $${item.Amount} | ${invoiceNum} | ${reason} |\\n`;\n  });\n  report += `\\n`;\n  report += `> **Search locations checked:** Production folder, Invoice Pool\\n\\n`;\n} else {\n  report += `\u2705 **All income transactions have invoices!**\\n\\n`;\n}\n\nreport += `---\\n\\n`;\n\n// Orphaned Receipts\nreport += `## \ud83e\uddfe Orphaned Receipts (No Transaction Match)\\n\\n`;\nif (orphanedReceipts.count > 0) {\n  report += `**Count:** ${orphanedReceipts.count}\\n\\n`;\n  report += `| Date | Vendor | Amount |\\n`;\n  report += `|------|--------|--------|\\n`;\n  orphanedReceipts.items.forEach(item => {\n    report += `| ${item.Date} | ${item.Vendor} | $${item.Amount} |\\n`;\n  });\n  report += `\\n`;\n  report += `> **Note:** These receipts don't match any transaction. Consider creating transactions or removing if duplicates.\\n\\n`;\n} else {\n  report += `\u2705 **All receipts are matched to transactions!**\\n\\n`;\n}\n\nreport += `---\\n\\n`;\n\n// Action Items\nreport += `## \u2705 Action Items\\n\\n`;\nif (unmatchedExpenses.count > 0) {\n  report += `1. **Find ${unmatchedExpenses.count} missing receipts** for expense transactions listed above\\n`;\n}\nif (unmatchedIncome.count > 0) {\n  report += `${unmatchedExpenses.count > 0 ? '2' : '1'}. **Find ${unmatchedIncome.count} missing invoices** for income transactions listed above\\n`;\n  \n  // Count how many have extractable invoice numbers\n  const withInvoiceNum = unmatchedIncome.items.filter(item => item.ExtractedInvoiceNumber).length;\n  if (withInvoiceNum > 0) {\n    report += `   - ${withInvoiceNum} transaction(s) have extractable invoice numbers to search for\\n`;\n  }\n}\nif (orphanedReceipts.count > 0) {\n  const step = (unmatchedExpenses.count > 0 ? 1 : 0) + (unmatchedIncome.count > 0 ? 1 : 0) + 1;\n  report += `${step}. **Review ${orphanedReceipts.count} orphaned receipts** - create transactions or remove duplicates\\n`;\n}\n\nif (unmatchedExpenses.count === 0 && unmatchedIncome.count === 0 && orphanedReceipts.count === 0) {\n  report += `\ud83c\udf89 **No action needed! All documents are properly matched.**\\n\\n`;\n}\n\nreturn [{\n  json: {\n    reportMarkdown: report,\n    summary: {\n      totalTransactions: totalTransactions,\n      totalMatched: totalMatched,\n      successRate: successRate,\n      unmatchedExpenses: unmatchedExpenses.count,\n      unmatchedIncome: unmatchedIncome.count,\n      orphanedReceipts: orphanedReceipts.count,\n      totalIssues: totalUnmatched + totalOrphaned\n    },\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "node-format-missing-items-report",
      "name": "Format Missing Items Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3232,
        480
      ]
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineAll",
        "options": {}
      },
      "id": "merge-receipts-transactions",
      "name": "Merge Receipts and Expense Txns",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        768,
        288
      ]
    },
    {
      "parameters": {
        "documentId": {
          "mode": "id",
          "value": "1l1uA8qA0DCGzGLBhmP2HqTzaajjbkURY2SLeqSuHMXM"
        },
        "sheetName": {
          "mode": "name",
          "value": "Invoices"
        },
        "options": {}
      },
      "id": "node-read-invoices-sheet",
      "name": "Read Invoices Database",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        768,
        960
      ],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "H7ewI1sOrDYabelt",
          "name": "Google Sheets account"
        }
      },
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 60000
    },
    {
      "parameters": {
        "resource": "fileFolder",
        "queryString": "='1V7UmNvDP3a2t6IIbJJI7y8YXz6_X7F6l' in parents and mimeType='application/pdf'",
        "filter": {},
        "options": {
          "fields": [
            "id",
            "name",
            "mimeType",
            "createdTime",
            "modifiedTime"
          ]
        }
      },
      "id": "node-search-pool",
      "name": "Search Invoice Pool (Priority 2)",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        768,
        768
      ],
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "PGGNF2ZKD2XqDhe0",
          "name": "Google Drive (swayfromthehook)"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineAll"
      },
      "id": "node-merge-sources",
      "name": "Merge All Invoice Sources",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        992,
        768
      ]
    },
    {
      "parameters": {
        "jsCode": "// Enrich Google Drive files with Invoices database metadata\nconst allItems = $input.all();\n\n// Separate Drive files from database records\nconst driveFiles = [];\nconst databaseRecords = [];\n\nfor (const item of allItems) {\n  const json = item.json;\n  // Database records have InvoiceID, Drive files have 'id' (file ID)\n  if (json.InvoiceID) {\n    databaseRecords.push(json);\n  } else if (json.id) {\n    driveFiles.push(json);\n  }\n}\n\n// Create lookup map by FileID from database\nconst metadataMap = {};\nfor (const record of databaseRecords) {\n  const fileId = record.FileID;\n  if (fileId) {\n    metadataMap[fileId] = record;\n  }\n}\n\n// Enrich Drive files with database metadata\nconst enrichedInvoices = [];\nfor (const file of driveFiles) {\n  const metadata = metadataMap[file.id] || {};\n  \n  enrichedInvoices.push({\n    json: {\n      file_id: file.id,\n      file_name: file.name,\n      created_time: file.createdTime,\n      modified_time: file.modifiedTime,\n      mime_type: file.mimeType,\n      // From Invoices sheet (if available)\n      invoice_id: metadata.InvoiceID || null,\n      client_name: metadata.ClientName || null,\n      amount: metadata.Amount || null,\n      currency: metadata.Currency || null,\n      date: metadata.Date || null,\n      project: metadata.Project || null\n    }\n  });\n}\n\nif (enrichedInvoices.length === 0) {\n  return [{ json: { message: 'No invoices found from any source', count: 0 } }];\n}\n\nreturn enrichedInvoices;"
      },
      "id": "node-enrich-invoices",
      "name": "Enrich Invoices with Database Metadata",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1216,
        768
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "process-matching",
        "options": {}
      },
      "id": "webhook-trigger-temp",
      "name": "Webhook Trigger (Testing)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        96,
        720
      ],
      "webhookId": "437c9269-b18a-4a53-8fcb-83b200177323"
    },
    {
      "id": "webhook-rematch",
      "name": "Re-match Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        96,
        400
      ],
      "parameters": {
        "path": "expense-rematch",
        "httpMethod": "POST",
        "responseMode": "lastNode",
        "options": {}
      }
    }
  ],
  "connections": {
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Read Unmatched Receipts",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read All Transactions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Unmatched Receipts": {
      "main": [
        [
          {
            "node": "Filter Unmatched Receipts Only",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read All Transactions": {
      "main": [
        [
          {
            "node": "Filter Expense Transactions",
            "type": "main",
            "index": 0
          },
          {
            "node": "Filter Income Transactions",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read Invoices Database",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Unmatched Receipts Only": {
      "main": [
        [
          {
            "node": "Merge Receipts and Expense Txns",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Expense Transactions": {
      "main": [
        [
          {
            "node": "Merge Receipts and Expense Txns",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Filter Income Transactions": {
      "main": [
        [
          {
            "node": "Search Production Folder (Priority 1)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Search Invoice Pool (Priority 2)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Match Receipts to Expense Transactions": {
      "main": [
        [
          {
            "node": "Merge Receipt and Invoice Matches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search Production Folder (Priority 1)": {
      "main": [
        [
          {
            "node": "Merge All Invoice Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Match Invoices to Income Transactions": {
      "main": [
        [
          {
            "node": "Merge Receipt and Invoice Matches",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Receipt and Invoice Matches": {
      "main": [
        [
          {
            "node": "Filter Successful Matches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Successful Matches": {
      "main": [
        [
          {
            "node": "Prepare Receipt Updates",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prepare Transaction Updates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Receipt Updates": {
      "main": [
        [
          {
            "node": "Update Receipts Sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Transaction Updates": {
      "main": [
        [
          {
            "node": "Update Transactions Sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Receipts Sheet": {
      "main": [
        [
          {
            "node": "Generate Summary Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Transactions Sheet": {
      "main": [
        [
          {
            "node": "Generate Summary Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Find Unmatched Expense Transactions": {
      "main": [
        [
          {
            "node": "Format Missing Items Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Find Unmatched Income Transactions": {
      "main": [
        [
          {
            "node": "Format Missing Items Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Find Orphaned Receipts": {
      "main": [
        [
          {
            "node": "Format Missing Items Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search Invoice Pool (Priority 2)": {
      "main": [
        [
          {
            "node": "Merge All Invoice Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge All Invoice Sources": {
      "main": [
        [
          {
            "node": "Enrich Invoices with Database Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enrich Invoices with Database Metadata": {
      "main": [
        [
          {
            "node": "Match Invoices to Income Transactions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook Trigger (Testing)": {
      "main": [
        [
          {
            "node": "Read Unmatched Receipts",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read All Transactions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Invoices Database": {
      "main": [
        [
          {
            "node": "Merge All Invoice Sources",
            "type": "1",
            "index": 0
          }
        ]
      ]
    },
    "Generate Summary Report": {
      "main": [
        [
          {
            "node": "Find Unmatched Expense Transactions",
            "type": "main",
            "index": 0
          },
          {
            "node": "Find Unmatched Income Transactions",
            "type": "main",
            "index": 0
          },
          {
            "node": "Find Orphaned Receipts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Receipts and Expense Txns": {
      "main": [
        [
          {
            "node": "Match Receipts to Expense Transactions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Re-match Webhook": {
      "main": [
        [
          {
            "node": "Read Unmatched Receipts",
            "type": "0",
            "index": 0
          },
          {
            "node": "Read All Transactions",
            "type": "0",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": true,
    "timeSavedMode": "fixed"
  },
  "staticData": null,
  "meta": null,
  "pinData": {},
  "versionId": "26df59da-4504-43b2-aa5a-581faa5f5320",
  "activeVersionId": "26df59da-4504-43b2-aa5a-581faa5f5320",
  "versionCounter": 116,
  "triggerCount": 2,
  "shared": [
    {
      "updatedAt": "2026-01-05T21:08:23.061Z",
      "createdAt": "2026-01-05T21:08:23.061Z",
      "role": "workflow:owner",
      "workflowId": "CJtdqMreZ17esJAW",
      "projectId": "Rs8mhw052fnrzWZM",
      "project": {
        "updatedAt": "2025-12-31T15:54:29.115Z",
        "createdAt": "2025-12-31T15:27:33.865Z",
        "id": "Rs8mhw052fnrzWZM",
        "name": "Sway Clarke <sway@oloxa.ai>",
        "type": "personal",
        "icon": null,
        "description": null,
        "creatorId": "e9bd9112-c2e3-4f67-873a-e1001baeafd8",
        "projectRelations": [
          {
            "updatedAt": "2025-12-31T15:27:33.865Z",
            "createdAt": "2025-12-31T15:27:33.865Z",
            "userId": "e9bd9112-c2e3-4f67-873a-e1001baeafd8",
            "projectId": "Rs8mhw052fnrzWZM",
            "user": {
              "updatedAt": "2026-01-31T00:12:46.682Z",
              "createdAt": "2025-12-31T15:27:33.119Z",
              "id": "e9bd9112-c2e3-4f67-873a-e1001baeafd8",
              "email": "sway@oloxa.ai",
              "firstName": "Sway",
              "lastName": "Clarke",
              "personalizationAnswers": {
                "version": "v4",
                "personalization_survey_submitted_at": "2025-12-31T15:54:37.562Z",
                "personalization_survey_n8n_version": "2.1.4"
              },
              "settings": {
                "userActivated": true,
                "easyAIWorkflowOnboarded": true,
                "firstSuccessfulWorkflowId": "zbxHkXOoD1qaz6OS",
                "userActivatedAt": 1767398053308,
                "npsSurvey": {
                  "responded": true,
                  "lastShownAt": 1767684846804
                }
              },
              "disabled": false,
              "mfaEnabled": false,
              "lastActiveAt": "2026-01-30",
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": [],
  "activeVersion": {
    "updatedAt": "2026-01-29T19:11:49.299Z",
    "createdAt": "2026-01-29T19:11:49.299Z",
    "versionId": "26df59da-4504-43b2-aa5a-581faa5f5320",
    "workflowId": "CJtdqMreZ17esJAW",
    "nodes": [
      {
        "parameters": {},
        "id": "node-1",
        "name": "Manual Trigger",
        "type": "n8n-nodes-base.manualTrigger",
        "typeVersion": 1,
        "position": [
          96,
          144
        ]
      },
      {
        "parameters": {
          "documentId": {
            "mode": "id",
            "value": "1l1uA8qA0DCGzGLBhmP2HqTzaajjbkURY2SLeqSuHMXM"
          },
          "sheetName": {
            "mode": "name",
            "value": "Receipts"
          },
          "options": {}
        },
        "id": "node-2",
        "name": "Read Unmatched Receipts",
        "type": "n8n-nodes-base.googleSheets",
        "typeVersion": 4.7,
        "position": [
          320,
          192
        ],
        "credentials": {
          "googleSheetsOAuth2Api": {
            "id": "H7ewI1sOrDYabelt",
            "name": "Google Sheets account"
          }
        },
        "continueOnFail": true,
        "retryOnFail": true,
        "maxTries": 5,
        "waitBetweenTries": 5000
      },
      {
        "parameters": {
          "jsCode": "const receipts = $input.all();\n\n// Filter for unmatched receipts (Matched = FALSE or empty transaction_id)\nconst unmatchedReceipts = receipts.filter(item => {\n  const matched = item.json.Matched;\n  const transactionId = item.json.transaction_id;\n  \n  // Include if Matched is FALSE or empty, OR transaction_id is empty\n  return (!matched || matched === 'FALSE' || matched === false || !transactionId || transactionId === '');\n});\n\n// Return unmatched receipts, or empty array if none\nif (unmatchedReceipts.length === 0) {\n  return [{ json: { message: 'No unmatched receipts found', count: 0 } }];\n}\n\nreturn unmatchedReceipts;"
        },
        "id": "node-3",
        "name": "Filter Unmatched Receipts Only",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          544,
          192
        ]
      },
      {
        "parameters": {
          "documentId": {
            "mode": "id",
            "value": "1l1uA8qA0DCGzGLBhmP2HqTzaajjbkURY2SLeqSuHMXM"
          },
          "sheetName": {
            "mode": "name",
            "value": "Transactions"
          },
          "options": {}
        },
        "id": "node-4",
        "name": "Read All Transactions",
        "type": "n8n-nodes-base.googleSheets",
        "typeVersion": 4.7,
        "position": [
          320,
          672
        ],
        "credentials": {
          "googleSheetsOAuth2Api": {
            "id": "H7ewI1sOrDYabelt",
            "name": "Google Sheets account"
          }
        },
        "continueOnFail": true,
        "retryOnFail": true,
        "maxTries": 5,
        "waitBetweenTries": 5000
      },
      {
        "parameters": {
          "jsCode": "// Get transactions from Read All Transactions node\nconst transactions = $input.all();\n\n// Filter for Type = 'expense' transactions only\nconst expenseTransactions = transactions.filter(item => {\n  const type = item.json.Type;\n  return type && type.toLowerCase() === 'expense';\n});\n\n// Return expense transactions\nif (expenseTransactions.length === 0) {\n  return [{ json: { message: 'No expense transactions found', count: 0 } }];\n}\n\nreturn expenseTransactions;"
        },
        "id": "node-filter-expense",
        "name": "Filter Expense Transactions",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          544,
          384
        ]
      },
      {
        "parameters": {
          "jsCode": "// Get transactions from Read All Transactions node\nconst transactions = $input.all();\n\n// Filter for Type = 'income' transactions only\nconst incomeTransactions = transactions.filter(item => {\n  const type = item.json.Type;\n  return type && type.toLowerCase() === 'income';\n});\n\n// Return income transactions\nif (incomeTransactions.length === 0) {\n  return [{ json: { message: 'No income transactions found', count: 0 } }];\n}\n\nreturn incomeTransactions;"
        },
        "id": "node-filter-income",
        "name": "Filter Income Transactions",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          544,
          672
        ]
      },
      {
        "parameters": {
          "jsCode": "// Match receipts to expense transactions from merged data\n// n8n Merge creates combinations (receipts \u00d7 transactions)\n// Each item contains fields from BOTH sources\n\nconst allItems = $input.all();\nconsole.log(`Processing ${allItems.length} merged combinations`);\n\nif (allItems.length === 0) {\n  return [{ json: { message: 'No merged items to process' } }];\n}\n\n// Log first item to understand structure\nconsole.log('First merged item sample:', JSON.stringify(allItems[0]?.json, null, 2));\n\n// ===== DATE NORMALIZATION =====\n// Converts all date formats to YYYY-MM-DD for comparison\nfunction normalizeDate(dateStr) {\n  if (!dateStr) return null;\n  if (dateStr instanceof Date) {\n    const d = dateStr;\n    return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;\n  }\n  \n  const str = String(dateStr).trim();\n  \n  // DD.MM.YYYY (European format with dots)\n  let match = str.match(/^(\\d{1,2})\\.(\\d{1,2})\\.(\\d{4})$/);\n  if (match) {\n    const [_, day, month, year] = match;\n    return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;\n  }\n  \n  // DD/MM/YYYY (European format with slashes)\n  match = str.match(/^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/);\n  if (match) {\n    const [_, day, month, year] = match;\n    return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;\n  }\n  \n  // YYYY-MM-DD (already normalized)\n  match = str.match(/^(\\d{4})-(\\d{1,2})-(\\d{1,2})$/);\n  if (match) {\n    const [_, year, month, day] = match;\n    return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;\n  }\n  \n  // Jan 29, 2026 or January 29, 2026 (text month)\n  match = str.match(/(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\\s+(\\d{1,2}),?\\s+(\\d{4})/i);\n  if (match) {\n    const monthMap = {jan:1,feb:2,mar:3,apr:4,may:5,jun:6,jul:7,aug:8,sep:9,oct:10,nov:11,dec:12};\n    const month = monthMap[match[1].toLowerCase()];\n    const day = match[2];\n    const year = match[3];\n    return `${year}-${String(month).padStart(2, '0')}-${day.padStart(2, '0')}`;\n  }\n  \n  // Fallback to Date parsing\n  try {\n    const parsed = new Date(str);\n    if (!isNaN(parsed.getTime())) {\n      return `${parsed.getFullYear()}-${String(parsed.getMonth() + 1).padStart(2, '0')}-${String(parsed.getDate()).padStart(2, '0')}`;\n    }\n  } catch (e) {}\n  \n  return null;\n}\n\n// ===== AMOUNT NORMALIZATION =====\n// Strips currency symbols, handles German/US number formats, returns float\nfunction normalizeAmount(amountStr) {\n  if (typeof amountStr === 'number') return Math.abs(amountStr);\n  if (!amountStr) return null;\n  \n  let str = String(amountStr).trim();\n  \n  // Strip currency symbols (\u20ac, $, \u00a3, CHF, etc.)\n  str = str.replace(/[\u20ac$\u00a3\u00a5\u20b9]/g, '');\n  str = str.replace(/CHF|USD|EUR|GBP/gi, '');\n  str = str.trim();\n  \n  // Handle German format: 1.572,94 (dot as thousand separator, comma as decimal)\n  // vs US format: 1,572.94 (comma as thousand separator, dot as decimal)\n  \n  const hasDot = str.includes('.');\n  const hasComma = str.includes(',');\n  \n  if (hasDot && hasComma) {\n    // Both present - determine format by position\n    const dotPos = str.lastIndexOf('.');\n    const commaPos = str.lastIndexOf(',');\n    \n    if (commaPos > dotPos) {\n      // German format: 1.572,94 \u2192 remove dots, replace comma with dot\n      str = str.replace(/\\./g, '').replace(',', '.');\n    } else {\n      // US format: 1,572.94 \u2192 remove commas\n      str = str.replace(/,/g, '');\n    }\n  } else if (hasComma) {\n    // Only comma - could be decimal separator or thousand separator\n    // If 2 digits after comma, it's decimal (1,99 or 1572,94)\n    const afterComma = str.split(',')[1];\n    if (afterComma && afterComma.length === 2) {\n      // Decimal separator\n      str = str.replace(',', '.');\n    } else {\n      // Thousand separator\n      str = str.replace(/,/g, '');\n    }\n  } else if (hasDot) {\n    // Only dot - likely decimal separator (US format)\n    // Unless it's like 1.000 (German thousand)\n    const afterDot = str.split('.')[1];\n    if (afterDot && afterDot.length === 3 && !afterDot.match(/\\d{1,2}/)) {\n      // Might be German thousand: 1.000\n      str = str.replace(/\\./g, '');\n    }\n  }\n  \n  // Remove any remaining spaces\n  str = str.replace(/\\s/g, '');\n  \n  const parsed = parseFloat(str);\n  return isNaN(parsed) ? null : Math.abs(parsed);\n}\n\nconst matches = [];\nconst seenPairs = new Set();\nlet skipped = 0;\n\nfor (const item of allItems) {\n  const json = item.json;\n  \n  const receiptFileName = json.FileName;\n  const transactionId = json.TransactionID;\n  \n  if (!receiptFileName || !transactionId) {\n    skipped++;\n    continue;\n  }\n  \n  if (json.receipt_id && json.receipt_id !== '') {\n    continue;\n  }\n  \n  // ===== NORMALIZE DATE =====\n  const dateStr = json.Date || json.date;\n  const normalizedDate = normalizeDate(dateStr);\n  if (!normalizedDate) {\n    console.log(`Skipping - invalid date: ${dateStr}`);\n    skipped++;\n    continue;\n  }\n  \n  // ===== NORMALIZE AMOUNT =====\n  const amountRaw = json.Amount || json.amount;\n  const normalizedAmount = normalizeAmount(amountRaw);\n  if (!normalizedAmount || isNaN(normalizedAmount)) {\n    console.log(`Skipping - invalid amount: ${amountRaw}`);\n    skipped++;\n    continue;\n  }\n  \n  const receiptRow = json.receipt_row_number || json.row_number;\n  const txnRow = json.transaction_row_number || json.row_number;\n  \n  const pairKey = `${receiptRow}-${transactionId}`;\n  if (seenPairs.has(pairKey)) {\n    continue;\n  }\n  seenPairs.add(pairKey);\n  \n  matches.push({\n    json: {\n      receiptId: json.ReceiptID || receiptRow,\n      transactionId: transactionId,\n      receiptFileName: receiptFileName,\n      receiptVendor: json.Vendor,\n      transactionDescription: json.Description,\n      transactionBank: json.Bank,\n      matchedAmount: normalizedAmount,\n      matchedDate: normalizedDate,\n      originalDate: dateStr,\n      originalAmount: amountRaw,\n      receiptRowNumber: receiptRow,\n      transactionRowNumber: txnRow,\n      matchType: 'receipt-expense',\n      confidence: 'high'\n    }\n  });\n}\n\nconsole.log(`Found ${matches.length} matches (skipped ${skipped} items)`);\n\nif (matches.length === 0) {\n  console.log('WARNING: No matches found!');\n  return [{ json: { \n    message: 'No matches found', \n    totalCombinations: allItems.length,\n    skipped: skipped,\n    sampleItem: allItems[0]?.json \n  } }];\n}\n\nreturn matches;"
        },
        "id": "node-5",
        "name": "Match Receipts to Expense Transactions",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          992,
          288
        ]
      },
      {
        "parameters": {
          "resource": "fileFolder",
          "queryString": "='1_zVNS3JHS15pUjvfEJMh9nzYWn6TltbS' in parents and mimeType='application/pdf'",
          "filter": {},
          "options": {
            "fields": [
              "id",
              "name",
              "mimeType",
              "createdTime",
              "modifiedTime"
            ]
          }
        },
        "id": "node-search-invoices",
        "name": "Search Production Folder (Priority 1)",
        "type": "n8n-nodes-base.googleDrive",
        "typeVersion": 3,
        "position": [
          768,
          576
        ],
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "PGGNF2ZKD2XqDhe0",
            "name": "Google Drive (swayfromthehook)"
          }
        },
        "continueOnFail": true
      },
      {
        "parameters": {
          "jsCode": "// Enhanced invoice matching with invoice # extraction and fuzzy client name matching\nconst invoices = $input.all();\nconst incomeTransactions = $('Filter Income Transactions').all();\n\n// Levenshtein distance for fuzzy matching\nfunction levenshtein(a, b) {\n  const matrix = [];\n  for (let i = 0; i <= b.length; i++) {\n    matrix[i] = [i];\n  }\n  for (let j = 0; j <= a.length; j++) {\n    matrix[0][j] = j;\n  }\n  for (let i = 1; i <= b.length; i++) {\n    for (let j = 1; j <= a.length; j++) {\n      if (b.charAt(i - 1) === a.charAt(j - 1)) {\n        matrix[i][j] = matrix[i - 1][j - 1];\n      } else {\n        matrix[i][j] = Math.min(\n          matrix[i - 1][j - 1] + 1,\n          matrix[i][j - 1] + 1,\n          matrix[i - 1][j] + 1\n        );\n      }\n    }\n  }\n  return matrix[b.length][a.length];\n}\n\nfunction similarity(s1, s2) {\n  const longer = s1.length > s2.length ? s1 : s2;\n  const shorter = s1.length > s2.length ? s2 : s1;\n  if (longer.length === 0) return 1.0;\n  return (longer.length - levenshtein(longer, shorter)) / longer.length;\n}\n\n// Extract invoice number from bank description\nfunction extractInvoiceNumber(description) {\n  if (!description) return null;\n\n  // Patterns: #123, Invoice 123, Rechnung 123, INV-123, Rech. #123\n  const patterns = [\n    /#(\\d+)/i,\n    /Invoice[:\\s]+(\\d+)/i,\n    /Rechnung[:\\s]+#?(\\d+)/i,\n    /INV-?(\\d+)/i,\n    /Rech\\.?[:\\s]+#?(\\d+)/i\n  ];\n\n  for (const pattern of patterns) {\n    const match = description.match(pattern);\n    if (match && match[1]) {\n      return match[1];\n    }\n  }\n\n  return null;\n}\n\n// Match transactions to invoices\nconst matches = [];\n\nfor (const txnItem of incomeTransactions) {\n  const txn = txnItem.json;\n  let bestMatch = null;\n  let matchConfidence = 'none';\n  let matchMethod = null;\n\n  // Extract invoice # from transaction description\n  const invoiceNumber = extractInvoiceNumber(txn['Description/Vendor']);\n\n  // PRIMARY MATCH: Invoice # + amount + date\n  if (invoiceNumber) {\n    for (const invItem of invoices) {\n      const inv = invItem.json;\n      const fileNameMatch = inv.file_name && inv.file_name.includes(invoiceNumber);\n\n      if (fileNameMatch) {\n        // Check amount match (\u00b12 EUR tolerance)\n        const txnAmount = Math.abs(parseFloat(txn.Amount || 0));\n        const invAmount = parseFloat(inv.amount || 0);\n        const amountMatch = Math.abs(txnAmount - invAmount) <= 2;\n\n        // Check date match (\u00b17 days)\n        const txnDate = new Date(txn.Date);\n        const invDate = new Date(inv.date);\n        const daysDiff = Math.abs((txnDate - invDate) / (1000 * 60 * 60 * 24));\n        const dateMatch = daysDiff <= 7;\n\n        if (amountMatch && dateMatch) {\n          bestMatch = inv;\n          matchConfidence = 'primary';\n          matchMethod = 'invoice#';\n          break;\n        }\n      }\n    }\n  }\n\n  // SECONDARY MATCH: Fuzzy client name + amount + date\n  if (!bestMatch) {\n    const txnDescription = (txn['Description/Vendor'] || '').toLowerCase();\n\n    for (const invItem of invoices) {\n      const inv = invItem.json;\n      const clientName = (inv.client_name || '').toLowerCase();\n\n      if (clientName) {\n        const similarityScore = similarity(txnDescription, clientName);\n\n        if (similarityScore >= 0.7) {\n          // Check exact amount match\n          const txnAmount = Math.abs(parseFloat(txn.Amount || 0));\n          const invAmount = parseFloat(inv.amount || 0);\n          const amountMatch = txnAmount === invAmount;\n\n          // Check date match (\u00b114 days)\n          const txnDate = new Date(txn.Date);\n          const invDate = new Date(inv.date);\n          const daysDiff = Math.abs((txnDate - invDate) / (1000 * 60 * 60 * 24));\n          const dateMatch = daysDiff <= 14;\n\n          if (amountMatch && dateMatch) {\n            bestMatch = inv;\n            matchConfidence = 'secondary';\n            matchMethod = 'fuzzy-client';\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  // \u2705 FIX: Ensure proper object structure for ALL items\n  matches.push({\n    json: {\n      TransactionID: txn.TransactionID,\n      Date: txn.Date,\n      'Description/Vendor': txn['Description/Vendor'],\n      Amount: txn.Amount,\n      matched: bestMatch ? true : false,\n      invoice_id: bestMatch?.invoice_id || null,\n      invoice_file_id: bestMatch?.file_id || null,\n      invoice_file_name: bestMatch?.file_name || null,\n      match_confidence: matchConfidence,\n      match_method: matchMethod,\n      extracted_invoice_number: invoiceNumber,\n      confidence: bestMatch ? (matchConfidence === 'primary' ? 0.95 : 0.75) : 0,\n      matchType: 'invoice'\n    }\n  });\n}\n\n// \u2705 FIX: Always return array of objects with json property\n// Even if no matches, return empty match structure\nif (matches.length === 0) {\n  return [{\n    json: {\n      message: 'No income transactions to match',\n      matched: false,\n      matchType: 'invoice',\n      confidence: 0\n    }\n  }];\n}\n\nreturn matches;"
        },
        "id": "node-match-invoices",
        "name": "Match Invoices to Income Transactions",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1440,
          768
        ]
      },
      {
        "parameters": {
          "mode": "combine",
          "combineBy": "combineAll",
          "options": {}
        },
        "id": "merge-receipt-invoice-matches",
        "name": "Merge Receipt and Invoice Matches",
        "type": "n8n-nodes-base.merge",
        "typeVersion": 3,
        "position": [
          1664,
          480
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "leftValue": "",
              "caseSensitive": true,
              "typeValidation": "strict"
            },
            "combinator": "and",
            "conditions": [
              {
                "id": "condition-1",
                "leftValue": "={{ $json.matched }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals"
                }
              },
              {
                "id": "condition-2",
                "leftValue": "={{ $json.confidence }}",
                "rightValue": 0.7,
                "operator": {
                  "type": "number",
                  "operation": "gt"
                }
              }
            ]
          },
          "options": {}
        },
        "id": "node-6",
        "name": "Filter Successful Matches",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          1888,
          480
        ]
      },
      {
        "parameters": {
          "jsCode": "// Prepare receipt updates (only receipt matches)\nconst matches = $input.all().filter(item => item.json.matchType === 'receipt');\n\nconst updates = matches.map(match => ({\n  json: {\n    range: `Receipts!A${match.json.receiptRow}:Z${match.json.receiptRow}`,\n    values: [[\n      // Assumes ReceiptID is in a specific column - adjust as needed\n      // This creates an update for the TransactionID column in the receipt row\n      match.json.transactionId\n    ]]\n  }\n}));\n\nreturn updates;"
        },
        "id": "node-7",
        "name": "Prepare Receipt Updates",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2112,
          384
        ]
      },
      {
        "parameters": {
          "documentId": {
            "mode": "id",
            "value": "1l1uA8qA0DCGzGLBhmP2HqTzaajjbkURY2SLeqSuHMXM"
          },
          "sheetName": {
            "mode": "name",
            "value": "Receipts"
          }
        },
        "id": "node-8",
        "name": "Update Receipts Sheet",
        "type": "n8n-nodes-base.googleSheets",
        "typeVersion": 4.7,
        "position": [
          2336,
          384
        ],
        "credentials": {
          "googleSheetsOAuth2Api": {
            "id": "H7ewI1sOrDYabelt",
            "name": "Google Sheets account"
          }
        },
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// Prepare transaction updates with enhanced invoice matching data\nconst matches = $input.all();\n\nconst updates = [];\n\nfor (const match of matches) {\n  const json = match.json;\n\n  // For receipt matches (expenses)\n  if (json.matchType === 'receipt') {\n    updates.push({\n      json: {\n        TransactionID: json.transactionId,\n        ReceiptID: json.receiptId,\n        MatchConfidence: json.confidence,\n        MatchMethod: 'receipt',\n        // New columns (leave empty for receipt matches)\n        InvoiceID: '',\n        InvoiceFileID: ''\n      }\n    });\n  }\n  // For invoice matches (income)\n  else if (json.matchType === 'invoice' && json.matched) {\n    updates.push({\n      json: {\n        TransactionID: json.TransactionID,\n        // New invoice columns\n        InvoiceID: json.invoice_id || '',\n        InvoiceFileID: json.invoice_file_id || '',\n        MatchConfidence: json.match_confidence || 'none',\n        MatchMethod: json.match_method || 'none',\n        // Receipt columns (leave empty for invoice matches)\n        ReceiptID: ''\n      }\n    });\n  }\n}\n\n// \u2705 FIX: Always return valid structure, even if empty\nif (updates.length === 0) {\n  return [{\n    json: {\n      message: 'No transaction updates needed',\n      updateCount: 0\n    }\n  }];\n}\n\nreturn updates;"
        },
        "id": "node-9",
        "name": "Prepare Transaction Updates",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2112,
          576
        ]
      },
      {
        "parameters": {
          "documentId": {
            "mode": "id",
            "value": "1l1uA8qA0DCGzGLBhmP2HqTzaajjbkURY2SLeqSuHMXM"
          },
          "sheetName": {
            "mode": "name",
            "value": "Transactions"
          }
        },
        "id": "node-10",
        "name": "Update Transactions Sheet",
        "type": "n8n-nodes-base.googleSheets",
        "typeVersion": 4.7,
        "position": [
          2336,
          576
        ],
        "credentials": {
          "googleSheetsOAuth2Api": {
            "id": "H7ewI1sOrDYabelt",
            "name": "Google Sheets account"
          }
        },
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// Get all match results from both branches\nconst receiptMatches = $('Match Receipts to Expense Transactions').all();\nconst invoiceMatches = $('Match Invoices to Income Transactions').all();\n\n// Combine both\nconst allMatches = [...receiptMatches, ...invoiceMatches];\n\n// Calculate statistics\nconst totalItems = allMatches.length;\nconst matched = allMatches.filter(m => m.json.matched && m.json.confidence > 0.7);\nconst unmatched = allMatches.filter(m => !m.json.matched || m.json.confidence <= 0.7);\nconst receiptMatchCount = matched.filter(m => m.json.matchType === 'receipt').length;\nconst invoiceMatchCount = matched.filter(m => m.json.matchType === 'invoice').length;\nconst exactMatches = matched.filter(m => m.json.matchTier === 'EXACT');\nconst fuzzyMatches = matched.filter(m => m.json.matchTier === 'FUZZY');\n\n// Calculate average confidence (only for successful matches)\nconst avgConfidence = matched.length > 0 \n  ? matched.reduce((sum, m) => sum + m.json.confidence, 0) / matched.length \n  : 0;\n\nreturn [{\n  json: {\n    summary: `Processed ${totalItems} items: ${matched.length} matched (${receiptMatchCount} receipts, ${invoiceMatchCount} invoices), ${unmatched.length} unmatched`,\n    totalItems: totalItems,\n    successfulMatches: matched.length,\n    receiptMatches: receiptMatchCount,\n    invoiceMatches: invoiceMatchCount,\n    unmatchedItems: unmatched.length,\n    exactMatches: exactMatches.length,\n    fuzzyMatches: fuzzyMatches.length,\n    averageConfidence: avgConfidence.toFixed(2),\n    timestamp: new Date().toISOString()\n  }\n}];"
        },
        "id": "node-11",
        "name": "Generate Summary Report",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2560,
          480
        ]
      },
      {
        "parameters": {
          "jsCode": "// \u2705 REUSE existing data from 'Read All Transactions' node (no duplicate read)\nconst transactions = $('Read All Transactions').all();\n\n// Filter for unmatched expense transactions (Type='expense' AND ReceiptID is empty)\nconst unmatchedExpenses = transactions.filter(item => {\n  const type = item.json.Type;\n  const receiptId = item.json.ReceiptID;\n  \n  return type && type.toLowerCase() === 'expense' && (!receiptId || receiptId === '');\n});\n\n// Return unmatched expense transactions\nif (unmatchedExpenses.length === 0) {\n  return [{ json: { message: 'No unmatched expense transactions', count: 0, items: [] } }];\n}\n\nreturn [{\n  json: {\n    message: `Found ${unmatchedExpenses.length} unmatched expense transactions`,\n    count: unmatchedExpenses.length,\n    items: unmatchedExpenses.map(item => ({\n      TransactionID: item.json.TransactionID,\n      Date: item.json.Date,\n      Vendor: item.json.Vendor,\n      Amount: item.json.Amount,\n      Type: item.json.Type\n    }))\n  }\n}];"
        },
        "id": "node-find-unmatched-expenses",
        "name": "Find Unmatched Expense Transactions",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3008,
          288
        ]
      },
      {
        "parameters": {
          "jsCode": "// \u2705 REUSE existing data from 'Read All Transactions' node (no duplicate read)\nconst transactions = $('Read All Transactions').all();\n\n// Extract invoice number helper function\nfunction extractInvoiceNumber(description) {\n  if (!description) return null;\n\n  const patterns = [\n    /#(\\d+)/i,\n    /Invoice[:\\s]+(\\d+)/i,\n    /Rechnung[:\\s]+#?(\\d+)/i,\n    /INV-?(\\d+)/i,\n    /Rech\\.?[:\\s]+#?(\\d+)/i\n  ];\n\n  for (const pattern of patterns) {\n    const match = description.match(pattern);\n    if (match && match[1]) {\n      return match[1];\n    }\n  }\n\n  return null;\n}\n\n// Filter for unmatched income transactions\nconst unmatchedIncome = transactions.filter(item => {\n  const type = item.json.Type;\n  const invoiceId = item.json.InvoiceID;\n\n  return type && type.toLowerCase() === 'income' && (!invoiceId || invoiceId === '');\n});\n\n// Build items array BEFORE return statement (more explicit)\nconst items = unmatchedIncome.map(item => {\n  const description = item.json['Description/Vendor'] || '';\n  const extractedInvoiceNum = extractInvoiceNumber(description);\n\n  return {\n    TransactionID: item.json.TransactionID,\n    Date: item.json.Date,\n    Client: item.json['Description/Vendor'],\n    Amount: item.json.Amount,\n    ExtractedInvoiceNumber: extractedInvoiceNum,\n    Reason: extractedInvoiceNum\n      ? `Invoice #${extractedInvoiceNum} not found in any source`\n      : 'No invoice number found in description'\n  };\n});\n\n// \u2705 FIX: Return explicit object structure\nif (unmatchedIncome.length === 0) {\n  return [{\n    json: {\n      message: 'No unmatched income transactions',\n      count: 0,\n      items: []\n    }\n  }];\n}\n\n// \u2705 FIX: Use pre-built items array\nreturn [{\n  json: {\n    message: `Found ${unmatchedIncome.length} unmatched income transactions`,\n    count: unmatchedIncome.length,\n    items: items\n  }\n}];"
        },
        "id": "node-find-unmatched-income",
        "name": "Find Unmatched Income Transactions",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3008,
          480
        ]
      },
      {
        "parameters": {
          "jsCode": "// \u2705 REUSE existing data from 'Read Unmatched Receipts' node (no duplicate read)\nconst receipts = $('Read Unmatched Receipts').all();\n\n// Filter for orphaned receipts (no transaction_id or empty transaction_id)\nconst orphanedReceipts = receipts.filter(item => {\n  const transactionId = item.json.transaction_id;\n  return !transactionId || transactionId === '';\n});\n\n// Return orphaned receipts\nif (orphanedReceipts.length === 0) {\n  return [{ json: { message: 'No orphaned receipts', count: 0, items: [] } }];\n}\n\nreturn [{\n  json: {\n    message: `Found ${orphanedReceipts.length} orphaned receipts`,\n    count: orphanedReceipts.length,\n    items: orphanedReceipts.map(item => ({\n      ReceiptID: item.json.ReceiptID,\n      Date: item.json.Date,\n      Vendor: item.json.Vendor,\n      Amount: item.json.Amount\n    }))\n  }\n}];"
        },
        "id": "node-find-orphaned-receipts",
        "name": "Find Orphaned Receipts",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3008,
          672
        ]
      },
      {
        "parameters": {
          "jsCode": "// Get data from all missing items nodes\nconst unmatchedExpenses = $('Find Unmatched Expense Transactions').first().json;\nconst unmatchedIncome = $('Find Unmatched Income Transactions').first().json;\nconst orphanedReceipts = $('Find Orphaned Receipts').first().json;\nconst summary = $('Generate Summary Report').first().json;\n\n// Calculate totals\nconst totalUnmatched = unmatchedExpenses.count + unmatchedIncome.count;\nconst totalOrphaned = orphanedReceipts.count;\nconst totalTransactions = parseInt(summary.totalItems) || 0;\nconst totalMatched = parseInt(summary.successfulMatches) || 0;\n\n// Calculate success rate\nconst successRate = totalTransactions > 0 \n  ? ((totalMatched / totalTransactions) * 100).toFixed(1)\n  : '0.0';\n\n// Build markdown report\nlet report = `# Missing Items Report\\n\\n`;\nreport += `**Generated:** ${new Date().toISOString()}\\n\\n`;\nreport += `---\\n\\n`;\n\n// Overall Statistics\nreport += `## \ud83d\udcca Overall Statistics\\n\\n`;\nreport += `- **Total Transactions Processed:** ${totalTransactions}\\n`;\nreport += `- **Successfully Matched:** ${totalMatched} (${successRate}%)\\n`;\nreport += `- **Unmatched Transactions:** ${totalUnmatched}\\n`;\nreport += `- **Orphaned Documents:** ${totalOrphaned}\\n\\n`;\nreport += `---\\n\\n`;\n\n// Unmatched Expense Transactions\nreport += `## \ud83d\udcb3 Unmatched Expense Transactions (Need Receipts)\\n\\n`;\nif (unmatchedExpenses.count > 0) {\n  report += `**Count:** ${unmatchedExpenses.count}\\n\\n`;\n  report += `| Date | Vendor | Amount |\\n`;\n  report += `|------|--------|--------|\\n`;\n  unmatchedExpenses.items.forEach(item => {\n    report += `| ${item.Date} | ${item.Vendor} | $${item.Amount} |\\n`;\n  });\n  report += `\\n`;\n} else {\n  report += `\u2705 **All expense transactions have receipts!**\\n\\n`;\n}\n\nreport += `---\\n\\n`;\n\n// Unmatched Income Transactions (ENHANCED)\nreport += `## \ud83d\udcc4 Unmatched Income Transactions (Need Invoices)\\n\\n`;\nif (unmatchedIncome.count > 0) {\n  report += `**Count:** ${unmatchedIncome.count}\\n\\n`;\n  report += `| Date | Client | Amount | Extracted Invoice # | Reason |\\n`;\n  report += `|------|--------|--------|---------------------|--------|\\n`;\n  unmatchedIncome.items.forEach(item => {\n    const invoiceNum = item.ExtractedInvoiceNumber || 'N/A';\n    const reason = item.Reason || 'Unknown';\n    report += `| ${item.Date} | ${item.Client} | $${item.Amount} | ${invoiceNum} | ${reason} |\\n`;\n  });\n  report += `\\n`;\n  report += `> **Search locations checked:** Production folder, Invoice Pool\\n\\n`;\n} else {\n  report += `\u2705 **All income transactions have invoices!**\\n\\n`;\n}\n\nreport += `---\\n\\n`;\n\n// Orphaned Receipts\nreport += `## \ud83e\uddfe Orphaned Receipts (No Transaction Match)\\n\\n`;\nif (orphanedReceipts.count > 0) {\n  report += `**Count:** ${orphanedReceipts.count}\\n\\n`;\n  report += `| Date | Vendor | Amount |\\n`;\n  report += `|------|--------|--------|\\n`;\n  orphanedReceipts.items.forEach(item => {\n    report += `| ${item.Date} | ${item.Vendor} | $${item.Amount} |\\n`;\n  });\n  report += `\\n`;\n  report += `> **Note:** These receipts don't match any transaction. Consider creating transactions or removing if duplicates.\\n\\n`;\n} else {\n  report += `\u2705 **All receipts are matched to transactions!**\\n\\n`;\n}\n\nreport += `---\\n\\n`;\n\n// Action Items\nreport += `## \u2705 Action Items\\n\\n`;\nif (unmatchedExpenses.count > 0) {\n  report += `1. **Find ${unmatchedExpenses.count} missing receipts** for expense transactions listed above\\n`;\n}\nif (unmatchedIncome.count > 0) {\n  report += `${unmatchedExpenses.count > 0 ? '2' : '1'}. **Find ${unmatchedIncome.count} missing invoices** for income transactions listed above\\n`;\n  \n  // Count how many have extractable invoice numbers\n  const withInvoiceNum = unmatchedIncome.items.filter(item => item.ExtractedInvoiceNumber).length;\n  if (withInvoiceNum > 0) {\n    report += `   - ${withInvoiceNum} transaction(s) have extractable invoice numbers to search for\\n`;\n  }\n}\nif (orphanedReceipts.count > 0) {\n  const step = (unmatchedExpenses.count > 0 ? 1 : 0) + (unmatchedIncome.count > 0 ? 1 : 0) + 1;\n  report += `${step}. **Review ${orphanedReceipts.count} orphaned receipts** - create transactions or remove duplicates\\n`;\n}\n\nif (unmatchedExpenses.count === 0 && unmatchedIncome.count === 0 && orphanedReceipts.count === 0) {\n  report += `\ud83c\udf89 **No action needed! All documents are properly matched.**\\n\\n`;\n}\n\nreturn [{\n  json: {\n    reportMarkdown: report,\n    summary: {\n      totalTransactions: totalTransactions,\n      totalMatched: totalMatched,\n      successRate: successRate,\n      unmatchedExpenses: unmatchedExpenses.count,\n      unmatchedIncome: unmatchedIncome.count,\n      orphanedReceipts: orphanedReceipts.count,\n      totalIssues: totalUnmatched + totalOrphaned\n    },\n    timestamp: new Date().toISOString()\n  }\n}];"
        },
        "id": "node-format-missing-items-report",
        "name": "Format Missing Items Report",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3232,
          480
        ]
      },
      {
        "parameters": {
          "mode": "combine",
          "combineBy": "combineAll",
          "options": {}
        },
        "id": "merge-receipts-transactions",
        "name": "Merge Receipts and Expense Txns",
        "type": "n8n-nodes-base.merge",
        "typeVersion": 3,
        "position": [
          768,
          288
        ]
      },
      {
        "parameters": {
          "documentId": {
            "mode": "id",
            "value": "1l1uA8qA0DCGzGLBhmP2HqTzaajjbkURY2SLeqSuHMXM"
          },
          "sheetName": {
            "mode": "name",
            "value": "Invoices"
          },
          "options": {}
        },
        "id": "node-read-invoices-sheet",
        "name": "Read Invoices Database",
        "type": "n8n-nodes-base.googleSheets",
        "typeVersion": 4.7,
        "position": [
          768,
          960
        ],
        "credentials": {
          "googleSheetsOAuth2Api": {
            "id": "H7ewI1sOrDYabelt",
            "name": "Google Sheets account"
          }
        },
        "continueOnFail": true,
        "retryOnFail": true,
        "maxTries": 3,
        "waitBetweenTries": 60000
      },
      {
        "parameters": {
          "resource": "fileFolder",
          "queryString": "='1V7UmNvDP3a2t6IIbJJI7y8YXz6_X7F6l' in parents and mimeType='application/pdf'",
          "filter": {},
          "options": {
            "fields": [
              "id",
              "name",
              "mimeType",
              "createdTime",
              "modifiedTime"
            ]
          }
        },
        "id": "node-search-pool",
        "name": "Search Invoice Pool (Priority 2)",
        "type": "n8n-nodes-base.googleDrive",
        "typeVersion": 3,
        "position": [
          768,
          768
        ],
        "credentials": {
          "googleDriveOAuth2Api": {
            "id": "PGGNF2ZKD2XqDhe0",
            "name": "Google Drive (swayfromthehook)"
          }
        },
        "continueOnFail": true
      },
      {
        "parameters": {
          "mode": "combine",
          "combineBy": "combineAll"
        },
        "id": "node-merge-sources",
        "name": "Merge All Invoice Sources",
        "type": "n8n-nodes-base.merge",
        "typeVersion": 3,
        "position": [
          992,
          768
        ]
      },
      {
        "parameters": {
          "jsCode": "// Enrich Google Drive files with Invoices database metadata\nconst allItems = $input.all();\n\n// Separate Drive files from database records\nconst driveFiles = [];\nconst databaseRecords = [];\n\nfor (const item of allItems) {\n  const json = item.json;\n  // Database records have InvoiceID, Drive files have 'id' (file ID)\n  if (json.InvoiceID) {\n    databaseRecords.push(json);\n  } else if (json.id) {\n    driveFiles.push(json);\n  }\n}\n\n// Create lookup map by FileID from database\nconst metadataMap = {};\nfor (const record of databaseRecords) {\n  const fileId = record.FileID;\n  if (fileId) {\n    metadataMap[fileId] = record;\n  }\n}\n\n// Enrich Drive files with database metadata\nconst enrichedInvoices = [];\nfor (const file of driveFiles) {\n  const metadata = metadataMap[file.id] || {};\n  \n  enrichedInvoices.push({\n    json: {\n      file_id: file.id,\n      file_name: file.name,\n      created_time: file.createdTime,\n      modified_time: file.modifiedTime,\n      mime_type: file.mimeType,\n      // From Invoices sheet (if available)\n      invoice_id: metadata.InvoiceID || null,\n      client_name: metadata.ClientName || null,\n      amount: metadata.Amount || null,\n      currency: metadata.Currency || null,\n      date: metadata.Date || null,\n      project: metadata.Project || null\n    }\n  });\n}\n\nif (enrichedInvoices.length === 0) {\n  return [{ json: { message: 'No invoices found from any source', count: 0 } }];\n}\n\nreturn enrichedInvoices;"
        },
        "id": "node-enrich-invoices",
        "name": "Enrich Invoices with Database Metadata",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1216,
          768
        ]
      },
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "process-matching",
          "options": {}
        },
        "id": "webhook-trigger-temp",
        "name": "Webhook Trigger (Testing)",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2,
        "position": [
          96,
          720
        ],
        "webhookId": "437c9269-b18a-4a53-8fcb-83b200177323"
      },
      {
        "id": "webhook-rematch",
        "name": "Re-match Webhook",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2,
        "position": [
          96,
          400
        ],
        "parameters": {
          "path": "expense-rematch",
          "httpMethod": "POST",
          "responseMode": "lastNode",
          "options": {}
        }
      }
    ],
    "connections": {
      "Manual Trigger": {
        "main": [
          [
            {
              "node": "Read Unmatched Receipts",
              "type": "main",
              "index": 0
            },
            {
              "node": "Read All Transactions",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Read Unmatched Receipts": {
        "main": [
          [
            {
              "node": "Filter Unmatched Receipts Only",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Read All Transactions": {
        "main": [
          [
            {
              "node": "Filter Expense Transactions",
              "type": "main",
              "index": 0
            },
            {
              "node": "Filter Income Transactions",
              "type": "main",
              "index": 0
            },
            {
              "node": "Read Invoices Database",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Filter Unmatched Receipts Only": {
        "main": [
          [
            {
              "node": "Merge Receipts and Expense Txns",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Filter Expense Transactions": {
        "main": [
          [
            {
              "node": "Merge Receipts and Expense Txns",
              "type": "main",
              "index": 1
            }
          ]
        ]
      },
      "Filter Income Transactions": {
        "main": [
          [
            {
              "node": "Search Production Folder (Priority 1)",
              "type": "main",
              "index": 0
            },
            {
              "node": "Search Invoice Pool (Priority 2)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Match Receipts to Expense Transactions": {
        "main": [
          [
            {
              "node": "Merge Receipt and Invoice Matches",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Search Production Folder (Priority 1)": {
        "main": [
          [
            {
              "node": "Merge All Invoice Sources",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Match Invoices to Income Transactions": {
        "main": [
          [
            {
              "node": "Merge Receipt and Invoice Matches",
              "type": "main",
              "index": 1
            }
          ]
        ]
      },
      "Merge Receipt and Invoice Matches": {
        "main": [
          [
            {
              "node": "Filter Successful Matches",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Filter Successful Matches": {
        "main": [
          [
            {
              "node": "Prepare Receipt Updates",
              "type": "main",
              "index": 0
            },
            {
              "node": "Prepare Transaction Updates",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Receipt Updates": {
        "main": [
          [
            {
              "node": "Update Receipts Sheet",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Transaction Updates": {
        "main": [
          [
            {
              "node": "Update Transactions Sheet",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Update Receipts Sheet": {
        "main": [
          [
            {
              "node": "Generate Summary Report",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Update Transactions Sheet": {
        "main": [
          [
            {
              "node": "Generate Summary Report",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Find Unmatched Expense Transactions": {
        "main": [
          [
            {
              "node": "Format Missing Items Report",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Find Unmatched Income Transactions": {
        "main": [
          [
            {
              "node": "Format Missing Items Report",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Find Orphaned Receipts": {
        "main": [
          [
            {
              "node": "Format Missing Items Report",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Search Invoice Pool (Priority 2)": {
        "main": [
          [
            {
              "node": "Merge All Invoice Sources",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Merge All Invoice Sources": {
        "main": [
          [
            {
              "node": "Enrich Invoices with Database Metadata",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Enrich Invoices with Database Metadata": {
        "main": [
          [
            {
              "node": "Match Invoices to Income Transactions",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Webhook Trigger (Testing)": {
        "main": [
          [
            {
              "node": "Read Unmatched Receipts",
              "type": "main",
              "index": 0
            },
            {
              "node": "Read All Transactions",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Read Invoices Database": {
        "main": [
          [
            {
              "node": "Merge All Invoice Sources",
              "type": "1",
              "index": 0
            }
          ]
        ]
      },
      "Generate Summary Report": {
        "main": [
          [
            {
              "node": "Find Unmatched Expense Transactions",
              "type": "main",
              "index": 0
            },
            {
              "node": "Find Unmatched Income Transactions",
              "type": "main",
              "index": 0
            },
            {
              "node": "Find Orphaned Receipts",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Merge Receipts and Expense Txns": {
        "main": [
          [
            {
              "node": "Match Receipts to Expense Transactions",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Re-match Webhook": {
        "main": [
          [
            {
              "node": "Read Unmatched Receipts",
              "type": "0",
              "index": 0
            },
            {
              "node": "Read All Transactions",
              "type": "0",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "Sway Clarke",
    "name": null,
    "description": null,
    "autosaved": false,
    "workflowPublishHistory": [
      {
        "createdAt": "2026-01-29T19:11:49.462Z",
        "id": 1789,
        "workflowId": "CJtdqMreZ17esJAW",
        "versionId": "26df59da-4504-43b2-aa5a-581faa5f5320",
        "event": "activated",
        "userId": "e9bd9112-c2e3-4f67-873a-e1001baeafd8"
      }
    ]
  }
}