{
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "30 23 * * *"
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Daily Schedule",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.3,
      "position": [
        688,
        304
      ],
      "disabled": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "days-back",
              "name": "daysBack",
              "value": "={{ $json.daysBack || 60 }}",
              "type": "number"
            },
            {
              "id": "fathom-key",
              "name": "fathomApiKey",
              "value": "lzTrFSjfaTlbGrxW_txpEg.iKQ-dm_4tL395VFtFv04FmLuLiTweAVQXMeiUWrdB_4",
              "type": "string"
            },
            {
              "id": "batch-limit",
              "name": "batchLimit",
              "value": 3,
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "id": "config-node",
      "name": "Config",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        912,
        -32
      ]
    },
    {
      "parameters": {
        "url": "https://api.fathom.ai/external/v1/meetings?limit=100",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $('Config').item.json.fathomApiKey }}"
            }
          ]
        },
        "options": {}
      },
      "id": "list-meetings",
      "name": "List Meetings",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        1136,
        -32
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Extract meetings array from API response and handle pagination\n// This node will be called multiple times if there are more pages\nconst daysBack = $('Config').item.json.daysBack;\nconst apiKey = $('Config').item.json.fathomApiKey;\n\nconst cutoffDate = new Date();\ncutoffDate.setDate(cutoffDate.getDate() - daysBack);\n\n// Fetch all pages of meetings\nlet allMeetings = [];\nlet nextCursor = null;\nlet pageCount = 0;\nconst maxPages = 20; // Safety limit\n\ndo {\n  let url = 'https://api.fathom.ai/external/v1/meetings';\n  if (nextCursor) {\n    url += `?cursor=${encodeURIComponent(nextCursor)}`;\n  }\n  \n  const response = await this.helpers.httpRequest({\n    method: 'GET',\n    url: url,\n    headers: {\n      'x-api-key': apiKey\n    }\n  });\n  \n  const meetings = response.items || [];\n  allMeetings = allMeetings.concat(meetings);\n  \n  nextCursor = response.next_cursor || null;\n  pageCount++;\n  \n  // Check if we've gone past the cutoff date\n  if (meetings.length > 0) {\n    const lastMeeting = meetings[meetings.length - 1];\n    const lastMeetingDate = new Date(lastMeeting.created_at || lastMeeting.scheduled_start_time);\n    if (lastMeetingDate < cutoffDate) {\n      // We've fetched enough - stop pagination\n      break;\n    }\n  }\n  \n} while (nextCursor && pageCount < maxPages);\n\n// Filter by daysBack\nconst filteredMeetings = allMeetings.filter(meeting => {\n  const meetingDate = new Date(meeting.created_at || meeting.scheduled_start_time);\n  return meetingDate >= cutoffDate;\n});\n\nreturn filteredMeetings.map(meeting => ({ json: meeting }));"
      },
      "id": "extract-meetings",
      "name": "Extract Meetings Array",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1360,
        -32
      ]
    },
    {
      "parameters": {
        "url": "=https://api.fathom.ai/external/v1/recordings/{{ $json.recording_id }}/transcript",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $('Config').item.json.fathomApiKey }}"
            }
          ]
        },
        "options": {}
      },
      "id": "get-transcript",
      "name": "Get Transcript",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        1584,
        -32
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Group related meetings before processing\nconst meetings = $input.all();\n\n// Sort meetings by date/time (earliest first)\nmeetings.sort(function(a, b) {\n  const dateA = new Date(a.json.created_at || a.json.scheduled_start_time || 0);\n  const dateB = new Date(b.json.created_at || b.json.scheduled_start_time || 0);\n  return dateA - dateB;\n});\n\nconst grouped = [];\nconst processed = new Set();\n\nfor (let i = 0; i < meetings.length; i++) {\n  if (processed.has(i)) continue;\n  \n  const current = meetings[i].json;\n  const relatedIndices = [i];\n  \n  // Find related meetings\n  for (let j = i + 1; j < meetings.length; j++) {\n    if (processed.has(j)) continue;\n    \n    const candidate = meetings[j].json;\n    \n    // Extract meeting titles for comparison\n    const currentTitle = (current.title || current.meeting_title || '').toLowerCase();\n    const candidateTitle = (candidate.title || candidate.meeting_title || '').toLowerCase();\n    \n    // Check for impromptu keywords\n    const hasImpromptu = candidateTitle.includes('impromptu') || candidateTitle.includes('continued') || candidateTitle.includes('follow-up');\n    \n    // Extract common name parts (words longer than 3 chars)\n    const currentWords = currentTitle.split(/\\s+/).filter(function(w) { return w.length > 3; });\n    const candidateWords = candidateTitle.split(/\\s+/).filter(function(w) { return w.length > 3; });\n    const commonWords = currentWords.filter(function(w) { return candidateWords.includes(w); });\n    \n    // Rule 1: Same contact + impromptu keyword\n    if (commonWords.length >= 2 && hasImpromptu) {\n      relatedIndices.push(j);\n      processed.add(j);\n      continue;\n    }\n    \n    // Rule 2: Time-based grouping (within 2 hours)\n    const currentDate = new Date(current.created_at || current.scheduled_start_time || 0);\n    const candidateDate = new Date(candidate.created_at || candidate.scheduled_start_time || 0);\n    const timeDiffHours = Math.abs(candidateDate - currentDate) / (1000 * 60 * 60);\n    \n    if (timeDiffHours <= 2 && commonWords.length >= 1) {\n      relatedIndices.push(j);\n      processed.add(j);\n    }\n  }\n  \n  // Process the grouped meetings\n  if (relatedIndices.length === 1) {\n    // No grouping needed - single meeting\n    const meeting = current;\n    \n    // Check calendar_invitees for external contacts\n    const calendarInvitees = meeting.calendar_invitees || [];\n    const externalInvitees = calendarInvitees.filter(function(invitee) { return invitee.is_external === true; });\n    const isStandaloneImpromptu = externalInvitees.length === 0;\n    const primaryContact = externalInvitees[0] || {};\n    \n    const meetingDate = meeting.created_at || meeting.scheduled_start_time || new Date().toISOString();\n    \n    // Format date inline\n    const date = new Date(meetingDate);\n    const day = date.getDate();\n    const month = date.toLocaleString('en-US', { month: 'long' });\n    const year = date.getFullYear();\n    const s = ['th', 'st', 'nd', 'rd'];\n    const v = day % 100;\n    const ordinal = day + (s[(v - 20) % 10] || s[v] || s[0]);\n    const dateFolderName = month + ' ' + ordinal + ', ' + year;\n    \n    // Format transcript inline\n    const transcript = meeting.transcript;\n    let formattedTranscript = '';\n    if (transcript && Array.isArray(transcript)) {\n      const parts = [];\n      for (let k = 0; k < transcript.length; k++) {\n        const utterance = transcript[k];\n        const speaker = (utterance.speaker && utterance.speaker.display_name) || 'Unknown';\n        parts.push(speaker + ': ' + utterance.text);\n      }\n      formattedTranscript = parts.join('\\n');\n    }\n    \n    grouped.push({\n      meeting_title: meeting.title || meeting.meeting_title || 'Untitled Meeting',\n      meeting_url: meeting.url,\n      recording_id: meeting.recording_id,\n      contact_name: primaryContact.name || null,\n      contact_email: primaryContact.email || null,\n      is_standalone_impromptu: isStandaloneImpromptu,\n      meeting_date: meetingDate,\n      date_folder_name: dateFolderName,\n      combined_transcript: formattedTranscript,\n      parent_folder_id: '1fzJztc3nweG6mzsEJOJBeaA6tk84jys9',\n      is_grouped: false,\n      grouped_meeting_count: 1\n    });\n  } else {\n    // Merge multiple related meetings\n    const baseMeeting = current;\n    const allMeetings = [];\n    for (let idx = 0; idx < relatedIndices.length; idx++) {\n      allMeetings.push(meetings[relatedIndices[idx]].json);\n    }\n    \n    // Combine transcripts chronologically\n    const transcriptParts = [];\n    for (let index = 0; index < allMeetings.length; index++) {\n      const m = allMeetings[index];\n      const transcript = m.transcript;\n      let formattedPart = '';\n      if (transcript && Array.isArray(transcript)) {\n        const parts = [];\n        for (let k = 0; k < transcript.length; k++) {\n          const utterance = transcript[k];\n          const speaker = (utterance.speaker && utterance.speaker.display_name) || 'Unknown';\n          parts.push(speaker + ': ' + utterance.text);\n        }\n        formattedPart = parts.join('\\n');\n      }\n      if (index === 0) {\n        transcriptParts.push(formattedPart);\n      } else {\n        transcriptParts.push('\\n\\n--- Continued (Part ' + (index + 1) + ') ---\\n\\n' + formattedPart);\n      }\n    }\n    const combinedTranscript = transcriptParts.join('');\n    \n    // Merge participants (deduplicate)\n    const allParticipants = new Set();\n    for (let midx = 0; midx < allMeetings.length; midx++) {\n      const m = allMeetings[midx];\n      const invitees = m.calendar_invitees || [];\n      for (let iidx = 0; iidx < invitees.length; iidx++) {\n        const inv = invitees[iidx];\n        if (inv.name) allParticipants.add(inv.name);\n        if (inv.email) allParticipants.add(inv.email);\n      }\n    }\n    \n    // Sum durations\n    let totalDuration = 0;\n    for (let midx = 0; midx < allMeetings.length; midx++) {\n      totalDuration += (allMeetings[midx].duration || 0);\n    }\n    \n    // Check for external invitees in first meeting\n    const calendarInvitees = baseMeeting.calendar_invitees || [];\n    const externalInvitees = calendarInvitees.filter(function(invitee) { return invitee.is_external === true; });\n    const isStandaloneImpromptu = externalInvitees.length === 0;\n    const primaryContact = externalInvitees[0] || {};\n    \n    const meetingDate = baseMeeting.created_at || baseMeeting.scheduled_start_time || new Date().toISOString();\n    \n    // Format date inline\n    const date = new Date(meetingDate);\n    const day = date.getDate();\n    const month = date.toLocaleString('en-US', { month: 'long' });\n    const year = date.getFullYear();\n    const s = ['th', 'st', 'nd', 'rd'];\n    const v = day % 100;\n    const ordinal = day + (s[(v - 20) % 10] || s[v] || s[0]);\n    const dateFolderName = month + ' ' + ordinal + ', ' + year;\n    \n    grouped.push({\n      meeting_title: (baseMeeting.title || baseMeeting.meeting_title || 'Untitled Meeting') + ' (' + relatedIndices.length + ' parts)',\n      meeting_url: baseMeeting.url,\n      recording_id: baseMeeting.recording_id,\n      contact_name: primaryContact.name || null,\n      contact_email: primaryContact.email || null,\n      is_standalone_impromptu: isStandaloneImpromptu,\n      meeting_date: meetingDate,\n      date_folder_name: dateFolderName,\n      combined_transcript: combinedTranscript,\n      parent_folder_id: '1fzJztc3nweG6mzsEJOJBeaA6tk84jys9',\n      is_grouped: true,\n      grouped_meeting_count: relatedIndices.length,\n      total_duration: totalDuration,\n      participants: Array.from(allParticipants)\n    });\n  }\n  \n  processed.add(i);\n}\n\n// Return array of items with json property\nconst outputItems = [];\nfor (let i = 0; i < grouped.length; i++) {\n  outputItems.push({ json: grouped[i] });\n}\nreturn outputItems;"
      },
      "id": "group-related-meetings",
      "name": "Process Each Meeting",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2032,
        -32
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Prepare data for folder creation and file saving\nconst meeting = $input.item.json;\n\n// Get contact name - use AI-extracted name if available, otherwise from meeting data\nlet contactName = meeting.contact_name || meeting.meeting_title || 'Unknown Contact';\n\n// Clean up contact name (remove 'and Sway Clarke' suffix if present)\nif (contactName.includes(' and Sway Clarke')) {\n  contactName = contactName.replace(' and Sway Clarke', '').trim();\n}\n\nreturn {\n  json: {\n    contact_name: contactName,\n    contact_email: meeting.contact_email || null,\n    is_standalone_impromptu: meeting.is_standalone_impromptu || false,\n    ai_extracted: meeting.ai_extracted || false,\n    transcript: meeting.combined_transcript || '',\n    date_folder_name: meeting.date_folder_name,\n    meeting_date: meeting.meeting_date,\n    parent_folder_id: meeting.parent_folder_id || '12wrqmiKIaIZJz8GmSSkl1aUc0HNY5JBw'\n  }\n};"
      },
      "id": "prepare-date-folder",
      "name": "Prepare Date Folder Name",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6672,
        328
      ]
    },
    {
      "parameters": {
        "resource": "folder",
        "name": "={{ $json.date_folder_name }}",
        "driveId": {
          "__rl": true,
          "mode": "list",
          "value": "My Drive"
        },
        "folderId": {
          "__rl": true,
          "mode": "id",
          "value": "={{ $json.parent_folder_id }}"
        },
        "options": {}
      },
      "id": "create-or-get-folder",
      "name": "Create or Get Date Folder",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        7120,
        328
      ],
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "a4m50EefR3DJoU0R",
          "name": "Google Drive account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "resource": "file",
        "operation": "upload",
        "driveId": {
          "__rl": true,
          "mode": "list",
          "value": "My Drive"
        },
        "folderId": {
          "__rl": true,
          "mode": "id",
          "value": "={{ $json.folder_id }}"
        },
        "name": "={{ $json.filename }}",
        "options": {}
      },
      "id": "save-transcript",
      "name": "Save Transcript to Drive",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        7792,
        328
      ],
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "a4m50EefR3DJoU0R",
          "name": "Google Drive account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {},
      "id": "manual-trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        240,
        -32
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Convert transcript text to binary file with date in filename\nconst item = $input.item.json;\nconst transcript = item.transcript || '';\nconst contactName = item.contact_name || 'Unknown';\nconst dateFolderName = item.date_folder_name || 'Unknown Date';\nconst folderId = item.folder_id;\n\n// Create filename with contact name and date\nconst fileName = `${contactName} - ${dateFolderName} - Transcript.txt`;\n\n// Create binary data from text\nconst binaryData = Buffer.from(transcript, 'utf-8');\n\nreturn {\n  json: {\n    contact_name: contactName,\n    folder_id: folderId,\n    file_name: fileName\n  },\n  binary: {\n    data: {\n      data: binaryData.toString('base64'),\n      mimeType: 'text/plain',\n      fileName: fileName\n    }\n  }\n};"
      },
      "id": "convert-to-binary",
      "name": "Convert to Binary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7568,
        328
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.is_standalone_impromptu }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              },
              "id": "standalone-check"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-impromptu",
      "name": "Is Standalone Impromptu?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        5424,
        376
      ],
      "disabled": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "prompt",
              "name": "prompt",
              "value": "=You are analyzing a meeting transcript to extract the contact person's name.\n\nTranscript:\n{{ $json.combined_transcript }}\n\nExtract the primary contact person mentioned in this transcript (not Sway Clarke - he is the host). Return ONLY their full name, nothing else.\n\nIf no clear contact name is found, return: UNKNOWN",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "build-ai-prompt",
      "name": "Build AI Prompt",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        5648,
        304
      ],
      "disabled": true
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "messages": {
          "values": [
            {
              "content": "={{ $json.prompt }}"
            }
          ]
        },
        "options": {
          "temperature": 0
        }
      },
      "id": "openai-extract",
      "name": "Extract Name (OpenAI)",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        5872,
        304
      ],
      "credentials": {
        "openAiApi": {
          "id": "xmJ7t6kaKgMwA1ce",
          "name": "OpenAi account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Extract the contact name from OpenAI response and merge with original data\nconst aiResponse = $input.item.json;\nconst originalData = $('Is Standalone Impromptu?').item.json;\n\n// Get the extracted name from OpenAI response\n// Handle different response formats from OpenAI node\nlet extractedName = 'UNKNOWN';\nif (aiResponse.message?.content) {\n  extractedName = aiResponse.message.content;\n} else if (aiResponse.content?.[0]?.text) {\n  extractedName = aiResponse.content[0].text;\n} else if (aiResponse.text) {\n  extractedName = aiResponse.text;\n} else if (typeof aiResponse.output === 'string') {\n  extractedName = aiResponse.output;\n}\n\n// Clean up the name\nextractedName = extractedName.trim();\n\nreturn {\n  json: {\n    ...originalData,\n    contact_name: extractedName,\n    ai_extracted: true\n  }\n};"
      },
      "id": "extract-ai-name",
      "name": "Extract AI Name",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6224,
        304
      ],
      "disabled": true
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        6448,
        376
      ],
      "id": "f14fb868-5c37-421e-8627-f9ee9381f0d3",
      "name": "Merge",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Get meetings from Extract Meetings Array\nconst meetings = $('Extract Meetings Array').all();\n\n// Get transcripts from Get Transcript\nconst transcripts = $('Get Transcript').all();\n\n// Combine by position\nconst combined = meetings.map((meeting, index) => {\n  const transcriptData = transcripts[index]?.json || {};\n  return {\n    json: {\n      ...meeting.json,\n      transcript: transcriptData.transcript || []\n    }\n  };\n});\n\nreturn combined;"
      },
      "id": "dac3357c-b30b-4672-9a1c-6d50eed930a7",
      "name": "Combine Meeting + Transcript1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1808,
        -32
      ]
    },
    {
      "parameters": {
        "jsCode": "// Get all meetings and extract unique dates\nconst meetings = $input.all();\n\n// Create a map of unique dates\nconst uniqueDates = new Map();\n\nfor (const item of meetings) {\n  const dateFolderName = item.json.date_folder_name;\n  if (!uniqueDates.has(dateFolderName)) {\n    uniqueDates.set(dateFolderName, {\n      date_folder_name: dateFolderName,\n      parent_folder_id: item.json.parent_folder_id\n    });\n  }\n}\n\n// Return unique dates as separate items\nreturn Array.from(uniqueDates.values()).map(date => ({ json: date }));"
      },
      "id": "4e61a66e-eefe-4695-8b66-f41dbcfebda5",
      "name": "Get Unique Dates",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6896,
        328
      ]
    },
    {
      "parameters": {
        "jsCode": "// Get all meetings from Prepare Date Folder Name\nconst meetings = $('Prepare Date Folder Name').all();\n\n// Get all created folders from Create or Get Date Folder\nconst folders = $('Create or Get Date Folder').all();\n\n// Create a map of date_folder_name -> folder_id\nconst folderMap = new Map();\nfor (const folder of folders) {\n  folderMap.set(folder.json.name, folder.json.id);\n}\n\n// Match each meeting to its folder\nconst result = meetings.map(meeting => {\n  const dateFolderName = meeting.json.date_folder_name;\n  const folderId = folderMap.get(dateFolderName);\n  \n  return {\n    json: {\n      ...meeting.json,\n      folder_id: folderId\n    }\n  };\n});\n\nreturn result;"
      },
      "id": "b26242c7-112d-40e6-b38d-6fb93b8b03d2",
      "name": "Match Meetings to Folders",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7344,
        328
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "fathom-test",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        240,
        160
      ],
      "webhookId": "ccfeaeb4-73ad-41cf-b5bc-77224ee7061a"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ai-prompt-assignment",
              "name": "ai_prompt",
              "value": "You are an expert AI consultant analyzing client meeting transcripts to extract actionable insights.\n\n# Your Task\nAnalyze this transcript using the frameworks below and return a structured JSON response.\n\n---\n\n## ANALYSIS FRAMEWORKS\n\n### 1. Pain Point Analysis\n**Goal:** Identify problems the client is actively experiencing\n\n**Structure:**\n```json\n\"pain_points\": [\n  {\n    \"pain_point\": \"Concise, specific description of the problem\",\n    \"category\": \"One of: Efficiency, Cost, Quality, Scalability, Technical Debt, User Experience, Compliance, Other\",\n    \"severity\": \"One of: Critical, High, Medium, Low\",\n    \"impact\": \"Business impact in measurable terms (time, money, quality, risk)\",\n    \"frequency\": \"How often this occurs (daily, weekly, monthly, rarely)\",\n    \"teams_affected\": [\"List of teams/departments impacted\"],\n    \"current_workaround\": \"How they're currently handling this (if any)\",\n    \"quantifiable_metrics\": {\n      \"time_lost\": \"e.g., '2 hours per week per person'\",\n      \"money_lost\": \"e.g., '$5K monthly in wasted ad spend'\",\n      \"error_rate\": \"e.g., '15% of orders have data entry errors'\"\n    }\n  }\n]\n```\n\n**Severity Guidelines:**\n- **Critical**: Blocking revenue, causing customer churn, legal/compliance risk, system downtime\n- **High**: Significant inefficiency, frequent manual work, quality issues affecting customers\n- **Medium**: Moderate inefficiency, occasional errors, process friction\n- **Low**: Minor annoyance, infrequent issue, nice-to-have improvement\n\n---\n\n### 2. Growth Opportunity Analysis\n**Goal:** Identify untapped potential and expansion possibilities\n\n**Structure:**\n```json\n\"growth_opportunities\": [\n  {\n    \"opportunity\": \"Clear description of the growth potential\",\n    \"category\": \"One of: New Revenue Stream, Market Expansion, Product Enhancement, Operational Efficiency, Customer Retention, Team Productivity, Other\",\n    \"potential_impact\": {\n      \"revenue_potential\": \"Estimated revenue impact (e.g., '$50K annual recurring revenue')\",\n      \"time_savings\": \"Estimated time saved (e.g., '10 hours per week')\",\n      \"quality_improvement\": \"Qualitative improvement (e.g., 'Reduce customer churn by 20%')\"\n    },\n    \"requirements\": [\"List of what's needed to realize this opportunity\"],\n    \"timeline_estimate\": \"Rough timeline to implement (e.g., '2-3 months')\",\n    \"confidence_level\": \"One of: High, Medium, Low (based on clarity in transcript)\"\n  }\n]\n```\n\n**Category Guidelines:**\n- **New Revenue Stream**: New product, service, or monetization method\n- **Market Expansion**: New customer segments, geographies, or channels\n- **Product Enhancement**: Features that increase value/usage\n- **Operational Efficiency**: Process improvements that free up resources\n- **Customer Retention**: Improvements that reduce churn or increase LTV\n- **Team Productivity**: Tools/processes that make team more effective\n\n---\n\n### 3. Context & Relationship Insights\n**Goal:** Understand the bigger picture and relationship dynamics\n\n**Structure:**\n```json\n\"context_insights\": {\n  \"meeting_type\": \"One of: Discovery Call, Regular Check-in, Project Kickoff, Review/Retrospective, Emergency/Fire Drill, Other\",\n  \"relationship_stage\": \"One of: Prospecting, New Client, Active Engagement, Ongoing Relationship, At Risk, Renewal Discussion\",\n  \"client_maturity\": \"One of: Early Stage, Growing, Established, Enterprise\",\n  \"technical_sophistication\": \"One of: Non-technical, Basic, Intermediate, Advanced\",\n  \"decision_makers_present\": [\"List of decision-makers mentioned or present\"],\n  \"budget_signals\": \"Any signals about budget, timeline, or resource constraints\",\n  \"competitive_landscape\": \"Mentions of competitors, alternatives, or market pressures\",\n  \"urgency_indicators\": \"Signals about timeline pressure or urgency\"\n}\n```\n\n---\n\n### 4. Action Items & Next Steps\n**Goal:** Extract commitments and follow-ups\n\n**Structure:**\n```json\n\"action_items\": [\n  {\n    \"action\": \"Specific task or deliverable\",\n    \"owner\": \"Who is responsible (me, client, team member name)\",\n    \"deadline\": \"Due date or timeframe (if mentioned)\",\n    \"priority\": \"One of: Urgent, High, Medium, Low\",\n    \"dependencies\": [\"What needs to happen first (if any)\"]\n  }\n]\n```\n\n---\n\n### 5. Strategic Recommendations\n**Goal:** Suggest next steps based on analysis\n\n**Structure:**\n```json\n\"recommendations\": [\n  {\n    \"recommendation\": \"Clear, actionable suggestion\",\n    \"rationale\": \"Why this makes sense based on the transcript\",\n    \"priority\": \"One of: Immediate, Short-term (1-3 months), Medium-term (3-6 months), Long-term (6+ months)\",\n    \"effort_estimate\": \"One of: Low, Medium, High\",\n    \"opportunity_matrix_position\": \"One of: Quick Win (High Impact, Low Effort), Major Project (High Impact, High Effort), Fill-in (Low Impact, Low Effort), Time Sink (Low Impact, High Effort)\"\n  }\n]\n```\n\n**Opportunity Matrix Framework:**\n```\n        High Impact\n            |\nQuick Win   |   Major Project\n------------|------------\nFill-in     |   Time Sink\n            |\n        Low Effort → High Effort\n```\n\n---\n\n## OUTPUT REQUIREMENTS\n\n**Return ONLY valid JSON** with this exact structure:\n\n```json\n{\n  \"pain_points\": [...],\n  \"growth_opportunities\": [...],\n  \"context_insights\": {...},\n  \"action_items\": [...],\n  \"recommendations\": [...],\n  \"meeting_title\": \"VALUE_FROM_METADATA\",\n  \"meeting_date\": \"VALUE_FROM_METADATA\",\n  \"contact_name\": \"VALUE_FROM_METADATA\",\n  \"contact_email\": \"VALUE_FROM_METADATA\",\n  \"meeting_url\": \"VALUE_FROM_METADATA\",\n  \"recording_id\": \"VALUE_FROM_METADATA\"\n}\n```\n\n**Quality Guidelines:**\n- Be specific and concrete, avoid vague generalizations\n- Quote specific numbers, dates, or details from transcript when available\n- If information is unclear or missing, mark with \"[needs clarification]\" or \"[not mentioned]\"\n- Focus on actionable insights, not just summary\n- Prioritize business impact over technical details\n- Always use Opportunity Matrix framework for prioritization\n\n**Edge Case Handling:**\n- **Multiple pain points with similar descriptions**: Consolidate if same root cause, separate if affect different teams/workflows\n- **No clear pain points (exploratory call)**: Focus on growth opportunities and process improvement possibilities instead\n- **Highly technical jargon**: Translate to business impact (e.g., \"database query timeout\" → \"3-second page load delay frustrates users\")\n- **Conflicting information in transcript**: Note conflict explicitly and mark conclusion as \"[conflicting data - needs clarification]\"\n- **Discovery call vs regular check-in**: Discovery = focus on pain points and opportunities; Regular = focus on progress, feedback, additional needs\n- **Vague quantification (\"takes too long\")**: Estimate based on context and mark \"[estimated based on: context clues + industry benchmarks]\"\n\n---\n\n## MEETING METADATA (REQUIRED IN JSON RESPONSE)\n\n**CRITICAL: Include these exact fields and values in your JSON output:**\n\n```\nmeeting_title: ${ $json.meeting_title || \"Unknown\" }\nmeeting_date: ${ $json.meeting_date || \"Unknown\" }\ncontact_name: ${ $json.contact_name || \"Unknown\" }\ncontact_email: ${ $json.contact_email || \"Unknown\" }\nmeeting_url: ${ $json.meeting_url || \"\" }\nrecording_id: ${ $json.recording_id || \"\" }\n```\n\n**Return these fields AS-IS in your JSON response. Do not modify or interpret them.**\n\n---\n\nTranscript:\n${ $json.combined_transcript }\n\nReturn ONLY valid JSON, no markdown formatting.",
              "type": "string"
            }
          ]
        }
      },
      "id": "enhanced-ai-analysis",
      "name": "Enhanced AI Analysis",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2480,
        64
      ]
    },
    {
      "parameters": {
        "jsCode": "// CRITICAL FIX: GPT-4o returns structured JSON with arrays/objects\n// This node converts structured data into formatted text strings for Airtable\n\nconst item = $input.item;\nconst inputData = item.json;\n\n// The AI response is in inputData.message.content (from OpenAI node)\nlet aiContent = '';\nif (inputData.message && inputData.message.content) {\n  aiContent = inputData.message.content;\n} else if (typeof inputData === 'string') {\n  aiContent = inputData;\n} else {\n  throw new Error('AI response not found in expected format');\n}\n\n// 6-tier bulletproof JSON parser\nlet parsed = {};\n\ntry {\n  // Tier 1: Try direct parse\n  parsed = JSON.parse(aiContent);\n} catch (e1) {\n  try {\n    // Tier 2: Strip markdown code fences\n    let cleaned = aiContent.replace(/^```json\\s*/i, '').replace(/\\s*```$/,  '');\n    parsed = JSON.parse(cleaned);\n  } catch (e2) {\n    try {\n      // Tier 3: Extract first complete JSON object\n      const jsonMatch = aiContent.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        parsed = JSON.parse(jsonMatch[0]);\n      } else {\n        throw new Error('No JSON object found');\n      }\n    } catch (e3) {\n      try {\n        // Tier 4: Try fixing common escape issues\n        let fixed = aiContent.replace(/\\n/g, '\\\\n').replace(/\\r/g, '');\n        parsed = JSON.parse(fixed);\n      } catch (e4) {\n        try {\n          // Tier 5: Extract between first { and last }\n          const firstBrace = aiContent.indexOf('{');\n          const lastBrace = aiContent.lastIndexOf('}');\n          if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {\n            const extracted = aiContent.substring(firstBrace, lastBrace + 1);\n            parsed = JSON.parse(extracted);\n          } else {\n            throw new Error('No valid JSON structure found');\n          }\n        } catch (e5) {\n          // Tier 6: Return error structure with raw content\n          console.error('All JSON parsing attempts failed:', e5);\n          parsed = {\n            pain_points: [],\n            growth_opportunities: [],\n            context_insights: {},\n            action_items: [],\n            recommendations: [],\n            meeting_title: 'Parse Error',\n            meeting_date: '',\n            contact_name: '',\n            contact_email: '',\n            meeting_url: '',\n            recording_id: ''\n          };\n        }\n      }\n    }\n  }\n}\n\n// ==========================================\n// FORMATTER FUNCTIONS - Convert arrays/objects to formatted text\n// ==========================================\n\n/**\n * Format pain points array into readable markdown text\n */\nfunction formatPainPoints(painPoints) {\n  if (!Array.isArray(painPoints) || painPoints.length === 0) return '';\n  \n  let formatted = '## Pain Points' + '\\n\\n';\n  painPoints.forEach(function(pp, index) {\n    formatted += '### ' + (index + 1) + '. ' + (pp.pain_point || 'Unnamed Pain Point') + '\\n';\n    formatted += '- **Category:** ' + (pp.category || 'N/A') + '\\n';\n    formatted += '- **Severity:** ' + (pp.severity || 'N/A') + '\\n';\n    formatted += '- **Impact:** ' + (pp.impact || 'N/A') + '\\n';\n    formatted += '- **Frequency:** ' + (pp.frequency || 'N/A') + '\\n';\n    if (pp.teams_affected && Array.isArray(pp.teams_affected)) {\n      formatted += '- **Teams Affected:** ' + pp.teams_affected.join(', ') + '\\n';\n    }\n    if (pp.current_workaround) {\n      formatted += '- **Current Workaround:** ' + pp.current_workaround + '\\n';\n    }\n    if (pp.quantifiable_metrics) {\n      formatted += '- **Metrics:**' + '\\n';\n      if (pp.quantifiable_metrics.time_lost) formatted += '  - Time Lost: ' + pp.quantifiable_metrics.time_lost + '\\n';\n      if (pp.quantifiable_metrics.money_lost) formatted += '  - Money Lost: ' + pp.quantifiable_metrics.money_lost + '\\n';\n      if (pp.quantifiable_metrics.error_rate) formatted += '  - Error Rate: ' + pp.quantifiable_metrics.error_rate + '\\n';\n    }\n    formatted += '\\n';\n  });\n  return formatted.trim();\n}\n\n/**\n * Format growth opportunities array into readable markdown text\n */\nfunction formatGrowthOpportunities(opportunities) {\n  if (!Array.isArray(opportunities) || opportunities.length === 0) return '';\n  \n  let formatted = '## Growth Opportunities' + '\\n\\n';\n  opportunities.forEach(function(opp, index) {\n    formatted += '### ' + (index + 1) + '. ' + (opp.opportunity || 'Unnamed Opportunity') + '\\n';\n    formatted += '- **Category:** ' + (opp.category || 'N/A') + '\\n';\n    if (opp.potential_impact) {\n      formatted += '- **Potential Impact:**' + '\\n';\n      if (opp.potential_impact.revenue_potential) formatted += '  - Revenue: ' + opp.potential_impact.revenue_potential + '\\n';\n      if (opp.potential_impact.time_savings) formatted += '  - Time Savings: ' + opp.potential_impact.time_savings + '\\n';\n      if (opp.potential_impact.quality_improvement) formatted += '  - Quality: ' + opp.potential_impact.quality_improvement + '\\n';\n    }\n    if (opp.requirements && Array.isArray(opp.requirements)) {\n      formatted += '- **Requirements:** ' + opp.requirements.join(', ') + '\\n';\n    }\n    if (opp.timeline_estimate) formatted += '- **Timeline:** ' + opp.timeline_estimate + '\\n';\n    if (opp.confidence_level) formatted += '- **Confidence:** ' + opp.confidence_level + '\\n';\n    formatted += '\\n';\n  });\n  return formatted.trim();\n}\n\n/**\n * Format context insights object into readable markdown text\n */\nfunction formatContextInsights(context) {\n  if (!context || typeof context !== 'object') return '';\n  \n  let formatted = '## Context & Relationship Insights' + '\\n\\n';\n  if (context.meeting_type) formatted += '- **Meeting Type:** ' + context.meeting_type + '\\n';\n  if (context.relationship_stage) formatted += '- **Relationship Stage:** ' + context.relationship_stage + '\\n';\n  if (context.client_maturity) formatted += '- **Client Maturity:** ' + context.client_maturity + '\\n';\n  if (context.technical_sophistication) formatted += '- **Technical Sophistication:** ' + context.technical_sophistication + '\\n';\n  if (context.decision_makers_present && Array.isArray(context.decision_makers_present)) {\n    formatted += '- **Decision Makers:** ' + context.decision_makers_present.join(', ') + '\\n';\n  }\n  if (context.budget_signals) formatted += '- **Budget Signals:** ' + context.budget_signals + '\\n';\n  if (context.competitive_landscape) formatted += '- **Competitive Landscape:** ' + context.competitive_landscape + '\\n';\n  if (context.urgency_indicators) formatted += '- **Urgency:** ' + context.urgency_indicators + '\\n';\n  return formatted.trim();\n}\n\n/**\n * Format action items array into readable markdown text\n */\nfunction formatActionItems(actionItems) {\n  if (!Array.isArray(actionItems) || actionItems.length === 0) return '';\n  \n  let formatted = '## Action Items' + '\\n\\n';\n  actionItems.forEach(function(item, index) {\n    formatted += '### ' + (index + 1) + '. ' + (item.action || 'Unnamed Action') + '\\n';\n    formatted += '- **Owner:** ' + (item.owner || 'N/A') + '\\n';\n    formatted += '- **Priority:** ' + (item.priority || 'N/A') + '\\n';\n    if (item.deadline) formatted += '- **Deadline:** ' + item.deadline + '\\n';\n    if (item.dependencies && Array.isArray(item.dependencies) && item.dependencies.length > 0) {\n      formatted += '- **Dependencies:** ' + item.dependencies.join(', ') + '\\n';\n    }\n    formatted += '\\n';\n  });\n  return formatted.trim();\n}\n\n/**\n * Format recommendations array into readable markdown text\n */\nfunction formatRecommendations(recommendations) {\n  if (!Array.isArray(recommendations) || recommendations.length === 0) return '';\n  \n  let formatted = '## Strategic Recommendations' + '\\n\\n';\n  recommendations.forEach(function(rec, index) {\n    formatted += '### ' + (index + 1) + '. ' + (rec.recommendation || 'Unnamed Recommendation') + '\\n';\n    if (rec.rationale) formatted += '- **Rationale:** ' + rec.rationale + '\\n';\n    formatted += '- **Priority:** ' + (rec.priority || 'N/A') + '\\n';\n    formatted += '- **Effort:** ' + (rec.effort_estimate || 'N/A') + '\\n';\n    if (rec.opportunity_matrix_position) formatted += '- **Matrix Position:** ' + rec.opportunity_matrix_position + '\\n';\n    formatted += '\\n';\n  });\n  return formatted.trim();\n}\n\n// ==========================================\n// CONVERT STRUCTURED DATA TO FORMATTED TEXT\n// ==========================================\n\n// Format all analysis fields\nconst formattedPainPoints = formatPainPoints(parsed.pain_points);\nconst formattedGrowthOpportunities = formatGrowthOpportunities(parsed.growth_opportunities);\nconst formattedContextInsights = formatContextInsights(parsed.context_insights);\nconst formattedActionItems = formatActionItems(parsed.action_items);\nconst formattedRecommendations = formatRecommendations(parsed.recommendations);\n\n// Build comprehensive analysis sections\nconst summaryParts = [formattedContextInsights, formattedGrowthOpportunities].filter(function(s) { return s; });\nconst summary = summaryParts.join('\\n\\n---\\n\\n');\n\nconst quickWinsLines = formattedRecommendations.split('\\n').filter(function(line) {\n  return line.includes('Quick Win') || (line.includes('Low') && line.includes('High Impact'));\n});\nconst quickWins = quickWinsLines.length > 0 ? quickWinsLines.join('\\n') : formattedRecommendations;\n\n// Return formatted data for Airtable\nreturn {\n  json: {\n    // Formatted text fields for Airtable\n    summary: summary || 'No summary generated',\n    pain_points: formattedPainPoints || 'No pain points identified',\n    quick_wins: quickWins || 'No quick wins identified',\n    action_items: formattedActionItems || 'No action items identified',\n    key_insights: formattedContextInsights || 'No key insights generated',\n    pricing_strategy: '', // Not in new AI response format\n    client_journey_map: '', // Not in new AI response format\n    requirements: formattedRecommendations || 'No requirements identified',\n    \n    // Metadata fields from AI response\n    meeting_title: parsed.meeting_title || 'Unknown',\n    meeting_date: parsed.meeting_date || '',\n    contact_name: parsed.contact_name || 'Unknown',\n    contact_email: parsed.contact_email || '',\n    meeting_url: parsed.meeting_url || '',\n    recording_id: parsed.recording_id || '',\n    \n    // Debug info\n    _debug: {\n      raw_pain_points_count: Array.isArray(parsed.pain_points) ? parsed.pain_points.length : 0,\n      raw_opportunities_count: Array.isArray(parsed.growth_opportunities) ? parsed.growth_opportunities.length : 0,\n      raw_action_items_count: Array.isArray(parsed.action_items) ? parsed.action_items.length : 0,\n      raw_recommendations_count: Array.isArray(parsed.recommendations) ? parsed.recommendations.length : 0\n    }\n  }\n};\n"
      },
      "id": "parse-ai-response",
      "name": "Parse AI Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3280,
        64
      ]
    },
    {
      "parameters": {
        "operation": "create",
        "base": {
          "__rl": true,
          "value": "appvd4nlsNhIWYdbI",
          "mode": "list",
          "cachedResultName": "Oloxa CRM",
          "cachedResultUrl": "https://airtable.com/appvd4nlsNhIWYdbI"
        },
        "table": {
          "__rl": true,
          "value": "tblkcbS4DIqvIzJW2",
          "mode": "list",
          "cachedResultName": "Calls",
          "cachedResultUrl": "https://airtable.com/appvd4nlsNhIWYdbI/tblkcbS4DIqvIzJW2"
        },
        "columns": {
          "mappingMode": "autoMapInputData",
          "value": {},
          "matchingColumns": [],
          "schema": [
            {
              "id": "Title",
              "displayName": "Title",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Date",
              "displayName": "Date",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Contact",
              "displayName": "Contact",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Company",
              "displayName": "Company",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "array",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Call Type",
              "displayName": "Call Type",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "options",
              "options": [
                {
                  "name": "AI Audit",
                  "value": "AI Audit"
                },
                {
                  "name": "Discovery",
                  "value": "Discovery"
                },
                {
                  "name": "Follow-up",
                  "value": "Follow-up"
                },
                {
                  "name": "Proposal Review",
                  "value": "Proposal Review"
                },
                {
                  "name": "Kickoff",
                  "value": "Kickoff"
                },
                {
                  "name": "Check-in",
                  "value": "Check-in"
                },
                {
                  "name": "Coaching",
                  "value": "Coaching"
                },
                {
                  "name": "Other",
                  "value": "Other"
                }
              ],
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Summary",
              "displayName": "Summary",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Pain Points",
              "displayName": "Pain Points",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Quick Wins",
              "displayName": "Quick Wins",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Action Items",
              "displayName": "Action Items",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Performance Score",
              "displayName": "Performance Score",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "number",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Improvement Areas",
              "displayName": "Improvement Areas",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Transcript Link",
              "displayName": "Transcript Link",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Complexity Assessment",
              "displayName": "Complexity Assessment",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Roadmap",
              "displayName": "Roadmap",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Key Insights",
              "displayName": "Key Insights",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Pricing Strategy",
              "displayName": "Pricing Strategy",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Client Journey Map",
              "displayName": "Client Journey Map",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Requirements",
              "displayName": "Requirements",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "Call Performance",
              "displayName": "Call Performance",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "array",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "call_type",
              "displayName": "call_type",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "options",
              "options": [
                {
                  "name": "Discovery",
                  "value": "Discovery"
                },
                {
                  "name": "Developer/Coaching",
                  "value": "Developer/Coaching"
                },
                {
                  "name": "Regular",
                  "value": "Regular"
                }
              ],
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "id": "save-to-airtable",
      "name": "Save to Airtable",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [
        5648,
        -8
      ],
      "credentials": {
        "airtableTokenApi": {
          "id": "7Nw3lCcZ0ETUwNak",
          "name": "airtable-creds"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract participant names and meeting metadata from Fathom meeting data\nconst item = $input.item.json;\n\nlet participantNames = [];\nlet primaryParticipant = 'Unknown';\nlet meetingTitle = item.meeting_title || '';\nlet meetingDate = '';\n\n// Parse meeting title format: \"Meeting with [Name] - YYYY-MM-DD HH:MM\"\nif (meetingTitle) {\n  // Extract date from title (format: YYYY-MM-DD)\n  const dateMatch = meetingTitle.match(/(\\d{4}-\\d{2}-\\d{2})/);\n  if (dateMatch) {\n    meetingDate = dateMatch[1];\n  }\n  \n  // Extract participant name from \"Meeting with [Name] - Date\" format\n  const nameMatch = meetingTitle.match(/Meeting with ([^-]+)/i);\n  if (nameMatch) {\n    primaryParticipant = nameMatch[1].trim();\n    participantNames = [primaryParticipant];\n  } else if (item.contact_name && item.contact_name !== 'UNKNOWN') {\n    // Fallback to contact_name\n    primaryParticipant = item.contact_name;\n    participantNames = [primaryParticipant];\n  } else {\n    // Last resort: parse \"Name1 and Name2\" format\n    const parts = meetingTitle.split(' and ');\n    participantNames = parts\n      .map(name => name.trim())\n      .filter(name => name !== 'Sway Clarke' && name !== '');\n    primaryParticipant = participantNames[0] || 'Unknown';\n  }\n}\n\n// If no date found, use current date\nif (!meetingDate) {\n  meetingDate = new Date().toISOString().split('T')[0];\n}\n\nreturn {\n  json: {\n    ...item,\n    participant_names: participantNames,\n    primary_participant: primaryParticipant,\n    meeting_title: meetingTitle,\n    meeting_date: meetingDate\n  }\n};"
      },
      "id": "extract-participant-names",
      "name": "Extract Participant Names",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4528,
        -8
      ]
    },
    {
      "parameters": {
        "operation": "search",
        "base": {
          "__rl": true,
          "mode": "id",
          "value": "appvd4nlsNhIWYdbI"
        },
        "table": {
          "__rl": true,
          "mode": "id",
          "value": "tblEB4I4qVQmkSKpw"
        },
        "options": {}
      },
      "id": "search-contacts",
      "name": "Search Contacts",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [
        4752,
        -8
      ],
      "credentials": {
        "airtableTokenApi": {
          "id": "7Nw3lCcZ0ETUwNak",
          "name": "airtable-creds"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "operation": "search",
        "base": {
          "__rl": true,
          "mode": "id",
          "value": "appvd4nlsNhIWYdbI"
        },
        "table": {
          "__rl": true,
          "mode": "id",
          "value": "tblbr6SBSc5K4l3uk"
        },
        "options": {}
      },
      "id": "search-clients",
      "name": "Search Clients",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [
        4976,
        -8
      ],
      "credentials": {
        "airtableTokenApi": {
          "id": "7Nw3lCcZ0ETUwNak",
          "name": "airtable-creds"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// ==========================================\n// PREPARE AIRTABLE DATA - FIXED DATA ACCESS\n// ==========================================\n\n// Get the current item - it has ALL data from the merge\nconst data = $input.item.json;\n\n// Extract metadata fields from original meeting data\nconst meetingTitle = data.meeting_title || '';\nconst meetingDate = data.meeting_date || new Date().toISOString().split('T')[0];\nconst contactName = data.contact_name || data.primary_participant || 'Unknown';\nconst contactEmail = data.contact_email || '';\n\n// Extract AI analysis fields (from Parse AI Response)\nconst summary = data.summary || '';\nconst painPoints = data.pain_points || '';\nconst quickWins = data.quick_wins || '';\nconst actionItems = data.action_items || '';\nconst keyInsights = data.key_insights || '';\nconst pricingStrategy = data.pricing_strategy || '';\nconst clientJourneyMap = data.client_journey_map || '';\nconst requirements = data.requirements || '';\nconst transcriptLink = data.meeting_url || '';\n\n// Extract performance fields (from Parse Performance Response)\nconst performanceScore = data.perf_performance_score || 0;\nconst improvementAreas = data.perf_improvement_areas || '';\nconst complexityAssessment = data.perf_complexity_assessment || '';\nconst roadmap = data.perf_roadmap || '';\n\n// Detect call type from transcript and title\nconst transcriptText = data.combined_transcript || '';\nconst titleLower = meetingTitle.toLowerCase();\nconst transcriptLower = transcriptText.toLowerCase();\n\nlet callType = 'Discovery';  // Default\n\nif (titleLower.includes('discovery') || titleLower.includes('intake') || titleLower.includes('initial')) {\n  callType = 'Discovery';\n} else if (titleLower.includes('ai audit') || titleLower.includes('audit')) {\n  callType = 'AI Audit';\n} else if (titleLower.includes('proposal review')) {\n  callType = 'Proposal Review';\n} else if (titleLower.includes('proposal')) {\n  callType = 'Proposal';\n} else if (titleLower.includes('testing') || titleLower.includes('deployment')) {\n  callType = 'Testing & Deployment';\n} else if (titleLower.includes('closing') || titleLower.includes('contract')) {\n  callType = 'Closing';\n} else if (transcriptLower.includes('current process') || transcriptLower.includes('pain point') || \n           transcriptLower.includes('tell me about') || transcriptLower.includes('how does your team')) {\n  callType = 'Discovery';\n}\n\n// Format date to YYYY-MM-DD if it's an ISO string\nlet formattedDate = meetingDate;\nif (meetingDate.includes('T')) {\n  formattedDate = meetingDate.split('T')[0];\n}\n\n// Build Airtable data object for Calls table\nconst airtableData = {\n  // Core fields\n  'Title': contactName,\n  'Date': formattedDate,\n  'Contact': contactEmail || contactName,\n  'Call Type': callType,\n  \n  // Analysis fields from Parse AI Response\n  'Summary': summary,\n  'Pain Points': painPoints,\n  'Quick Wins': quickWins,\n  'Action Items': actionItems,\n  'Key Insights': keyInsights,\n  'Pricing Strategy': pricingStrategy,\n  'Client Journey Map': clientJourneyMap,\n  'Requirements': requirements,\n  'Transcript Link': transcriptLink,\n  \n  // Performance fields (for reference, actual performance goes to separate table)\n  'Performance Score': performanceScore,\n  'Improvement Areas': improvementAreas,\n  'Complexity Assessment': complexityAssessment,\n  'Roadmap': roadmap\n};\n\n// Remove empty values to avoid Airtable errors\nconst cleanedData = {};\nfor (const key in airtableData) {\n  const value = airtableData[key];\n  if (value !== null && value !== undefined && value !== '') {\n    cleanedData[key] = value;\n  }\n}\n\nconsole.log('✅ Prepared Airtable data for Calls table:', JSON.stringify(cleanedData, null, 2));\nconsole.log('📊 Data source fields:', {\n  meeting_title: meetingTitle,\n  meeting_date: meetingDate,\n  contact_name: contactName,\n  contact_email: contactEmail,\n  has_summary: !!summary,\n  has_pain_points: !!painPoints,\n  has_quick_wins: !!quickWins,\n  has_action_items: !!actionItems,\n  has_key_insights: !!keyInsights,\n  has_pricing_strategy: !!pricingStrategy,\n  has_client_journey_map: !!clientJourneyMap,\n  has_requirements: !!requirements,\n  has_performance_score: performanceScore > 0\n});\n\n// Return array with single item\nreturn [{ json: cleanedData }];"
      },
      "id": "prepare-airtable-data",
      "name": "Prepare Airtable Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5200,
        -8
      ]
    },
    {
      "parameters": {
        "jsCode": "// Check if webhook contains transcript data\nconst items = $input.all();\n\nif (items.length === 0 || !items[0].json) {\n  // No data, fetch from API\n  return [{ json: { route: 'api', daysBack: 60 } }];\n}\n\nconst data = items[0].json;\n\n// WEBHOOK PAYLOAD STRUCTURE:\n// Expected format: { body: { transcript: [...], title: \"...\", ... } }\n// OR: { transcript: [...], title: \"...\", ... } (direct)\n\n// Check body.transcript first (n8n webhook wraps in body)\nif (data.body?.transcript && Array.isArray(data.body.transcript) && data.body.transcript.length > 0) {\n  console.log('✅ WEBHOOK ROUTE: Found transcript in body.transcript');\n  return [{ json: { route: 'webhook', meeting: data.body } }];\n}\n\n// Check direct transcript (if webhook doesn't wrap)\nif (data.transcript && Array.isArray(data.transcript) && data.transcript.length > 0) {\n  console.log('✅ WEBHOOK ROUTE: Found transcript at root level');\n  return [{ json: { route: 'webhook', meeting: data } }];\n}\n\n// No transcript found - fall back to API\nconsole.log('❌ NO TRANSCRIPT FOUND - Using API route');\nreturn [{ json: { route: 'api', daysBack: 60 } }];\n"
      },
      "id": "route-webhook-or-api",
      "name": "Route: Webhook or API",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        464,
        64
      ]
    },
    {
      "parameters": {
        "jsCode": "// Process single meeting from webhook\nconst routeData = $input.first().json;\nconst meeting = routeData.meeting;\n\n// VALIDATION: Check transcript exists\nconst transcript = meeting.transcript;\nif (!transcript || !Array.isArray(transcript) || transcript.length === 0) {\n  throw new Error('Invalid webhook payload: transcript is missing or empty');\n}\n\n// VALIDATION: Log first 100 chars of transcript for verification\nconst firstUtterance = transcript[0];\nconst speaker = (firstUtterance.speaker && firstUtterance.speaker.display_name) || 'Unknown';\nconst firstText = firstUtterance.text || '';\nconst preview = `${speaker}: ${firstText}`.substring(0, 100);\nconsole.log('✅ VALIDATION: Transcript first 100 chars:', preview);\n\n// Format transcript inline\nlet formattedTranscript = '';\nif (transcript && Array.isArray(transcript)) {\n  const parts = [];\n  for (let i = 0; i < transcript.length; i++) {\n    const utterance = transcript[i];\n    const speaker = (utterance.speaker && utterance.speaker.display_name) || 'Unknown';\n    parts.push(speaker + ': ' + utterance.text);\n  }\n  formattedTranscript = parts.join('\\n');\n}\n\n// VALIDATION: Check transcript content length\nif (formattedTranscript.length < 100) {\n  throw new Error(`Transcript appears too short: ${formattedTranscript.length} chars`);\n}\nconsole.log(`✅ VALIDATION: Transcript length: ${transcript.length} utterances, ${formattedTranscript.length} total chars`);\n\n// Format date inline\nconst dateStr = meeting.created_at || meeting.scheduled_start_time || new Date().toISOString();\nconst date = new Date(dateStr);\nconst day = date.getDate();\nconst month = date.toLocaleString('en-US', { month: 'long' });\nconst year = date.getFullYear();\n\n// Add ordinal suffix\nconst s = ['th', 'st', 'nd', 'rd'];\nconst v = day % 100;\nconst ordinal = day + (s[(v - 20) % 10] || s[v] || s[0]);\nconst dateFolderName = month + ' ' + ordinal + ', ' + year;\n\n// Check calendar_invitees for external contacts\nconst calendarInvitees = meeting.calendar_invitees || [];\nconst externalInvitees = [];\nfor (let i = 0; i < calendarInvitees.length; i++) {\n  if (calendarInvitees[i].is_external === true) {\n    externalInvitees.push(calendarInvitees[i]);\n  }\n}\n\n// Get contact info from first external invitee (if any)\nconst primaryContact = externalInvitees[0] || {};\n\n// Return array of items with json property\nconst result = {\n  json: {\n    meeting_title: meeting.title || meeting.meeting_title || 'Untitled Meeting',\n    meeting_url: meeting.url || meeting.meeting_url,\n    recording_id: meeting.recording_id,\n    contact_name: primaryContact.name || null,\n    contact_email: primaryContact.email || null,\n    meeting_date: dateStr,\n    date_folder_name: dateFolderName,\n    combined_transcript: formattedTranscript,\n    parent_folder_id: '1fzJztc3nweG6mzsEJOJBeaA6tk84jys9'\n  }\n};\nreturn [result];"
      },
      "id": "process-webhook-meeting",
      "name": "Process Webhook Meeting",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2256,
        160
      ]
    },
    {
      "parameters": {
        "jsCode": "// Limit to 5 meetings per batch to prevent rate limiting\nconst meetings = $input.all();\nconst batchLimit = $('Config').first().json.batchLimit || 5;\n\nconst limited = meetings.slice(0, batchLimit);\n\nif (limited.length < meetings.length) {\n  console.log(`Limited batch from ${meetings.length} to ${limited.length} meetings`);\n}\n\nreturn limited;"
      },
      "id": "limit-batch-size",
      "name": "Limit Batch Size",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2256,
        -32
      ]
    },
    {
      "parameters": {
        "jsCode": "// Build performance evaluation prompt\nconst data = $input.item.json;\n\n// Safely stringify any field (handles arrays, objects, null, undefined)\nfunction safe(val) {\n  if (val === null || val === undefined) return '';\n  if (typeof val === 'string') return val;\n  if (Array.isArray(val) || typeof val === 'object') return JSON.stringify(val);\n  return String(val);\n}\n\nconst meetingTitle = safe(data.meeting_title) || 'Unknown';\nconst meetingDate = safe(data.meeting_date) || '';\nconst contactName = safe(data.contact_name) || 'Unknown';\nconst contactEmail = safe(data.contact_email) || '';\nconst meetingUrl = safe(data.meeting_url) || '';\nconst recordingId = safe(data.recording_id) || '';\nconst summary = safe(data.summary) || '';\nconst painPoints = safe(data.pain_points) || '';\nconst keyInsights = safe(data.key_insights) || '';\nconst actionItems = safe(data.action_items) || '';\n\nconst prompt = `You are a meeting performance analyst specializing in sales call evaluation.\n\nAnalyze the following meeting analysis and provide a detailed performance evaluation.\n\n**CRITICAL:** You MUST include the following metadata fields in your JSON response using the EXACT values provided below:\n- meeting_title\n- meeting_date\n- contact_name\n- contact_email\n- meeting_url\n- recording_id\n\n**MEETING METADATA (include in JSON output):**\nmeeting_title: ${meetingTitle}\nmeeting_date: ${meetingDate}\ncontact_name: ${contactName}\ncontact_email: ${contactEmail}\nmeeting_url: ${meetingUrl}\nrecording_id: ${recordingId}\n\nReturn ONLY valid JSON with these fields:\n{\n  \"perf_performance_score\": <number 0-100>,\n  \"perf_improvement_areas\": \"<string>\",\n  \"perf_complexity_assessment\": \"<string>\",\n  \"perf_roadmap\": \"<string>\",\n  \"perf_framework_adherence\": \"<string>\",\n  \"perf_quantification_quality\": <number 0-100>,\n  \"perf_discovery_depth\": <number 0-100>,\n  \"perf_talk_ratio\": <number 0-100>,\n  \"perf_four_cs_coverage\": \"<string covering Cost, Calendar, Consequences, Complexity>\",\n  \"perf_key_questions\": \"<string>\",\n  \"perf_quantification_tactics\": \"<string>\",\n  \"perf_numbers_captured\": \"<string>\",\n  \"perf_quotable_moments\": \"<string>\",\n  \"perf_next_steps_clarity\": <number 0-100>,\n  \"perf_strengths\": \"<string>\",\n  \"meeting_title\": \"${meetingTitle}\",\n  \"meeting_date\": \"${meetingDate}\",\n  \"contact_name\": \"${contactName}\",\n  \"contact_email\": \"${contactEmail}\",\n  \"meeting_url\": \"${meetingUrl}\",\n  \"recording_id\": \"${recordingId}\"\n}\n\n**MEETING ANALYSIS SUMMARY:**\n${summary}\n\n**PAIN POINTS IDENTIFIED:**\n${painPoints}\n\n**KEY INSIGHTS:**\n${keyInsights}\n\n**ACTION ITEMS:**\n${actionItems}\n\nReturn ONLY valid JSON, no markdown formatting.`;\n\nreturn {\n  json: {\n    performance_prompt: prompt,\n    // Pass through all metadata\n    meeting_title: meetingTitle,\n    meeting_date: meetingDate,\n    contact_name: contactName,\n    contact_email: contactEmail,\n    meeting_url: meetingUrl,\n    recording_id: recordingId,\n    // Pass through analysis data for downstream use\n    summary: summary,\n    pain_points: painPoints,\n    key_insights: keyInsights,\n    action_items: actionItems\n  }\n};",
        "mode": "runOnceForEachItem"
      },
      "id": "build-performance-prompt",
      "name": "Build Performance Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3504,
        64
      ]
    },
    {
      "parameters": {
        "jsCode": "// CRITICAL FIX: Pass through ALL upstream data + add performance fields\n// Receives output from Call AI for Performance (OpenAI node)\n\nconst item = $input.item;\nconst inputData = item.json;\n\n// The AI response is in inputData.message.content (from OpenAI node)\nlet aiContent = '';\nif (inputData.message && inputData.message.content) {\n  aiContent = inputData.message.content;\n} else if (typeof inputData === 'string') {\n  aiContent = inputData;\n} else {\n  throw new Error('AI performance response not found in expected format');\n}\n\n// Parse the JSON response from GPT-4o\nlet parsed = {};\n\ntry {\n  // Try direct parse first\n  parsed = JSON.parse(aiContent);\n} catch (e1) {\n  try {\n    // Strip markdown code fences\n    let cleaned = aiContent.replace(/^```json\\s*/i, '').replace(/\\s*```$/, '');\n    parsed = JSON.parse(cleaned);\n  } catch (e2) {\n    try {\n      // Extract first complete JSON object\n      const jsonMatch = aiContent.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        parsed = JSON.parse(jsonMatch[0]);\n      } else {\n        throw new Error('No JSON object found in performance response');\n      }\n    } catch (e3) {\n      // Fallback: return error structure\n      console.error('Failed to parse performance response:', e3);\n      parsed = {\n        performance_summary: 'ERROR: Failed to parse performance analysis',\n        performance_metrics: '',\n        performance_trends: ''\n      };\n    }\n  }\n}\n\n// CRITICAL: The Build Performance Prompt node should have passed meeting metadata\n// through in the ai_prompt, and GPT-4o should have included it in the response.\n// If not present, we'll use fallbacks.\n\nreturn {\n  json: {\n    // Spread ALL parsed fields from GPT (includes performance analysis)\n    ...parsed,\n    // Ensure performance fields exist\n    performance_summary: parsed.performance_summary || '',\n    performance_metrics: parsed.performance_metrics || '',\n    performance_trends: parsed.performance_trends || '',\n    // Pass through meeting metadata (should be in parsed from GPT response)\n    meeting_title: parsed.meeting_title || 'Unknown',\n    meeting_date: parsed.meeting_date || '',\n    contact_name: parsed.contact_name || 'Unknown',\n    contact_email: parsed.contact_email || '',\n    meeting_url: parsed.meeting_url || '',\n    recording_id: parsed.recording_id || ''\n  }\n};\n"
      },
      "id": "parse-performance-response",
      "name": "Parse Performance Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4304,
        64
      ]
    },
    {
      "parameters": {
        "operation": "create",
        "base": {
          "__rl": true,
          "value": "appvd4nlsNhIWYdbI",
          "mode": "list",
          "cachedResultName": "Oloxa CRM",
          "cachedResultUrl": "https://airtable.com/appvd4nlsNhIWYdbI"
        },
        "table": {
          "__rl": true,
          "value": "tblRX43do0HJVOPgC",
          "mode": "list",
          "cachedResultName": "Call Performance",
          "cachedResultUrl": "https://airtable.com/appvd4nlsNhIWYdbI/tblRX43do0HJVOPgC"
        },
        "columns": {
          "mappingMode": "autoMapInputData",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": true,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "id": "save-performance-to-airtable",
      "name": "Save Performance to Airtable",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [
        6448,
        64
      ],
      "credentials": {
        "airtableTokenApi": {
          "id": "7Nw3lCcZ0ETUwNak",
          "name": "airtable-creds"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.route }}",
              "rightValue": "webhook",
              "operator": {
                "type": "string",
                "operation": "equals"
              },
              "id": "route-check"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "789e9ac9-a050-43fd-b0c3-27473d9ed641",
      "name": "IF: Webhook or API?1",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        688,
        64
      ]
    },
    {
      "parameters": {},
      "id": "limit-to-one-record",
      "name": "Limit to 1 Record",
      "type": "n8n-nodes-base.limit",
      "typeVersion": 1,
      "position": [
        5424,
        -8
      ]
    },
    {
      "parameters": {
        "otherOptions": {}
      },
      "id": "slack-notification",
      "name": "Slack Notification",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.4,
      "position": [
        6896,
        16
      ],
      "webhookId": "da14729d-63c5-41af-9f51-f9616c04781a",
      "credentials": {
        "slackApi": {
          "id": "iN2b9bGFpoyptSPr",
          "name": "slack-workflow-notifications"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "const saveToAirtableData = $('Save to Airtable').item.json;\nconst performanceData = $('Save Performance to Airtable').item.json;\nconst parseAIData = $('Parse AI Response').first().json;\n\nconst clientName = saveToAirtableData.matched_client_name || 'Unknown';\nconst contactName = saveToAirtableData.matched_contact_name || 'Unknown';\nconst performanceScore = performanceData.perf_overall_score || 'N/A';\nconst topPainPoint = (parseAIData.pain_points && parseAIData.pain_points[0]) || 'Not identified';\n\nconst blocks = [\n  {\n    type: 'section',\n    text: {\n      type: 'mrkdwn',\n      text: '📞 *Call Analysis Complete*\\n\\n*Client:* ' + clientName + '\\n*Contact:* ' + contactName + '\\n*Performance Score:* ' + performanceScore + '/100\\n\\n*Top Pain Point:* ' + topPainPoint\n    }\n  },\n  {\n    type: 'actions',\n    elements: [\n      {\n        type: 'button',\n        text: { type: 'plain_text', text: 'Create Proposal (Company)' },\n        value: 'proposal_company',\n        action_id: 'proposal_company'\n      },\n      {\n        type: 'button',\n        text: { type: 'plain_text', text: 'Create Proposal (Individual)' },\n        value: 'proposal_individual',\n        action_id: 'proposal_individual'\n      },\n      {\n        type: 'button',\n        text: { type: 'plain_text', text: 'Send to Figma' },\n        value: 'send_figma',\n        action_id: 'send_figma'\n      },\n      {\n        type: 'button',\n        text: { type: 'plain_text', text: 'Send to Slides' },\n        value: 'send_slides',\n        action_id: 'send_slides',\n        style: 'primary'\n      },\n      {\n        type: 'button',\n        text: { type: 'plain_text', text: 'Do Nothing' },\n        value: 'do_nothing',\n        action_id: 'do_nothing'\n      }\n    ]\n  }\n];\n\nreturn {\n  json: {\n    slackBlocks: JSON.stringify(blocks),\n    ...performanceData\n  }\n};"
      },
      "id": "build-slack-blocks",
      "name": "Build Slack Blocks",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6672,
        16
      ]
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "GPT-4O-MINI"
        },
        "messages": {
          "values": [
            {
              "content": "={{ $json.ai_prompt }}  ",
              "role": "system"
            }
          ]
        },
        "options": {
          "temperature": 0
        }
      },
      "id": "call-ai-for-analysis",
      "name": "Call AI for Analysis",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        2704,
        136
      ],
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 5000,
      "credentials": {
        "openAiApi": {
          "id": "xmJ7t6kaKgMwA1ce",
          "name": "OpenAi account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "GPT-4O-MINI"
        },
        "messages": {
          "values": [
            {
              "content": "={{ $json.performance_prompt }}",
              "role": "system"
            }
          ]
        },
        "options": {
          "temperature": 0
        }
      },
      "id": "call-ai-performance",
      "name": "Call AI for Performance",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        3728,
        136
      ],
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 5000,
      "credentials": {
        "openAiApi": {
          "id": "xmJ7t6kaKgMwA1ce",
          "name": "OpenAi account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Get data from Merge node\n// Input 0: Parse Performance Response (has perf_* fields + meeting data)\n// Input 1: Save to Airtable (has Airtable record with id field)\nconst items = $input.all();\n\n// Separate the two data sources\nlet perfData = null;\nlet callsRecord = null;\n\nfor (const item of items) {\n  // Check if this is the Airtable record (has id field from Airtable)\n  if (item.json.id && item.json.fields) {\n    callsRecord = item.json;\n  }\n  // Check if this is performance data (has perf_performance_score field)\n  if (item.json.perf_performance_score !== undefined || item.json.performance_score !== undefined) {\n    perfData = item.json;\n  }\n}\n\n// Fallback defaults\nif (!callsRecord) {\n  callsRecord = { id: 'unknown' };\n}\nif (!perfData) {\n  perfData = {};\n}\n\n// Helper to convert to number safely\nconst toNum = (v) => { \n  const n = Number(v); \n  return isNaN(n) ? 0 : n; \n};\n\n// Build the performance record for Airtable\nconst result = {\n  \"Call Title\": perfData.meeting_title || perfData.contact_name || perfData.participant_name || perfData.title || \"Unknown\",\n  \"Call\": [callsRecord.id],\n  \"Overall Score\": toNum(perfData.perf_performance_score || perfData.performance_score),\n  \"Framework Adherence\": String(perfData.perf_framework_adherence || perfData.framework_adherence || \"\"),\n  \"Quantification Quality\": toNum(perfData.perf_quantification_quality || perfData.quantification_quality),\n  \"Discovery Depth\": toNum(perfData.perf_discovery_depth || perfData.discovery_depth),\n  \"Talk Ratio\": toNum(perfData.perf_talk_ratio || perfData.talk_ratio),\n  \"4 C's Coverage\": String(perfData.perf_4cs_coverage || perfData[\"4cs_coverage\"] || \"\"),\n  \"Key Questions Asked\": String(perfData.perf_key_questions || perfData.perf_key_questions_asked || perfData.key_questions_asked || \"\"),\n  \"Quantification Tactics Used\": String(perfData.perf_quantification_tactics || perfData.quantification_tactics || \"\"),\n  \"Numbers Captured\": String(perfData.perf_numbers_captured || perfData.numbers_captured || \"\"),\n  \"Quotable Moments\": String(perfData.perf_quotable_moments || perfData.quotable_moments || \"\"),\n  \"Next Steps Clarity\": toNum(perfData.perf_next_steps_clarity || perfData.next_steps_clarity),\n  \"Improvement Areas\": String(perfData.perf_improvement_areas || perfData.improvement_areas || \"\"),\n  \"Strengths\": String(perfData.perf_strengths || perfData.strengths || \"\")\n};\n\nreturn [{ json: result }];"
      },
      "id": "prepare-performance-data",
      "name": "Prepare Performance Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6224,
        64
      ]
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "id": "merge-performance-data",
      "name": "Merge Performance Data",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        5936,
        64
      ]
    },
    {
      "id": "merge-search-data",
      "name": "Merge Search Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        4988,
        -8
      ],
      "parameters": {
        "jsCode": "// CRITICAL FIX: Properly merge data from multiple upstream branches\n// Merge node receives 4 inputs:\n// - Parse AI Response (has analysis fields)\n// - Parse Performance Response (has performance data)\n// - Search Contacts (optional)\n// - Search Clients (optional)\n\n// Get ALL items from all branches\nconst allItems = $input.all();\n\n// Initialize data containers\nlet aiAnalysisData = {};\nlet performanceData = {};\nlet contactData = null;\nlet clientData = null;\n\n// Process each input item and categorize by source\nfor (const item of allItems) {\n  const data = item.json;\n  \n  // Detect Parse AI Response output (has summary, pain_points, etc.)\n  if (data.summary || data.pain_points || data.quick_wins) {\n    aiAnalysisData = data;\n    continue;\n  }\n  \n  // Detect Parse Performance Response output (has perf_ fields)\n  if (data.perf_performance_score !== undefined || data.perf_improvement_areas) {\n    performanceData = data;\n    continue;\n  }\n  \n  // Detect Airtable search results\n  if (data.fields) {\n    // Has Airtable fields structure\n    if (data.fields.Name && data.fields.Email) {\n      contactData = data;\n    } else if (data.fields[' Company Name'] || data.fields['Company Name']) {\n      clientData = data;\n    }\n  }\n}\n\n// Merge ALL data sources\nreturn {\n  json: {\n    // 1. Core metadata (prefer from performance node as it may be more recent)\n    meeting_title: performanceData.meeting_title || aiAnalysisData.meeting_title || 'Unknown',\n    meeting_date: performanceData.meeting_date || aiAnalysisData.meeting_date || '',\n    contact_name: performanceData.contact_name || aiAnalysisData.contact_name || 'Unknown',\n    contact_email: performanceData.contact_email || aiAnalysisData.contact_email || '',\n    meeting_url: performanceData.meeting_url || aiAnalysisData.meeting_url || '',\n    recording_id: performanceData.recording_id || aiAnalysisData.recording_id || '',\n    \n    // 2. AI Analysis fields from Parse AI Response\n    summary: aiAnalysisData.summary || '',\n    pain_points: aiAnalysisData.pain_points || '',\n    quick_wins: aiAnalysisData.quick_wins || '',\n    action_items: aiAnalysisData.action_items || '',\n    key_insights: aiAnalysisData.key_insights || '',\n    pricing_strategy: aiAnalysisData.pricing_strategy || '',\n    client_journey_map: aiAnalysisData.client_journey_map || '',\n    requirements: aiAnalysisData.requirements || '',\n    \n    // 3. Performance fields from Parse Performance Response\n    perf_performance_score: performanceData.perf_performance_score || 0,\n    perf_improvement_areas: performanceData.perf_improvement_areas || '',\n    perf_complexity_assessment: performanceData.perf_complexity_assessment || '',\n    perf_roadmap: performanceData.perf_roadmap || '',\n    performance_summary: performanceData.performance_summary || '',\n    performance_metrics: performanceData.performance_metrics || '',\n    performance_trends: performanceData.performance_trends || '',\n    \n    // 4. Search results\n    matched_contact: contactData,\n    matched_client: clientData,\n    matched_contact_name: contactData?.fields?.Name || contactData?.Name || performanceData.contact_name || aiAnalysisData.contact_name || 'Unknown',\n    matched_client_name: clientData?.fields?.[' Company Name'] || clientData?.['Company Name'] || 'Unknown',\n    \n    // 5. Debug info\n    _debug: {\n      has_ai_analysis: Object.keys(aiAnalysisData).length > 0,\n      has_performance: Object.keys(performanceData).length > 0,\n      has_contact: !!contactData,\n      has_client: !!clientData,\n      ai_fields_count: Object.keys(aiAnalysisData).length,\n      perf_fields_count: Object.keys(performanceData).length,\n      total_items_received: allItems.length\n    }\n  }\n};\n"
      }
    }
  ],
  "connections": {
    "Daily Schedule": {
      "main": [
        [
          {
            "node": "Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Config": {
      "main": [
        [
          {
            "node": "List Meetings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "List Meetings": {
      "main": [
        [
          {
            "node": "Extract Meetings Array",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Meetings Array": {
      "main": [
        [
          {
            "node": "Get Transcript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Transcript": {
      "main": [
        [
          {
            "node": "Combine Meeting + Transcript1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to Binary": {
      "main": [
        [
          {
            "node": "Save Transcript to Drive",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Standalone Impromptu?": {
      "main": [
        [
          {
            "node": "Build AI Prompt",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Build AI Prompt": {
      "main": [
        [
          {
            "node": "Extract Name (OpenAI)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Name (OpenAI)": {
      "main": [
        [
          {
            "node": "Extract AI Name",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract AI Name": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Prepare Date Folder Name",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Meeting + Transcript1": {
      "main": [
        [
          {
            "node": "Process Each Meeting",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Date Folder Name": {
      "main": [
        [
          {
            "node": "Get Unique Dates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Unique Dates": {
      "main": [
        [
          {
            "node": "Create or Get Date Folder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create or Get Date Folder": {
      "main": [
        [
          {
            "node": "Match Meetings to Folders",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Match Meetings to Folders": {
      "main": [
        [
          {
            "node": "Convert to Binary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Participant Names": {
      "main": [
        [
          {
            "node": "Search Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search Contacts": {
      "main": [
        [
          {
            "node": "Search Clients",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Route: Webhook or API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route: Webhook or API": {
      "main": [
        [
          {
            "node": "IF: Webhook or API?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Webhook Meeting": {
      "main": [
        [
          {
            "node": "Enhanced AI Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Each Meeting": {
      "main": [
        [
          {
            "node": "Limit Batch Size",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Limit Batch Size": {
      "main": [
        [
          {
            "node": "Enhanced AI Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse AI Response": {
      "main": [
        [
          {
            "node": "Build Performance Prompt",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Search Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Performance Response": {
      "main": [
        [
          {
            "node": "Extract Participant Names",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Performance Data",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Save to Airtable": {
      "main": [
        [
          {
            "node": "Merge Performance Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Performance to Airtable": {
      "main": [
        [
          {
            "node": "Prepare Date Folder Name",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Slack Blocks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Route: Webhook or API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF: Webhook or API?1": {
      "main": [
        [
          {
            "node": "Process Webhook Meeting",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Airtable Data": {
      "main": [
        [
          {
            "node": "Limit to 1 Record",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Limit to 1 Record": {
      "main": [
        [
          {
            "node": "Save to Airtable",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Slack Blocks": {
      "main": [
        [
          {
            "node": "Slack Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enhanced AI Analysis": {
      "main": [
        [
          {
            "node": "Call AI for Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Performance Prompt": {
      "main": [
        [
          {
            "node": "Call AI for Performance",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Performance Data": {
      "main": [
        [
          {
            "node": "Save Performance to Airtable",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Performance Data": {
      "main": [
        [
          {
            "node": "Prepare Performance Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call AI for Analysis": {
      "main": [
        [
          {
            "node": "Parse AI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call AI for Performance": {
      "main": [
        [
          {
            "node": "Parse Performance Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search Clients": {
      "main": [
        [
          {
            "node": "Merge Search Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Search Data": {
      "main": [
        [
          {
            "node": "Prepare Airtable Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}
